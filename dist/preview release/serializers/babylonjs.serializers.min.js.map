{"version":3,"sources":["webpack://SERIALIZERS/webpack/universalModuleDefinition","webpack://SERIALIZERS/webpack/bootstrap","webpack://SERIALIZERS/external {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/OBJ/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/glTFFileExporter.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFUtilities.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFData.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFExporter.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFAnimation.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFMaterialExporter.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFSerializer.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/Extensions/index.ts","webpack://SERIALIZERS/../node_modules/webpack/buildin/global.js","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/legacy/legacy.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/OBJ/objSerializer.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFExporterExtension.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/Extensions/KHR_texture_transform.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/shaders/textureTransform.fragment.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/legacy/legacy-glTF2Serializer.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/legacy/legacy-objSerializer.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__export","__IGLTFExporterExtension","babylonjs_1","_GLTFUtilities","_CreateBufferView","bufferIndex","byteOffset","byteLength","byteStride","bufferview","buffer","_CreateAccessor","bufferviewIndex","type","componentType","count","min","max","accessor","bufferView","_CalculateMinMaxPositions","positions","vertexStart","vertexCount","convertToRightHandedSystem","indexOffset","position","vector","Infinity","length_1","Vector3","FromArray","_GetRightHandedPositionVector3FromRef","asArray","j","num","_GetRightHandedPositionVector3","x","y","z","_GetRightHandedPositionArray3FromRef","_GetRightHandedNormalVector3","_GetRightHandedNormalVector3FromRef","_GetRightHandedNormalArray3FromRef","_GetRightHandedVector4FromRef","w","_GetRightHandedArray4FromRef","_GetRightHandedQuaternionFromRef","quaternion","_GetRightHandedQuaternionArrayFromRef","_NormalizeTangentFromRef","tangent","length","Math","sqrt","GLTFData","this","glTFFiles","downloadFiles","endsWith","str","suffix","indexOf","link","document","createElement","body","appendChild","setAttribute","download","blob","mimeType","href","URL","createObjectURL","Blob","click","glTFMaterialExporter_1","glTFUtilities_1","glTFData_1","glTFAnimation_1","_Exporter","babylonScene","options","_extensions","_asset","generator","version","_extensionsUsed","_extensionsRequired","_babylonScene","_bufferViews","_accessors","_meshes","_scenes","_nodes","_images","_materials","_materialMap","_textures","_samplers","_animations","_imageData","_convertToRightHandedSystem","useRightHandedSystem","_options","_shouldExportTransformNode","shouldExportTransformNode","babylonTransformNode","_animationSampleRate","animationSampleRate","_glTFMaterialExporter","_GLTFMaterialExporter","_loadExtensions","_applyExtensions","actionAsync","_i","_a","_ExtensionNames","name_1","extension","enabled","exporterProperty","_activeLoaderExtensions","activeLoaderExtensions","result","_extensionsPreExportTextureAsync","context","babylonTexture","preExportTextureAsync","_extensionsPostExportMeshPrimitiveAsync","meshPrimitive","babylonSubMesh","binaryWriter","postExportMeshPrimitiveAsync","name_2","_ExtensionFactories","RegisterExtension","UnregisterExtension","Tools","Warn","push","index","splice","_getLocalEngine","_localEngine","localCanvas","id","width","height","Engine","premultipliedAlpha","preserveDrawingBuffer","setViewport","Viewport","reorderIndicesBasedOnPrimitiveMode","submesh","primitiveMode","babylonIndices","Material","TriangleFillMode","indexStart","indexCount","secondIndex","getUInt32","thirdIndex","setUInt32","TriangleFanDrawMode","start","TriangleStripDrawMode","reorderVertexAttributeDataBasedOnPrimitiveMode","sideOrientation","vertexBufferKind","meshAttributeArray","ClockWiseSideOrientation","reorderTriangleFillMode","reorderTriangleStripDrawMode","reorderTriangleFanMode","vertexBuffer","getVertexBufferFromMesh","getMesh","stride","VertexBuffer","GetTypeByteLength","verticesCount","Error","vertexData","PositionKind","NormalKind","verticesStart","TangentKind","Vector4","ColorKind","size","getSize","UVKind","UV2Kind","Vector2","writeVertexAttributeData","vertices","vertexAttributeKind","vertices_1","vertex","normalize","_b","component","setFloat32","writeAttributeData","vertexAttributes","k","length_2","length_3","length_4","length_5","length_6","vertexAttributes_1","vertexAttribute_1","generateJSON","shouldUseGlb","glTFPrefix","prettyPrint","imageName","imageData","_this","_totalByteLength","glTF","asset","extensionsUsed","extensionsRequired","buffers","nodes","meshes","scenes","scene","bufferViews","accessors","animations","materials","textures","samplers","images","forEach","image","uri","split","data","undefined","JSON","stringify","_generateGLTFAsync","_generateBinaryAsync","then","binaryBuffer","jsonText","bin","glTFFileName","glTFBinFile","container","_BinaryWriter","createSceneAsync","dispose","getArrayBuffer","_getPadding","remainder","_generateGLBAsync","glbFileName","jsonLength","imageByteLength","jsonPadding","binPadding","imagePadding","headerLength","headerBuffer","ArrayBuffer","headerBufferView","DataView","setUint32","jsonChunkBuffer","jsonChunkBufferView","jsonData","Uint8Array","charCodeAt","jsonPaddingView","binaryChunkBuffer","binaryChunkBufferView","binPaddingBuffer","binPaddingView","imagePaddingBuffer","imagePaddingView","glbData","glbFile","setNodeTransformation","node","getPivotPoint","equalsToFloats","BABYLON","translation","scaling","scale","rotationQuaternion","Quaternion","RotationYawPitchRoll","rotation","multiplyInPlace","attributeKind","bufferMesh","isVerticesDataPresent","getVertexBuffer","createBufferViewKind","kind","Mesh","InstancedMesh","sourceMesh","getVerticesData","getByteOffset","getMeshPrimitiveMode","babylonMesh","LinesMesh","LineListDrawMode","material","fillMode","setPrimitiveMode","PointListDrawMode","PointFillMode","LineLoopDrawMode","LineStripDrawMode","setAttributeKind","attributes","POSITION","NORMAL","COLOR_0","TANGENT","TEXCOORD_0","TEXCOORD_1","setPrimitiveAttributesAsync","mesh","uvCoordsPresent","minMax","promises","attributeData","accessorType","indexBufferViewIndex","vertexAttributeBufferViews","attributeData_1","attribute","DeduceStride","bufferViewIndex","getTotalIndices","indices","getIndices","length_7","subMeshes","babylonMaterial","getMaterial","getScene","defaultMaterial","materialIndex","color","equals","Color3","White","alpha","pbrMetallicRoughness","baseColorFactor","concat","MultiMaterial","subMaterial","subMaterials","uniqueId","glTFMaterial","_c","attributeData_2","_hasTexturesPresent","keys","_d","attributeData_3","byteOffset_1","newMat","_stripTexturesFromMaterial","primitives","Promise","all","glTFNodeIndex","glTFNode","directDescendents","transformNodes","_convertMaterialsToGLTFAsync","createNodeMapAndAnimationsAsync","nodeMap","_nodeMap","nodes_1","parent","multiply","Log","getDescendants","children","directDescendents_1","descendent","nodeIndex","promiseChain","resolve","runtimeGLTFAnimation","channels","idleGLTFAnimations","createNodeAsync","TransformNode","animationGroups","_GLTFAnimation","_CreateNodeAnimationFromTransformNodeAnimations","nodes_2","idleGLTFAnimation","_CreateNodeAnimationFromAnimationGroups","Array","_arrayBuffer","_dataView","_byteOffset","resizeBuffer","newBuffer","oldUint8Array","newUint8Array","length_8","setUInt8","entry","setUint8","getUint32","getVector3Float32FromRef","vector3","getFloat32","setVector3Float32FromRef","getVector4Float32FromRef","vector4","setVector4Float32FromRef","isNaN","_TangentType","_CreateNodeAnimation","animation","animationChannelTargetPath","useQuaternion","inputs","outputs","keyFrames","getKeys","minMaxKeyFrames","calculateMinMaxKeyFrames","interpolationOrBake","_DeduceInterpolation","frameDelta","interpolation","interpolationType","shouldBakeAnimation","_CreateBakedAnimation","framePerSecond","_CreateLinearOrStepAnimation","_CreateCubicSplineAnimation","samplerInterpolation","inputsMin","FloatRound","inputsMax","_DeduceAnimationInfo","dataAccessorType","targetProperty","glTFAnimation","animationInfo","AddAnimation","hasRunningRuntimeAnimations","glTFAnimations","animationGroups_1","animationGroup","targetedAnimations","targetAnimation","target","keyframeAccessorIndex","dataAccessorIndex","outputLength","animationSampler","animationChannel","animationData","input","output","sampler","path","minFrame","maxFrame","fps","sampleRate","minMaxFrames","time","quaternionCache","Identity","previousTime","maxUsedFrame","currKeyFrame","nextKeyFrame","prevKeyFrame","endFrame","frame","f","_interpolate","loopMode","_SetInterpolatedValue","_ConvertFactorToVector3OrQuaternion","factor","animationType","componentName","basePositionRotationOrScale","_GetBasePositionRotationOrScale","Animation","ANIMATIONTYPE_FLOAT","cacheValue","dataType","RotationYawPitchRollToRef","keyFrame","_AddKeyframeValue","AddSplineTangent","INTANGENT","OUTTANGENT","newPositionRotationOrScale","ANIMATIONTYPE_VECTOR3","array","posRotScale","ANIMATIONTYPE_QUATERNION","inTangent","outTangent","AnimationKeyInterpolation","STEP","tangentType","tangentValue","exporter","_textureMap","_exporter","FuzzyEquals","color1","color2","epsilon","Scalar","WithinEpsilon","g","b","babylonMaterials","hasTextureCoords","babylonMaterials_1","StandardMaterial","_convertStandardMaterialAsync","PBRMetallicRoughnessMaterial","_convertPBRMetallicRoughnessMaterialAsync","PBRMaterial","_convertPBRMaterialAsync","originalMaterial","newMaterial","doubleSided","alphaMode","alphaCutoff","emissiveFactor","originalPBRMetallicRoughness","metallicFactor","roughnessFactor","emissiveTexture","normalTexture","occlusionTexture","pbrMat","baseColorTexture","metallicRoughnessTexture","_convertToGLTFPBRMetallicRoughness","babylonStandardMaterial","P0","P1","P2","P3","diffuse","diffuseColor","toLinearSpace","opacity","roughness","specularPower","p0","p1","p2","p3","_cubicBezierCurve","pow","_solveForRoughness","Clamp","_MaxSpecularPower","_SolveMetallic","specular","oneMinusSpecularStrength","_DielectricSpecular","a","D","_getAlphaMode","needAlphaBlending","needAlphaTesting","materialMap","glTFPbrMetallicRoughness","backFaceCulling","twoSidedLighting","diffuseTexture","_exportTextureAsync","glTFTexture","bumpTexture","level","glTFEmissiveTexture","ambientTexture","strength","opacityTexture","ALPHA_COMBINE","toString","emissiveColor","Black","_Epsilon","alphaCutOff","babylonPBRMetalRoughMaterial","baseColor","metallic","transparencyMode","baseTexture","occlusionStrength","_createBase64FromCanvasAsync","reject","hostingScene","textureType","TEXTURETYPE_UNSIGNED_INT","engine","Scene","tempTexture","createRawTexture","TEXTUREFORMAT_RGBA","Texture","NEAREST_SAMPLINGMODE","postProcess","PostProcess","getEffect","executeWhenCompiled","onApply","effect","_bindTexture","setSize","postProcessManager","directRender","canvas","getRenderingCanvas","toBlob","ToBlob","fileReader","FileReader","onload","event","base64String","readAsDataURL","dataURL","toDataURL","_createWhiteTexture","RawTexture","CreateRGBATexture","_resizeTexturesToSameDimensions","texture1","texture2","resizedTexture1","resizedTexture2","texture1Size","texture2Size","TextureTools","CreateResizedCopy","_convertPixelArrayToFloat32","pixels","Float32Array","_convertSpecularGlossinessTexturesToMetallicRoughnessAsync","specularGlossinessTexture","factors","resizedTextures","diffuseSize","diffuseBuffer","specularGlossinessBuffer","diffusePixels","readPixels","specularPixels","metallicRoughnessBuffer","baseColorBuffer","maxBaseColor","maxMetallic","maxRoughness","h","offset","specularGlossiness","specularColor","glossiness","metallicRoughness","_convertSpecularGlossinessToMetallicRoughness","hasAlpha","metallicRoughnessFactors_1","writeOutMetallicRoughnessTexture","writeOutBaseColorTexture","destinationOffset","sRGBBaseColorPixel","FromInts","toGammaSpace","metallicRoughnessPixel","promise","metallicRoughnessBase64","metallicRoughnessTextureBase64","baseColorBase64","baseColorTextureBase64","diffusePerceivedBrightness","_getPerceivedBrightness","specularPerceivedBrightness","_getMaxComponent","baseColorFromDiffuse","baseColorFromSpecular","subtract","Lerp","clampToRef","_convertMetalRoughFactorsToMetallicRoughnessAsync","babylonPBRMaterial","albedoColor","albedoTexture","metallicTexture","_getGLTFTextureSampler","texture","_getGLTFTextureWrapModesSampler","samplingMode","LINEAR_LINEAR","magFilter","minFilter","LINEAR_NEAREST","NEAREST_LINEAR","NEAREST_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","NEAREST_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","LINEAR_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPNEAREST","_getGLTFTextureWrapMode","wrapMode","WRAP_ADDRESSMODE","CLAMP_ADDRESSMODE","MIRROR_ADDRESSMODE","wrapS","wrapU","wrapT","wrapV","_convertSpecGlossFactorsToMetallicRoughnessAsync","specGloss","reflectivityColor","microSurface","samplerIndex","reflectivityTexture","useMicroSurfaceFromReflectivityMapAlpha","metallicRoughnessFactors","glTFBaseColorTexture","_getTextureInfoFromBase64","coordinatesIndex","glTFMRColorTexture","isMetallicWorkflow","setMetallicRoughnessPbrMaterial","ambientTextureStrength","getPixelsFromTexture","extensionPromise","_exportTextureInfoAsync","textureUid","uid","samplerIndex_1","foundSamplerIndex","base64Data","textureInfo","replace","base64Texture","baseTextureName","texCoordIndex","source","binStr","atob","arrBuff","arr","imageValues","textureName","RandomId","glTFImage","foundIndex","texCoord","glTFExporter_1","GLTF2Export","GLTFAsync","filePrefix","whenReadyAsync","_PreExportAsync","exportWithoutWaitingForScene","_PostExportAsync","glTFData","GLBAsync","Function","eval","e","OBJExport","OBJ","matlibname","globalposition","v","lastMatrix","newMatrix","Matrix","Translation","bakeTransformIntoVertices","mat","geometry","trunkVerts","trunkNormals","trunkUV","trunkFaces","curV","String","blanks","facePositions","faceUVs","faceNormals","join","MTL","toFixed","ambientColor","specularTexture","__IGLTFExporterExtensionV2","NAME","KHR_texture_transform","required","texture_transform_extension","uOffset","vOffset","uScale","vScale","wAng","One","Zero","textureTransformTextureAsync","proceduralTexture","ProceduralTexture","setTexture","setMatrix","getTextureMatrix","isReady","render","shader","Effect","ShadersStore","Exporters","Datas","Serializers","Extensions","GLTF2","globalObject","global","Exporter","serializer"],"mappings":"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","file":"babylonjs.serializers.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-serializers\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-serializers\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"SERIALIZERS\"] = factory(root[\"BABYLON\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","export * from \"./objSerializer\";","/** @hidden */\r\nexport var __IGLTFExporterExtension = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for extending the exporter\r\n * @hidden\r\n */\r\nexport interface IGLTFExporterExtension {\r\n    /**\r\n     * The name of this extension\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * Defines whether this extension is enabled\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines whether this extension is required\r\n     */\r\n    required: boolean;\r\n}","export * from \"./glTFAnimation\";\r\nexport * from \"./glTFData\";\r\nexport * from \"./glTFExporter\";\r\nexport * from \"./glTFExporterExtension\";\r\nexport * from \"./glTFMaterialExporter\";\r\nexport * from \"./glTFSerializer\";\r\nexport * from \"./glTFUtilities\";\r\nexport * from \"./Extensions\";","import { Nullable, FloatArray, Vector3, Vector4, Quaternion } from \"babylonjs\";\r\nimport { IBufferView, AccessorType, AccessorComponentType, IAccessor } from \"babylonjs-gltf2interface\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class _GLTFUtilities {\r\n    /**\r\n     * Creates a buffer view based on the supplied arguments\r\n     * @param bufferIndex index value of the specified buffer\r\n     * @param byteOffset byte offset value\r\n     * @param byteLength byte length of the bufferView\r\n     * @param byteStride byte distance between conequential elements\r\n     * @param name name of the buffer view\r\n     * @returns bufferView for glTF\r\n     */\r\n    public static _CreateBufferView(bufferIndex: number, byteOffset: number, byteLength: number, byteStride?: number, name?: string): IBufferView {\r\n        let bufferview: IBufferView = { buffer: bufferIndex, byteLength: byteLength };\r\n        if (byteOffset) {\r\n            bufferview.byteOffset = byteOffset;\r\n        }\r\n        if (name) {\r\n            bufferview.name = name;\r\n        }\r\n        if (byteStride) {\r\n            bufferview.byteStride = byteStride;\r\n        }\r\n\r\n        return bufferview;\r\n    }\r\n\r\n    /**\r\n     * Creates an accessor based on the supplied arguments\r\n     * @param bufferviewIndex The index of the bufferview referenced by this accessor\r\n     * @param name The name of the accessor\r\n     * @param type The type of the accessor\r\n     * @param componentType The datatype of components in the attribute\r\n     * @param count The number of attributes referenced by this accessor\r\n     * @param byteOffset The offset relative to the start of the bufferView in bytes\r\n     * @param min Minimum value of each component in this attribute\r\n     * @param max Maximum value of each component in this attribute\r\n     * @returns accessor for glTF\r\n     */\r\n    public static _CreateAccessor(bufferviewIndex: number, name: string, type: AccessorType, componentType: AccessorComponentType, count: number, byteOffset: Nullable<number>, min: Nullable<number[]>, max: Nullable<number[]>): IAccessor {\r\n        let accessor: IAccessor = { name: name, bufferView: bufferviewIndex, componentType: componentType, count: count, type: type };\r\n\r\n        if (min != null) {\r\n            accessor.min = min;\r\n        }\r\n        if (max != null) {\r\n            accessor.max = max;\r\n        }\r\n        if (byteOffset != null) {\r\n            accessor.byteOffset = byteOffset;\r\n        }\r\n\r\n        return accessor;\r\n    }\r\n\r\n    /**\r\n     * Calculates the minimum and maximum values of an array of position floats\r\n     * @param positions Positions array of a mesh\r\n     * @param vertexStart Starting vertex offset to calculate min and max values\r\n     * @param vertexCount Number of vertices to check for min and max values\r\n     * @returns min number array and max number array\r\n     */\r\n    public static _CalculateMinMaxPositions(positions: FloatArray, vertexStart: number, vertexCount: number, convertToRightHandedSystem: boolean): { min: number[], max: number[] } {\r\n        const min = [Infinity, Infinity, Infinity];\r\n        const max = [-Infinity, -Infinity, -Infinity];\r\n        const positionStrideSize = 3;\r\n        let indexOffset: number;\r\n        let position: Vector3;\r\n        let vector: number[];\r\n\r\n        if (vertexCount) {\r\n            for (let i = vertexStart, length = vertexStart + vertexCount; i < length; ++i) {\r\n                indexOffset = positionStrideSize * i;\r\n\r\n                position = Vector3.FromArray(positions, indexOffset);\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(position);\r\n                }\r\n                vector = position.asArray();\r\n\r\n                for (let j = 0; j < positionStrideSize; ++j) {\r\n                    let num = vector[j];\r\n                    if (num < min[j]) {\r\n                        min[j] = num;\r\n                    }\r\n                    if (num > max[j]) {\r\n                        max[j] = num;\r\n                    }\r\n                    ++indexOffset;\r\n                }\r\n            }\r\n        }\r\n        return { min, max };\r\n    }\r\n\r\n    /**\r\n     * Converts a new right-handed Vector3\r\n     * @param vector vector3 array\r\n     * @returns right-handed Vector3\r\n     */\r\n    public static _GetRightHandedPositionVector3(vector: Vector3): Vector3 {\r\n        return new Vector3(vector.x, vector.y, -vector.z);\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector3 to right-handed\r\n     * @param vector Vector3 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedPositionVector3FromRef(vector: Vector3) {\r\n        vector.z *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a three element number array to right-handed\r\n     * @param vector number array to convert to right-handed\r\n     */\r\n    public static _GetRightHandedPositionArray3FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a new right-handed Vector3\r\n     * @param vector vector3 array\r\n     * @returns right-handed Vector3\r\n     */\r\n    public static _GetRightHandedNormalVector3(vector: Vector3): Vector3 {\r\n        return new Vector3(vector.x, vector.y, -vector.z);\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector3 to right-handed\r\n     * @param vector Vector3 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedNormalVector3FromRef(vector: Vector3) {\r\n        vector.z *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a three element number array to right-handed\r\n     * @param vector number array to convert to right-handed\r\n     */\r\n    public static _GetRightHandedNormalArray3FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector4 to right-handed\r\n     * @param vector Vector4 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedVector4FromRef(vector: Vector4) {\r\n        vector.z *= -1;\r\n        vector.w *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector4 to right-handed\r\n     * @param vector Vector4 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedArray4FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n        vector[3] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Quaternion to right-handed\r\n     * @param quaternion Source quaternion to convert to right-handed\r\n     */\r\n    public static _GetRightHandedQuaternionFromRef(quaternion: Quaternion) {\r\n        quaternion.x *= -1;\r\n        quaternion.y *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Quaternion to right-handed\r\n     * @param quaternion Source quaternion to convert to right-handed\r\n     */\r\n    public static _GetRightHandedQuaternionArrayFromRef(quaternion: number[]) {\r\n        quaternion[0] *= -1;\r\n        quaternion[1] *= -1;\r\n    }\r\n\r\n    public static _NormalizeTangentFromRef(tangent: Vector4) {\r\n        const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);\r\n        if (length > 0) {\r\n            tangent.x /= length;\r\n            tangent.y /= length;\r\n            tangent.z /= length;\r\n        }\r\n    }\r\n}","import { ImageMimeType } from \"babylonjs-gltf2interface\";\r\n\r\n/**\r\n * Class for holding and downloading glTF file data\r\n */\r\nexport class GLTFData {\r\n    /**\r\n     * Object which contains the file name as the key and its data as the value\r\n     */\r\n    glTFFiles: { [fileName: string]: string | Blob };\r\n\r\n    /**\r\n     * Initializes the glTF file object\r\n     */\r\n    public constructor() {\r\n        this.glTFFiles = {};\r\n    }\r\n\r\n    /**\r\n     * Downloads the glTF data as files based on their names and data\r\n     */\r\n    public downloadFiles(): void {\r\n        /**\r\n        * Checks for a matching suffix at the end of a string (for ES5 and lower)\r\n        * @param str Source string\r\n        * @param suffix Suffix to search for in the source string\r\n        * @returns Boolean indicating whether the suffix was found (true) or not (false)\r\n        */\r\n        function endsWith(str: string, suffix: string): boolean {\r\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n        }\r\n\r\n        for (let key in this.glTFFiles) {\r\n            let link = document.createElement('a');\r\n            document.body.appendChild(link);\r\n            link.setAttribute(\"type\", \"hidden\");\r\n            link.download = key;\r\n            let blob = this.glTFFiles[key];\r\n            let mimeType;\r\n\r\n            if (endsWith(key, \".glb\")) {\r\n                mimeType = { type: \"model/gltf-binary\" };\r\n            }\r\n            else if (endsWith(key, \".bin\")) {\r\n                mimeType = { type: \"application/octet-stream\" };\r\n            }\r\n            else if (endsWith(key, \".gltf\")) {\r\n                mimeType = { type: \"model/gltf+json\" };\r\n            }\r\n            else if (endsWith(key, \".jpeg\" || \".jpg\")) {\r\n                mimeType = {type: ImageMimeType.JPEG};\r\n            }\r\n            else if (endsWith(key, \".png\")) {\r\n                mimeType = {type: ImageMimeType.PNG};\r\n            }\r\n\r\n            link.href = window.URL.createObjectURL(new Blob([blob], mimeType));\r\n            link.click();\r\n        }\r\n    }\r\n}\r\n","import { Scene, TransformNode, Node, Engine, Nullable, Texture, BaseTexture, SubMesh, Tools, Viewport, IndicesArray, Material, FloatArray, Mesh, VertexBuffer, Vector2, Vector3, Vector4, Quaternion, InstancedMesh, AbstractMesh, LinesMesh, Color3, MultiMaterial } from \"babylonjs\";\r\nimport { AccessorType, IBufferView, IAccessor, INode, IAsset, IScene, IMesh, IMaterial, ITexture, IImage, ISampler, IAnimation, ImageMimeType, IMeshPrimitive, IBuffer, IGLTF, MeshPrimitiveMode, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\n\r\nimport { IGLTFExporterExtensionV2 } from \"./glTFExporterExtension\";\r\nimport { _GLTFMaterialExporter } from \"./glTFMaterialExporter\";\r\nimport { IExportOptions } from \"./glTFSerializer\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _GLTFAnimation } from \"./glTFAnimation\";\r\n\r\n/**\r\n * Utility interface for storing vertex attribute data\r\n * @hidden\r\n */\r\ninterface _IVertexAttributeData {\r\n    /**\r\n     * Specifies the Babylon Vertex Buffer Type (Position, Normal, Color, etc.)\r\n    */\r\n    kind: string;\r\n\r\n    /**\r\n     * Specifies the glTF Accessor Type (VEC2, VEC3, etc.)\r\n    */\r\n    accessorType: AccessorType;\r\n\r\n    /**\r\n     * Specifies the BufferView index for the vertex attribute data\r\n    */\r\n    bufferViewIndex?: number;\r\n\r\n    byteStride?: number;\r\n}\r\n/**\r\n * Converts Babylon Scene into glTF 2.0.\r\n * @hidden\r\n */\r\nexport class _Exporter {\r\n    /**\r\n     * Stores all generated buffer views, which represents views into the main glTF buffer data\r\n     */\r\n    public _bufferViews: IBufferView[];\r\n    /**\r\n     * Stores all the generated accessors, which is used for accessing the data within the buffer views in glTF\r\n     */\r\n    public _accessors: IAccessor[];\r\n    /**\r\n     * Stores all the generated nodes, which contains transform and/or mesh information per node\r\n     */\r\n    private _nodes: INode[];\r\n    /**\r\n     * Stores the glTF asset information, which represents the glTF version and this file generator\r\n     */\r\n    private _asset: IAsset;\r\n    /**\r\n     * Stores all the generated glTF scenes, which stores multiple node hierarchies\r\n     */\r\n    private _scenes: IScene[];\r\n    /**\r\n     * Stores all the generated mesh information, each containing a set of primitives to render in glTF\r\n     */\r\n    private _meshes: IMesh[];\r\n    /**\r\n     * Stores all the generated material information, which represents the appearance of each primitive\r\n     */\r\n    public _materials: IMaterial[];\r\n\r\n    public _materialMap: { [materialID: number]: number };\r\n    /**\r\n     * Stores all the generated texture information, which is referenced by glTF materials\r\n     */\r\n    public _textures: ITexture[];\r\n    /**\r\n     * Stores all the generated image information, which is referenced by glTF textures\r\n     */\r\n    public _images: IImage[];\r\n\r\n    /**\r\n     * Stores all the texture samplers\r\n     */\r\n    public _samplers: ISampler[];\r\n    /**\r\n     * Stores all the generated animation samplers, which is referenced by glTF animations\r\n     */\r\n    /**\r\n     * Stores the animations for glTF models\r\n     */\r\n    private _animations: IAnimation[];\r\n    /**\r\n     * Stores the total amount of bytes stored in the glTF buffer\r\n     */\r\n    private _totalByteLength: number;\r\n    /**\r\n     * Stores a reference to the Babylon scene containing the source geometry and material information\r\n     */\r\n    private _babylonScene: Scene;\r\n    /**\r\n     * Stores a map of the image data, where the key is the file name and the value\r\n     * is the image data\r\n     */\r\n    public _imageData: { [fileName: string]: { data: Uint8Array, mimeType: ImageMimeType } };\r\n\r\n    /**\r\n     * Stores a map of the unique id of a node to its index in the node array\r\n     */\r\n    private _nodeMap: { [key: number]: number };\r\n\r\n    /**\r\n     * Specifies if the Babylon scene should be converted to right-handed on export\r\n     */\r\n    private _convertToRightHandedSystem: boolean;\r\n\r\n    /**\r\n     * Baked animation sample rate\r\n     */\r\n    private _animationSampleRate: number;\r\n\r\n    /**\r\n     * Callback which specifies if a transform node should be exported or not\r\n     */\r\n    private _shouldExportTransformNode: ((babylonTransformNode: TransformNode) => boolean);\r\n\r\n    private _localEngine: Engine;\r\n\r\n    public _glTFMaterialExporter: _GLTFMaterialExporter;\r\n\r\n    private _extensions: { [name: string]: IGLTFExporterExtensionV2 } = {};\r\n\r\n    private _extensionsUsed: string[];\r\n    private _extensionsRequired: string[];\r\n\r\n    private static _ExtensionNames = new Array<string>();\r\n    private static _ExtensionFactories: { [name: string]: (exporter: _Exporter) => IGLTFExporterExtensionV2 } = {};\r\n\r\n    private _applyExtensions<T>(property: any, actionAsync: (extension: IGLTFExporterExtensionV2) => Nullable<T> | undefined): Nullable<T> {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                const exporterProperty = property as any;\r\n                exporterProperty._activeLoaderExtensions = exporterProperty._activeLoaderExtensions || {};\r\n                const activeLoaderExtensions = exporterProperty._activeLoaderExtensions;\r\n                if (!activeLoaderExtensions[name]) {\r\n                    activeLoaderExtensions[name] = true;\r\n\r\n                    try {\r\n                        const result = actionAsync(extension);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    }\r\n                    finally {\r\n                        delete activeLoaderExtensions[name];\r\n                        delete exporterProperty._activeLoaderExtensions;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    public _extensionsPreExportTextureAsync(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(babylonTexture, (extension) => extension.preExportTextureAsync && extension.preExportTextureAsync(context, babylonTexture, mimeType));\r\n    }\r\n\r\n    public _extensionsPostExportMeshPrimitiveAsync(context: string, meshPrimitive: IMeshPrimitive, babylonSubMesh: SubMesh, binaryWriter: _BinaryWriter): Nullable<Promise<IMeshPrimitive>> {\r\n        return this._applyExtensions(meshPrimitive, (extension) => extension.postExportMeshPrimitiveAsync && extension.postExportMeshPrimitiveAsync(context, meshPrimitive, babylonSubMesh, binaryWriter));\r\n    }\r\n\r\n    /**\r\n     * Load glTF serializer extensions\r\n     */\r\n    private _loadExtensions(): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = _Exporter._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF Exporter instance, which can accept optional exporter options\r\n     * @param babylonScene Babylon scene object\r\n     * @param options Options to modify the behavior of the exporter\r\n     */\r\n    public constructor(babylonScene: Scene, options?: IExportOptions) {\r\n        this._asset = { generator: \"BabylonJS\", version: \"2.0\" };\r\n        this._extensionsUsed = [];\r\n        this._extensionsRequired = [];\r\n        this._babylonScene = babylonScene;\r\n        this._bufferViews = [];\r\n        this._accessors = [];\r\n        this._meshes = [];\r\n        this._scenes = [];\r\n        this._nodes = [];\r\n        this._images = [];\r\n        this._materials = [];\r\n        this._materialMap = [];\r\n        this._textures = [];\r\n        this._samplers = [];\r\n        this._animations = [];\r\n        this._imageData = {};\r\n        this._convertToRightHandedSystem = this._babylonScene.useRightHandedSystem ? false : true;\r\n        const _options = options || {};\r\n        this._shouldExportTransformNode = _options.shouldExportTransformNode ? _options.shouldExportTransformNode : (babylonTransformNode: TransformNode) => true;\r\n        this._animationSampleRate = _options.animationSampleRate ? _options.animationSampleRate : 1 / 60;\r\n\r\n        this._glTFMaterialExporter = new _GLTFMaterialExporter(this);\r\n        this._loadExtensions();\r\n    }\r\n\r\n    /**\r\n     * Registers a glTF exporter extension\r\n     * @param name Name of the extension to export\r\n     * @param factory The factory function that creates the exporter extension\r\n     */\r\n    public static RegisterExtension(name: string, factory: (exporter: _Exporter) => IGLTFExporterExtensionV2): void {\r\n        if (_Exporter.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name ${name} already exists`);\r\n        }\r\n\r\n        _Exporter._ExtensionFactories[name] = factory;\r\n        _Exporter._ExtensionNames.push(name);\r\n    }\r\n\r\n    /**\r\n     * Un-registers an exporter extension\r\n     * @param name The name fo the exporter extension\r\n     * @returns A boolean indicating whether the extension has been un-registered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!_Exporter._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n        delete _Exporter._ExtensionFactories[name];\r\n\r\n        const index = _Exporter._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            _Exporter._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Lazy load a local engine with premultiplied alpha set to false\r\n     */\r\n    public _getLocalEngine(): Engine {\r\n        if (!this._localEngine) {\r\n            const localCanvas = document.createElement('canvas');\r\n            localCanvas.id = \"WriteCanvas\";\r\n            localCanvas.width = 2048;\r\n            localCanvas.height = 2048;\r\n            this._localEngine = new Engine(localCanvas, true, { premultipliedAlpha: false, preserveDrawingBuffer: true });\r\n            this._localEngine.setViewport(new Viewport(0, 0, 1, 1));\r\n        }\r\n\r\n        return this._localEngine;\r\n    }\r\n\r\n    private reorderIndicesBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, babylonIndices: IndicesArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                if (!byteOffset) { byteOffset = 0; }\r\n                for (let i = submesh.indexStart, length = submesh.indexStart + submesh.indexCount; i < length; i = i + 3) {\r\n                    const index = byteOffset + i * 4;\r\n                    // swap the second and third indices\r\n                    const secondIndex = binaryWriter.getUInt32(index + 4);\r\n                    const thirdIndex = binaryWriter.getUInt32(index + 8);\r\n                    binaryWriter.setUInt32(thirdIndex, index + 4);\r\n                    binaryWriter.setUInt32(secondIndex, index + 8);\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                for (let i = submesh.indexStart + submesh.indexCount - 1, start = submesh.indexStart; i >= start; --i) {\r\n                    binaryWriter.setUInt32(babylonIndices[i], byteOffset);\r\n                    byteOffset += 4;\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                if (submesh.indexCount >= 3) {\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 2], byteOffset + 4);\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 1], byteOffset + 8);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attribute data based on the primitive mode.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderVertexAttributeDataBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter): void {\r\n        if (this._convertToRightHandedSystem && sideOrientation === Material.ClockWiseSideOrientation) {\r\n            switch (primitiveMode) {\r\n                case Material.TriangleFillMode: {\r\n                    this.reorderTriangleFillMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                    break;\r\n                }\r\n                case Material.TriangleStripDrawMode: {\r\n                    this.reorderTriangleStripDrawMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                    break;\r\n                }\r\n                case Material.TriangleFanDrawMode: {\r\n                    this.reorderTriangleFanMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle mode order .  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderTriangleFillMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            let stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n            if (submesh.verticesCount % 3 !== 0) {\r\n                Tools.Error('The submesh vertices for the triangle fill mode is not divisible by 3!');\r\n            }\r\n            else {\r\n                let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n                let index = 0;\r\n                switch (vertexBufferKind) {\r\n                    case VertexBuffer.PositionKind:\r\n                    case VertexBuffer.NormalKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.TangentKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.ColorKind: {\r\n                        const size = vertexBuffer.getSize();\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + size) {\r\n                            index = x * stride;\r\n                            if (size === 4) {\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                            else {\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.UVKind:\r\n                    case VertexBuffer.UV2Kind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                    }\r\n                }\r\n                this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter);\r\n            }\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleFillMode: Vertex Buffer Kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle strip order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderTriangleStripDrawMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            const stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    index = submesh.verticesStart;\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        vertexBuffer.getSize() === 4 ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index)) : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this.writeVertexAttributeData(vertexData, byteOffset + 12, vertexBufferKind, meshAttributeArray, binaryWriter);\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleStripDrawMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle fan order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderTriangleFanMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            let stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                        vertexBuffer.getSize() === 4 ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index)) : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter);\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleFanMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes the vertex attribute data to binary\r\n     * @param vertices The vertices to write to the binary writer\r\n     * @param byteOffset The offset into the binary writer to overwrite binary data\r\n     * @param vertexAttributeKind The vertex attribute type\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param binaryWriter The writer containing the binary data\r\n     */\r\n    private writeVertexAttributeData(vertices: Vector2[] | Vector3[] | Vector4[], byteOffset: number, vertexAttributeKind: string, meshAttributeArray: FloatArray, binaryWriter: _BinaryWriter) {\r\n        for (let vertex of vertices) {\r\n            if (this._convertToRightHandedSystem && !(vertexAttributeKind === VertexBuffer.ColorKind) && !(vertex instanceof Vector2)) {\r\n                if (vertex instanceof Vector3) {\r\n                    if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertex);\r\n                    }\r\n                    else if (vertexAttributeKind === VertexBuffer.PositionKind) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertex);\r\n                    }\r\n                    else {\r\n                        Tools.Error('Unsupported vertex attribute kind!');\r\n                    }\r\n                }\r\n                else {\r\n                    _GLTFUtilities._GetRightHandedVector4FromRef(vertex);\r\n                }\r\n            }\r\n            if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                vertex.normalize();\r\n            }\r\n            else if (vertexAttributeKind === VertexBuffer.TangentKind && vertex instanceof Vector4) {\r\n                _GLTFUtilities._NormalizeTangentFromRef(vertex);\r\n            }\r\n\r\n            for (let component of vertex.asArray()) {\r\n                binaryWriter.setFloat32(component, byteOffset);\r\n                byteOffset += 4;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes mesh attribute data to a data buffer\r\n     * Returns the bytelength of the data\r\n     * @param vertexBufferKind Indicates what kind of vertex data is being passed in\r\n     * @param meshAttributeArray Array containing the attribute data\r\n     * @param binaryWriter The buffer to write the binary data to\r\n     * @param indices Used to specify the order of the vertex data\r\n     */\r\n    public writeAttributeData(vertexBufferKind: string, meshAttributeArray: FloatArray, byteStride: number, binaryWriter: _BinaryWriter) {\r\n        const stride = byteStride / 4;\r\n        let vertexAttributes: number[][] = [];\r\n        let index: number;\r\n\r\n        switch (vertexBufferKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (this._convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertexData);\r\n                    }\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (this._convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertexData);\r\n                    }\r\n                    vertexData.normalize();\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    if (this._convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedVector4FromRef(vertexData);\r\n                    }\r\n                    _GLTFUtilities._NormalizeTangentFromRef(vertexData);\r\n\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = stride === 3 ? Vector3.FromArray(meshAttributeArray, index) : Vector4.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    vertexAttributes.push(this._convertToRightHandedSystem ? [meshAttributeArray[index], meshAttributeArray[index + 1]] : [meshAttributeArray[index], meshAttributeArray[index + 1]]);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + vertexBufferKind);\r\n                vertexAttributes = [];\r\n            }\r\n        }\r\n        for (let vertexAttribute of vertexAttributes) {\r\n            for (let component of vertexAttribute) {\r\n                binaryWriter.setFloat32(component);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates glTF json data\r\n     * @param shouldUseGlb Indicates whether the json should be written for a glb file\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @param prettyPrint Indicates whether the json file should be pretty printed (true) or not (false)\r\n     * @returns json data as string\r\n     */\r\n    private generateJSON(shouldUseGlb: boolean, glTFPrefix?: string, prettyPrint?: boolean): string {\r\n        let buffer: IBuffer = { byteLength: this._totalByteLength };\r\n        let imageName: string;\r\n        let imageData: { data: Uint8Array, mimeType: ImageMimeType };\r\n        let bufferView: IBufferView;\r\n        let byteOffset: number = this._totalByteLength;\r\n\r\n        let glTF: IGLTF = {\r\n            asset: this._asset\r\n        };\r\n        if (this._extensionsUsed && this._extensionsUsed.length) {\r\n            glTF.extensionsUsed = this._extensionsUsed;\r\n        }\r\n        if (this._extensionsRequired && this._extensionsRequired.length) {\r\n            glTF.extensionsRequired = this._extensionsRequired;\r\n        }\r\n        if (buffer.byteLength) {\r\n            glTF.buffers = [buffer];\r\n        }\r\n        if (this._nodes && this._nodes.length) {\r\n            glTF.nodes = this._nodes;\r\n        }\r\n        if (this._meshes && this._meshes.length) {\r\n            glTF.meshes = this._meshes;\r\n        }\r\n        if (this._scenes && this._scenes.length) {\r\n            glTF.scenes = this._scenes;\r\n            glTF.scene = 0;\r\n        }\r\n        if (this._bufferViews && this._bufferViews.length) {\r\n            glTF.bufferViews = this._bufferViews;\r\n        }\r\n        if (this._accessors && this._accessors.length) {\r\n            glTF.accessors = this._accessors;\r\n        }\r\n        if (this._animations && this._animations.length) {\r\n            glTF.animations = this._animations;\r\n        }\r\n        if (this._materials && this._materials.length) {\r\n            glTF.materials = this._materials;\r\n        }\r\n        if (this._textures && this._textures.length) {\r\n            glTF.textures = this._textures;\r\n        }\r\n        if (this._samplers && this._samplers.length) {\r\n            glTF.samplers = this._samplers;\r\n        }\r\n        if (this._images && this._images.length) {\r\n            if (!shouldUseGlb) {\r\n                glTF.images = this._images;\r\n            }\r\n            else {\r\n                glTF.images = [];\r\n\r\n                this._images.forEach((image) => {\r\n                    if (image.uri) {\r\n                        imageData = this._imageData[image.uri];\r\n                        imageName = image.uri.split('.')[0] + \" image\";\r\n                        bufferView = _GLTFUtilities._CreateBufferView(0, byteOffset, imageData.data.length, undefined, imageName);\r\n                        byteOffset += imageData.data.buffer.byteLength;\r\n                        this._bufferViews.push(bufferView);\r\n                        image.bufferView = this._bufferViews.length - 1;\r\n                        image.name = imageName;\r\n                        image.mimeType = imageData.mimeType;\r\n                        image.uri = undefined;\r\n                        if (!glTF.images) {\r\n                            glTF.images = [];\r\n                        }\r\n                        glTF.images.push(image);\r\n                    }\r\n                });\r\n                // Replace uri with bufferview and mime type for glb\r\n                buffer.byteLength = byteOffset;\r\n            }\r\n        }\r\n\r\n        if (!shouldUseGlb) {\r\n            buffer.uri = glTFPrefix + \".bin\";\r\n        }\r\n\r\n        const jsonText = prettyPrint ? JSON.stringify(glTF, null, 2) : JSON.stringify(glTF);\r\n\r\n        return jsonText;\r\n    }\r\n\r\n    /**\r\n     * Generates data for .gltf and .bin files based on the glTF prefix string\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @returns GLTFData with glTF file data\r\n     */\r\n    public _generateGLTFAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            const jsonText = this.generateJSON(false, glTFPrefix, true);\r\n            const bin = new Blob([binaryBuffer], { type: 'application/octet-stream' });\r\n\r\n            const glTFFileName = glTFPrefix + '.gltf';\r\n            const glTFBinFile = glTFPrefix + '.bin';\r\n\r\n            const container = new GLTFData();\r\n\r\n            container.glTFFiles[glTFFileName] = jsonText;\r\n            container.glTFFiles[glTFBinFile] = bin;\r\n\r\n            if (this._imageData) {\r\n                for (let image in this._imageData) {\r\n                    container.glTFFiles[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });\r\n                }\r\n            }\r\n\r\n            return container;\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Creates a binary buffer for glTF\r\n     * @returns array buffer for binary data\r\n     */\r\n    private _generateBinaryAsync(): Promise<ArrayBuffer> {\r\n        let binaryWriter = new _BinaryWriter(4);\r\n        return this.createSceneAsync(this._babylonScene, binaryWriter).then(() => {\r\n            if (this._localEngine) {\r\n                this._localEngine.dispose();\r\n            }\r\n            return binaryWriter.getArrayBuffer();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Pads the number to a multiple of 4\r\n     * @param num number to pad\r\n     * @returns padded number\r\n     */\r\n    private _getPadding(num: number): number {\r\n        let remainder = num % 4;\r\n        let padding = remainder === 0 ? remainder : 4 - remainder;\r\n\r\n        return padding;\r\n    }\r\n\r\n    /**\r\n     * Generates a glb file from the json and binary data\r\n     * Returns an object with the glb file name as the key and data as the value\r\n     * @param glTFPrefix\r\n     * @returns object with glb filename as key and data as value\r\n     */\r\n    public _generateGLBAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            const jsonText = this.generateJSON(true);\r\n            const glbFileName = glTFPrefix + '.glb';\r\n            const headerLength = 12;\r\n            const chunkLengthPrefix = 8;\r\n            const jsonLength = jsonText.length;\r\n            let imageByteLength = 0;\r\n\r\n            for (let key in this._imageData) {\r\n                imageByteLength += this._imageData[key].data.byteLength;\r\n            }\r\n            const jsonPadding = this._getPadding(jsonLength);\r\n            const binPadding = this._getPadding(binaryBuffer.byteLength);\r\n            const imagePadding = this._getPadding(imageByteLength);\r\n\r\n            const byteLength = headerLength + (2 * chunkLengthPrefix) + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding + imageByteLength + imagePadding;\r\n\r\n            //header\r\n            const headerBuffer = new ArrayBuffer(headerLength);\r\n            const headerBufferView = new DataView(headerBuffer);\r\n            headerBufferView.setUint32(0, 0x46546C67, true); //glTF\r\n            headerBufferView.setUint32(4, 2, true); // version\r\n            headerBufferView.setUint32(8, byteLength, true); // total bytes in file\r\n\r\n            //json chunk\r\n            const jsonChunkBuffer = new ArrayBuffer(chunkLengthPrefix + jsonLength + jsonPadding);\r\n            const jsonChunkBufferView = new DataView(jsonChunkBuffer);\r\n            jsonChunkBufferView.setUint32(0, jsonLength + jsonPadding, true);\r\n            jsonChunkBufferView.setUint32(4, 0x4E4F534A, true);\r\n\r\n            //json chunk bytes\r\n            const jsonData = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix);\r\n            for (let i = 0; i < jsonLength; ++i) {\r\n                jsonData[i] = jsonText.charCodeAt(i);\r\n            }\r\n\r\n            //json padding\r\n            const jsonPaddingView = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix + jsonLength);\r\n            for (let i = 0; i < jsonPadding; ++i) {\r\n                jsonPaddingView[i] = 0x20;\r\n            }\r\n\r\n            //binary chunk\r\n            const binaryChunkBuffer = new ArrayBuffer(chunkLengthPrefix);\r\n            const binaryChunkBufferView = new DataView(binaryChunkBuffer);\r\n            binaryChunkBufferView.setUint32(0, binaryBuffer.byteLength + imageByteLength + imagePadding, true);\r\n            binaryChunkBufferView.setUint32(4, 0x004E4942, true);\r\n\r\n            // binary padding\r\n            const binPaddingBuffer = new ArrayBuffer(binPadding);\r\n            const binPaddingView = new Uint8Array(binPaddingBuffer);\r\n            for (let i = 0; i < binPadding; ++i) {\r\n                binPaddingView[i] = 0;\r\n            }\r\n\r\n            const imagePaddingBuffer = new ArrayBuffer(imagePadding);\r\n            const imagePaddingView = new Uint8Array(imagePaddingBuffer);\r\n            for (let i = 0; i < imagePadding; ++i) {\r\n                imagePaddingView[i] = 0;\r\n            }\r\n\r\n            const glbData = [headerBuffer, jsonChunkBuffer, binaryChunkBuffer, binaryBuffer];\r\n\r\n            // binary data\r\n            for (let key in this._imageData) {\r\n                glbData.push(this._imageData[key].data.buffer);\r\n            }\r\n            glbData.push(binPaddingBuffer);\r\n\r\n            glbData.push(imagePaddingBuffer);\r\n\r\n            const glbFile = new Blob(glbData, { type: 'application/octet-stream' });\r\n\r\n            const container = new GLTFData();\r\n            container.glTFFiles[glbFileName] = glbFile;\r\n\r\n            if (this._localEngine != null) {\r\n                this._localEngine.dispose();\r\n            }\r\n\r\n            return container;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the TRS for each node\r\n     * @param node glTF Node for storing the transformation data\r\n     * @param babylonTransformNode Babylon mesh used as the source for the transformation data\r\n     */\r\n    private setNodeTransformation(node: INode, babylonTransformNode: TransformNode): void {\r\n        if (!babylonTransformNode.getPivotPoint().equalsToFloats(0, 0, 0)) {\r\n            BABYLON.Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\r\n        }\r\n        if (!babylonTransformNode.position.equalsToFloats(0, 0, 0)) {\r\n            node.translation = this._convertToRightHandedSystem ? _GLTFUtilities._GetRightHandedPositionVector3(babylonTransformNode.position).asArray() : babylonTransformNode.position.asArray();\r\n        }\r\n\r\n        if (!babylonTransformNode.scaling.equalsToFloats(1, 1, 1)) {\r\n            node.scale = babylonTransformNode.scaling.asArray();\r\n        }\r\n\r\n        let rotationQuaternion = Quaternion.RotationYawPitchRoll(babylonTransformNode.rotation.y, babylonTransformNode.rotation.x, babylonTransformNode.rotation.z);\r\n        if (babylonTransformNode.rotationQuaternion) {\r\n            rotationQuaternion.multiplyInPlace(babylonTransformNode.rotationQuaternion);\r\n        }\r\n        if (!(rotationQuaternion.x === 0 && rotationQuaternion.y === 0 && rotationQuaternion.z === 0 && rotationQuaternion.w === 1)) {\r\n            if (this._convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n\r\n            }\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private getVertexBufferFromMesh(attributeKind: string, bufferMesh: Mesh): Nullable<VertexBuffer> {\r\n        if (bufferMesh.isVerticesDataPresent(attributeKind)) {\r\n            const vertexBuffer = bufferMesh.getVertexBuffer(attributeKind);\r\n            if (vertexBuffer) {\r\n                return vertexBuffer;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a bufferview based on the vertices type for the Babylon mesh\r\n     * @param kind Indicates the type of vertices data\r\n     * @param babylonTransformNode The Babylon mesh to get the vertices data from\r\n     * @param binaryWriter The buffer to write the bufferview data to\r\n     */\r\n    private createBufferViewKind(kind: string, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter, byteStride: number) {\r\n        const bufferMesh = babylonTransformNode instanceof Mesh ?\r\n            babylonTransformNode as Mesh : babylonTransformNode instanceof InstancedMesh ?\r\n                (babylonTransformNode as InstancedMesh).sourceMesh : null;\r\n\r\n        if (bufferMesh) {\r\n            const vertexData = bufferMesh.getVerticesData(kind);\r\n\r\n            if (vertexData) {\r\n                const byteLength = vertexData.length * 4;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, kind + \" - \" + bufferMesh.name);\r\n                this._bufferViews.push(bufferView);\r\n\r\n                this.writeAttributeData(\r\n                    kind,\r\n                    vertexData,\r\n                    byteStride,\r\n                    binaryWriter\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The primitive mode of the Babylon mesh\r\n     * @param babylonMesh The BabylonJS mesh\r\n     */\r\n    private getMeshPrimitiveMode(babylonMesh: AbstractMesh): number {\r\n        if (babylonMesh instanceof LinesMesh) {\r\n            return Material.LineListDrawMode;\r\n        }\r\n        return babylonMesh.material ? babylonMesh.material.fillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the primitive mode of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param primitiveMode The primitive mode\r\n     */\r\n    private setPrimitiveMode(meshPrimitive: IMeshPrimitive, primitiveMode: number) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                // glTF defaults to using Triangle Mode\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_STRIP;\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_FAN;\r\n                break;\r\n            }\r\n            case Material.PointListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n            }\r\n            case Material.PointFillMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n                break;\r\n            }\r\n            case Material.LineLoopDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_LOOP;\r\n                break;\r\n            }\r\n            case Material.LineListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINES;\r\n                break;\r\n            }\r\n            case Material.LineStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_STRIP;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex attribute accessor based of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param attributeKind vertex attribute\r\n     * @returns boolean specifying if uv coordinates are present\r\n     */\r\n    private setAttributeKind(meshPrimitive: IMeshPrimitive, attributeKind: string): void {\r\n        switch (attributeKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                meshPrimitive.attributes.POSITION = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                meshPrimitive.attributes.NORMAL = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                meshPrimitive.attributes.COLOR_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                meshPrimitive.attributes.TANGENT = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind: {\r\n                meshPrimitive.attributes.TEXCOORD_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UV2Kind: {\r\n                meshPrimitive.attributes.TEXCOORD_1 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + attributeKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets data for the primitive attributes of each submesh\r\n     * @param mesh glTF Mesh object to store the primitive attribute information\r\n     * @param babylonTransformNode Babylon mesh to get the primitive attribute data from\r\n     * @param binaryWriter Buffer to write the attribute data to\r\n     */\r\n    private setPrimitiveAttributesAsync(mesh: IMesh, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter): Promise<void> {\r\n        let promises: Promise<IMeshPrimitive>[] = [];\r\n        let bufferMesh: Nullable<Mesh> = null;\r\n        let bufferView: IBufferView;\r\n        let uvCoordsPresent: boolean;\r\n        let minMax: { min: Nullable<number[]>, max: Nullable<number[]> };\r\n\r\n        if (babylonTransformNode instanceof Mesh) {\r\n            bufferMesh = (babylonTransformNode as Mesh);\r\n        }\r\n        else if (babylonTransformNode instanceof InstancedMesh) {\r\n            bufferMesh = (babylonTransformNode as InstancedMesh).sourceMesh;\r\n        }\r\n        const attributeData: _IVertexAttributeData[] = [\r\n            { kind: VertexBuffer.PositionKind, accessorType: AccessorType.VEC3, byteStride: 12 },\r\n            { kind: VertexBuffer.NormalKind, accessorType: AccessorType.VEC3, byteStride: 12 },\r\n            { kind: VertexBuffer.ColorKind, accessorType: AccessorType.VEC4, byteStride: 16 },\r\n            { kind: VertexBuffer.TangentKind, accessorType: AccessorType.VEC4, byteStride: 16 },\r\n            { kind: VertexBuffer.UVKind, accessorType: AccessorType.VEC2, byteStride: 8 },\r\n            { kind: VertexBuffer.UV2Kind, accessorType: AccessorType.VEC2, byteStride: 8 },\r\n        ];\r\n\r\n        if (bufferMesh) {\r\n            let indexBufferViewIndex: Nullable<number> = null;\r\n            const primitiveMode = this.getMeshPrimitiveMode(bufferMesh);\r\n            let vertexAttributeBufferViews: { [attributeKind: string]: number } = {};\r\n\r\n            // For each BabylonMesh, create bufferviews for each 'kind'\r\n            for (const attribute of attributeData) {\r\n                const attributeKind = attribute.kind;\r\n                if (bufferMesh.isVerticesDataPresent(attributeKind)) {\r\n                    const vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                    attribute.byteStride = vertexBuffer ? vertexBuffer.getSize() * 4 : VertexBuffer.DeduceStride(attributeKind) * 4;\r\n                    if (attribute.byteStride === 12) {\r\n                        attribute.accessorType = AccessorType.VEC3;\r\n                    }\r\n\r\n                    this.createBufferViewKind(attributeKind, babylonTransformNode, binaryWriter, attribute.byteStride);\r\n                    attribute.bufferViewIndex = this._bufferViews.length - 1;\r\n                    vertexAttributeBufferViews[attributeKind] = attribute.bufferViewIndex;\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.getTotalIndices()) {\r\n                const indices = bufferMesh.getIndices();\r\n                if (indices) {\r\n                    const byteLength = indices.length * 4;\r\n                    bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, \"Indices - \" + bufferMesh.name);\r\n                    this._bufferViews.push(bufferView);\r\n                    indexBufferViewIndex = this._bufferViews.length - 1;\r\n\r\n                    for (let k = 0, length = indices.length; k < length; ++k) {\r\n                        binaryWriter.setUInt32(indices[k]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.subMeshes) {\r\n                // go through all mesh primitives (submeshes)\r\n                for (const submesh of bufferMesh.subMeshes) {\r\n                    uvCoordsPresent = false;\r\n                    let babylonMaterial = submesh.getMaterial() || bufferMesh.getScene().defaultMaterial;\r\n\r\n                    let materialIndex: Nullable<number> = null;\r\n                    if (babylonMaterial) {\r\n                        if (bufferMesh instanceof LinesMesh) {\r\n                            // get the color from the lines mesh and set it in the material\r\n                            const material: IMaterial = {\r\n                                name: bufferMesh.name + ' material'\r\n                            };\r\n                            if (!bufferMesh.color.equals(Color3.White()) || bufferMesh.alpha < 1) {\r\n                                material.pbrMetallicRoughness = {\r\n                                    baseColorFactor: bufferMesh.color.asArray().concat([bufferMesh.alpha])\r\n                                };\r\n                            }\r\n                            this._materials.push(material);\r\n                            materialIndex = this._materials.length - 1;\r\n                        }\r\n                        else if (babylonMaterial instanceof MultiMaterial) {\r\n                            const subMaterial = babylonMaterial.subMaterials[submesh.materialIndex];\r\n                            if (subMaterial) {\r\n                                babylonMaterial = subMaterial;\r\n                                materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                            }\r\n                        }\r\n                        else {\r\n                            materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                        }\r\n                    }\r\n\r\n                    let glTFMaterial: Nullable<IMaterial> = materialIndex != null ? this._materials[materialIndex] : null;\r\n\r\n                    const meshPrimitive: IMeshPrimitive = { attributes: {} };\r\n                    this.setPrimitiveMode(meshPrimitive, primitiveMode);\r\n\r\n                    for (const attribute of attributeData) {\r\n                        const attributeKind = attribute.kind;\r\n                        if (attributeKind === VertexBuffer.UVKind || attributeKind === VertexBuffer.UV2Kind) {\r\n                            if (glTFMaterial && !this._glTFMaterialExporter._hasTexturesPresent(glTFMaterial)) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        let vertexData = bufferMesh.getVerticesData(attributeKind);\r\n                        if (vertexData) {\r\n                            const vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                            if (vertexBuffer) {\r\n                                const stride = vertexBuffer.getSize();\r\n                                const bufferViewIndex = attribute.bufferViewIndex;\r\n                                if (bufferViewIndex != undefined) { // check to see if bufferviewindex has a numeric value assigned.\r\n                                    minMax = { min: null, max: null };\r\n                                    if (attributeKind == VertexBuffer.PositionKind) {\r\n                                        minMax = _GLTFUtilities._CalculateMinMaxPositions(vertexData, 0, vertexData.length / stride, this._convertToRightHandedSystem);\r\n                                    }\r\n                                    const accessor = _GLTFUtilities._CreateAccessor(bufferViewIndex, attributeKind + \" - \" + babylonTransformNode.name, attribute.accessorType, AccessorComponentType.FLOAT, vertexData.length / stride, 0, minMax.min, minMax.max);\r\n                                    this._accessors.push(accessor);\r\n                                    this.setAttributeKind(meshPrimitive, attributeKind);\r\n                                    if (meshPrimitive.attributes.TEXCOORD_0 != null || meshPrimitive.attributes.TEXCOORD_1 != null) {\r\n                                        uvCoordsPresent = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (indexBufferViewIndex) {\r\n                        // Create accessor\r\n                        const accessor = _GLTFUtilities._CreateAccessor(indexBufferViewIndex, \"indices - \" + babylonTransformNode.name, AccessorType.SCALAR, AccessorComponentType.UNSIGNED_INT, submesh.indexCount, submesh.indexStart * 4, null, null);\r\n                        this._accessors.push(accessor);\r\n                        meshPrimitive.indices = this._accessors.length - 1;\r\n                    }\r\n                    if (materialIndex != null && Object.keys(meshPrimitive.attributes).length > 0) {\r\n                        let sideOrientation = babylonMaterial.sideOrientation;\r\n\r\n                        if (this._convertToRightHandedSystem && sideOrientation === Material.ClockWiseSideOrientation) {\r\n                            //Overwrite the indices to be counter-clockwise\r\n                            let byteOffset = indexBufferViewIndex != null ? this._bufferViews[indexBufferViewIndex].byteOffset : null;\r\n                            if (byteOffset == null) { byteOffset = 0; }\r\n                            let babylonIndices: Nullable<IndicesArray> = null;\r\n                            if (indexBufferViewIndex != null) {\r\n                                babylonIndices = bufferMesh.getIndices();\r\n                            }\r\n                            if (babylonIndices) {\r\n                                this.reorderIndicesBasedOnPrimitiveMode(submesh, primitiveMode, babylonIndices, byteOffset, binaryWriter);\r\n                            }\r\n                            else {\r\n                                for (let attribute of attributeData) {\r\n                                    let vertexData = bufferMesh.getVerticesData(attribute.kind);\r\n                                    if (vertexData) {\r\n                                        let byteOffset = this._bufferViews[vertexAttributeBufferViews[attribute.kind]].byteOffset;\r\n                                        if (!byteOffset) {\r\n                                            byteOffset = 0;\r\n                                        }\r\n                                        this.reorderVertexAttributeDataBasedOnPrimitiveMode(submesh, primitiveMode, sideOrientation, attribute.kind, vertexData, byteOffset, binaryWriter);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (!uvCoordsPresent && this._glTFMaterialExporter._hasTexturesPresent(this._materials[materialIndex])) {\r\n                            const newMat = this._glTFMaterialExporter._stripTexturesFromMaterial(this._materials[materialIndex]);\r\n                            this._materials.push(newMat);\r\n                            materialIndex = this._materials.length - 1;\r\n                        }\r\n\r\n                        meshPrimitive.material = materialIndex;\r\n\r\n                    }\r\n                    mesh.primitives.push(meshPrimitive);\r\n\r\n                    const promise = this._extensionsPostExportMeshPrimitiveAsync(\"postExport\", meshPrimitive, submesh, binaryWriter);\r\n                    if (promise) {\r\n                        promises.push();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            /* do nothing */\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF scene based on the array of meshes\r\n     * Returns the the total byte offset\r\n     * @param babylonScene Babylon scene to get the mesh data from\r\n     * @param binaryWriter Buffer to write binary data to\r\n     */\r\n    private createSceneAsync(babylonScene: Scene, binaryWriter: _BinaryWriter): Promise<void> {\r\n        const scene: IScene = { nodes: [] };\r\n        let glTFNodeIndex: number;\r\n        let glTFNode: INode;\r\n        let directDescendents: Node[];\r\n        const nodes = [...babylonScene.transformNodes, ...babylonScene.meshes];\r\n\r\n        return this._glTFMaterialExporter._convertMaterialsToGLTFAsync(babylonScene.materials, ImageMimeType.PNG, true).then(() => {\r\n            return this.createNodeMapAndAnimationsAsync(babylonScene, nodes, this._shouldExportTransformNode, binaryWriter).then((nodeMap) => {\r\n                this._nodeMap = nodeMap;\r\n\r\n                this._totalByteLength = binaryWriter.getByteOffset();\r\n                if (this._totalByteLength == undefined) {\r\n                    throw new Error(\"undefined byte length!\");\r\n                }\r\n\r\n                // Build Hierarchy with the node map.\r\n                for (let babylonTransformNode of nodes) {\r\n                    glTFNodeIndex = this._nodeMap[babylonTransformNode.uniqueId];\r\n                    if (glTFNodeIndex != null) {\r\n                        glTFNode = this._nodes[glTFNodeIndex];\r\n                        if (!babylonTransformNode.parent) {\r\n                            if (!this._shouldExportTransformNode(babylonTransformNode)) {\r\n                                Tools.Log(\"Omitting \" + babylonTransformNode.name + \" from scene.\");\r\n                            }\r\n                            else {\r\n                                if (this._convertToRightHandedSystem) {\r\n                                    if (glTFNode.translation) {\r\n                                        glTFNode.translation[2] *= -1;\r\n                                        glTFNode.translation[0] *= -1;\r\n                                    }\r\n                                    glTFNode.rotation = glTFNode.rotation ? Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(glTFNode.rotation)).asArray() : (Quaternion.FromArray([0, 1, 0, 0])).asArray();\r\n                                }\r\n\r\n                                scene.nodes.push(glTFNodeIndex);\r\n                            }\r\n                        }\r\n\r\n                        directDescendents = babylonTransformNode.getDescendants(true);\r\n                        if (!glTFNode.children && directDescendents && directDescendents.length) {\r\n                            const children: number[] = [];\r\n                            for (let descendent of directDescendents) {\r\n                                if (this._nodeMap[descendent.uniqueId] != null) {\r\n                                    children.push(this._nodeMap[descendent.uniqueId]);\r\n                                }\r\n                            }\r\n                            if (children.length) {\r\n                                glTFNode.children = children;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (scene.nodes.length) {\r\n                    this._scenes.push(scene);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a mapping of Node unique id to node index and handles animations\r\n     * @param babylonScene Babylon Scene\r\n     * @param nodes Babylon transform nodes\r\n     * @param shouldExportTransformNode Callback specifying if a transform node should be exported\r\n     * @param binaryWriter Buffer to write binary data to\r\n     * @returns Node mapping of unique id to index\r\n     */\r\n    private createNodeMapAndAnimationsAsync(babylonScene: Scene, nodes: TransformNode[], shouldExportTransformNode: (babylonTransformNode: TransformNode) => boolean, binaryWriter: _BinaryWriter): Promise<{ [key: number]: number }> {\r\n        let promiseChain = Promise.resolve();\r\n        const nodeMap: { [key: number]: number } = {};\r\n        let nodeIndex: number;\r\n        let runtimeGLTFAnimation: IAnimation = {\r\n            name: 'runtime animations',\r\n            channels: [],\r\n            samplers: []\r\n        };\r\n        let idleGLTFAnimations: IAnimation[] = [];\r\n\r\n        for (let babylonTransformNode of nodes) {\r\n            if (shouldExportTransformNode(babylonTransformNode)) {\r\n                promiseChain = promiseChain.then(() => {\r\n                    return this.createNodeAsync(babylonTransformNode, binaryWriter).then((node) => {\r\n                        const directDescendents = babylonTransformNode.getDescendants(true, (node: Node) => { return (node instanceof TransformNode); });\r\n                        if (directDescendents.length || node.mesh != null) {\r\n                            this._nodes.push(node);\r\n                            nodeIndex = this._nodes.length - 1;\r\n                            nodeMap[babylonTransformNode.uniqueId] = nodeIndex;\r\n                        }\r\n\r\n                        if (!babylonScene.animationGroups.length && babylonTransformNode.animations.length) {\r\n                            _GLTFAnimation._CreateNodeAnimationFromTransformNodeAnimations(babylonTransformNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, this._nodes, binaryWriter, this._bufferViews, this._accessors, this._convertToRightHandedSystem, this._animationSampleRate);\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                `Excluding mesh ${babylonTransformNode.name}`;\r\n            }\r\n        }\r\n\r\n        return promiseChain.then(() => {\r\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\r\n                this._animations.push(runtimeGLTFAnimation);\r\n            }\r\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\r\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\r\n                    this._animations.push(idleGLTFAnimation);\r\n                }\r\n            });\r\n\r\n            if (babylonScene.animationGroups.length) {\r\n                _GLTFAnimation._CreateNodeAnimationFromAnimationGroups(babylonScene, this._animations, nodeMap, this._nodes, binaryWriter, this._bufferViews, this._accessors, this._convertToRightHandedSystem, this._animationSampleRate);\r\n            }\r\n\r\n            return nodeMap;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF node from a Babylon mesh\r\n     * @param babylonMesh Source Babylon mesh\r\n     * @param binaryWriter Buffer for storing geometry data\r\n     * @returns glTF node\r\n     */\r\n    private createNodeAsync(babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter): Promise<INode> {\r\n        return Promise.resolve().then(() => {\r\n            // create node to hold translation/rotation/scale and the mesh\r\n            const node: INode = {};\r\n            // create mesh\r\n            const mesh: IMesh = { primitives: [] };\r\n\r\n            if (babylonTransformNode.name) {\r\n                node.name = babylonTransformNode.name;\r\n            }\r\n\r\n            // Set transformation\r\n            this.setNodeTransformation(node, babylonTransformNode);\r\n\r\n            return this.setPrimitiveAttributesAsync(mesh, babylonTransformNode, binaryWriter).then(() => {\r\n                if (mesh.primitives.length) {\r\n                    this._meshes.push(mesh);\r\n                    node.mesh = this._meshes.length - 1;\r\n                }\r\n\r\n                return node;\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * @hidden\r\n *\r\n * Stores glTF binary data.  If the array buffer byte length is exceeded, it doubles in size dynamically\r\n */\r\nexport class _BinaryWriter {\r\n    /**\r\n     * Array buffer which stores all binary data\r\n     */\r\n    private _arrayBuffer: ArrayBuffer;\r\n    /**\r\n     * View of the array buffer\r\n     */\r\n    private _dataView: DataView;\r\n    /**\r\n     * byte offset of data in array buffer\r\n     */\r\n    private _byteOffset: number;\r\n    /**\r\n     * Initialize binary writer with an initial byte length\r\n     * @param byteLength Initial byte length of the array buffer\r\n     */\r\n    constructor(byteLength: number) {\r\n        this._arrayBuffer = new ArrayBuffer(byteLength);\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n        this._byteOffset = 0;\r\n    }\r\n    /**\r\n     * Resize the array buffer to the specified byte length\r\n     * @param byteLength\r\n     */\r\n    private resizeBuffer(byteLength: number): ArrayBuffer {\r\n        let newBuffer = new ArrayBuffer(byteLength);\r\n        let oldUint8Array = new Uint8Array(this._arrayBuffer);\r\n        let newUint8Array = new Uint8Array(newBuffer);\r\n        for (let i = 0, length = newUint8Array.byteLength; i < length; ++i) {\r\n            newUint8Array[i] = oldUint8Array[i];\r\n        }\r\n        this._arrayBuffer = newBuffer;\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n\r\n        return newBuffer;\r\n    }\r\n    /**\r\n     * Get an array buffer with the length of the byte offset\r\n     * @returns ArrayBuffer resized to the byte offset\r\n     */\r\n    public getArrayBuffer(): ArrayBuffer {\r\n        return this.resizeBuffer(this.getByteOffset());\r\n    }\r\n    /**\r\n     * Get the byte offset of the array buffer\r\n     * @returns byte offset\r\n     */\r\n    public getByteOffset(): number {\r\n        if (this._byteOffset == undefined) {\r\n            throw new Error(\"Byte offset is undefined!\");\r\n        }\r\n        return this._byteOffset;\r\n    }\r\n    /**\r\n     * Stores an UInt8 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt8(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint8(byteOffset, entry);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            }\r\n        }\r\n        else {\r\n            if (this._byteOffset + 1 > this._arrayBuffer.byteLength) {\r\n                this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint8(this._byteOffset++, entry);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public getUInt32(byteOffset: number): number {\r\n        if (byteOffset < this._byteOffset) {\r\n            return this._dataView.getUint32(byteOffset, true);\r\n        }\r\n        else {\r\n            Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            throw new Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n        }\r\n    }\r\n\r\n    public getVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            vector3.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector3.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector3.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n        }\r\n    }\r\n\r\n    public setVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            this._dataView.setFloat32(byteOffset, vector3.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector3.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector3.z, true);\r\n        }\r\n    }\r\n\r\n    public getVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            vector4.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector4.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector4.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n            vector4.w = this._dataView.getFloat32(byteOffset + 12, true);\r\n        }\r\n    }\r\n\r\n    public setVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            this._dataView.setFloat32(byteOffset, vector4.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector4.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector4.z, true);\r\n            this._dataView.setFloat32(byteOffset + 12, vector4.w, true);\r\n        }\r\n    }\r\n    /**\r\n     * Stores a Float32 in the array buffer\r\n     * @param entry\r\n     */\r\n    public setFloat32(entry: number, byteOffset?: number) {\r\n        if (isNaN(entry)) {\r\n            Tools.Error('Invalid data being written!');\r\n        }\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setFloat32(byteOffset, entry, true);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary length!');\r\n            }\r\n        }\r\n        if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n            this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n        }\r\n        this._dataView.setFloat32(this._byteOffset, entry, true);\r\n        this._byteOffset += 4;\r\n    }\r\n    /**\r\n     * Stores an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt32(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint32(byteOffset, entry, true);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            }\r\n        }\r\n        else {\r\n            if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n                this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint32(this._byteOffset, entry, true);\r\n            this._byteOffset += 4;\r\n        }\r\n    }\r\n}","import { Animation, TransformNode, Nullable, Tools, Scene, Mesh, Vector3, Quaternion, IAnimationKey, AnimationKeyInterpolation } from \"babylonjs\";\r\nimport { AnimationSamplerInterpolation, AnimationChannelTargetPath, AccessorType, IAnimation, INode, IBufferView, IAccessor, IAnimationSampler, IAnimationChannel, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport { _BinaryWriter } from \"./glTFExporter\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\n\r\n/**\r\n * @hidden\r\n * Interface to store animation data.\r\n */\r\nexport interface _IAnimationData {\r\n    /**\r\n     * Keyframe data.\r\n     */\r\n    inputs: number[];\r\n    /**\r\n     * Value data.\r\n     */\r\n    outputs: number[][];\r\n    /**\r\n     * Animation interpolation data.\r\n     */\r\n    samplerInterpolation: AnimationSamplerInterpolation;\r\n    /**\r\n     * Minimum keyframe value.\r\n     */\r\n    inputsMin: number;\r\n    /**\r\n     * Maximum keyframe value.\r\n     */\r\n    inputsMax: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport interface _IAnimationInfo {\r\n    /**\r\n     * The target channel for the animation\r\n     */\r\n    animationChannelTargetPath: AnimationChannelTargetPath;\r\n    /**\r\n     * The glTF accessor type for the data.\r\n     */\r\n    dataAccessorType: AccessorType.VEC3 | AccessorType.VEC4;\r\n    /**\r\n     * Specifies if quaternions should be used.\r\n     */\r\n    useQuaternion: boolean;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * Enum for handling in tangent and out tangent.\r\n */\r\nenum _TangentType {\r\n    /**\r\n     * Specifies that input tangents are used.\r\n     */\r\n    INTANGENT,\r\n    /**\r\n     * Specifies that output tangents are used.\r\n     */\r\n    OUTTANGENT\r\n}\r\n/**\r\n * @hidden\r\n * Utility class for generating glTF animation data from BabylonJS.\r\n */\r\nexport class _GLTFAnimation {\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Creates glTF channel animation from BabylonJS animation.\r\n     * @param babylonTransformNode - BabylonJS mesh.\r\n     * @param animation - animation.\r\n     * @param animationChannelTargetPath - The target animation channel.\r\n     * @param convertToRightHandedSystem - Specifies if the values should be converted to right-handed.\r\n     * @param useQuaternion - Specifies if quaternions are used.\r\n     * @returns nullable IAnimationData\r\n     */\r\n    public static _CreateNodeAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean, animationSampleRate: number): Nullable<_IAnimationData> {\r\n        const inputs: number[] = [];\r\n        const outputs: number[][] = [];\r\n        const keyFrames = animation.getKeys();\r\n        const minMaxKeyFrames = _GLTFAnimation.calculateMinMaxKeyFrames(keyFrames);\r\n        const interpolationOrBake = _GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);\r\n        const frameDelta = minMaxKeyFrames.max - minMaxKeyFrames.min;\r\n\r\n        const interpolation = interpolationOrBake.interpolationType;\r\n        const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;\r\n\r\n        if (shouldBakeAnimation) {\r\n            _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n        else {\r\n            if (interpolation === AnimationSamplerInterpolation.LINEAR || interpolation === AnimationSamplerInterpolation.STEP) {\r\n                _GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n\r\n            }\r\n            else if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                _GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n            }\r\n            else {\r\n                _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);\r\n            }\r\n        }\r\n\r\n        if (inputs.length && outputs.length) {\r\n            const result: _IAnimationData = {\r\n                inputs: inputs,\r\n                outputs: outputs,\r\n                samplerInterpolation: interpolation,\r\n                inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),\r\n                inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond)\r\n            };\r\n\r\n            return result;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _DeduceAnimationInfo(animation: Animation): Nullable<_IAnimationInfo> {\r\n        let animationChannelTargetPath: Nullable<AnimationChannelTargetPath> = null;\r\n        let dataAccessorType = AccessorType.VEC3;\r\n        let useQuaternion: boolean = false;\r\n        let property = animation.targetProperty.split('.');\r\n        switch (property[0]) {\r\n            case 'scaling': {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.SCALE;\r\n                break;\r\n            }\r\n            case 'position': {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.TRANSLATION;\r\n                break;\r\n            }\r\n            case 'rotation': {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case 'rotationQuaternion': {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                useQuaternion = true;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported animatable property ${property[0]}`);\r\n            }\r\n        }\r\n        if (animationChannelTargetPath) {\r\n            return { animationChannelTargetPath: animationChannelTargetPath, dataAccessorType: dataAccessorType, useQuaternion: useQuaternion };\r\n        }\r\n        else {\r\n            Tools.Error('animation channel target path and data accessor type could be deduced');\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the transform node animations\r\n     * @param babylonTransformNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param convertToRightHandedSystem\r\n     */\r\n    public static _CreateNodeAnimationFromTransformNodeAnimations(babylonTransformNode: TransformNode, runtimeGLTFAnimation: IAnimation, idleGLTFAnimations: IAnimation[], nodeMap: { [key: number]: number }, nodes: INode[], binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, animationSampleRate: number) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonTransformNode.animations) {\r\n            for (let animation of babylonTransformNode.animations) {\r\n                let animationInfo = _GLTFAnimation._DeduceAnimationInfo(animation);\r\n                if (animationInfo) {\r\n                    glTFAnimation = {\r\n                        name: animation.name,\r\n                        samplers: [],\r\n                        channels: []\r\n                    };\r\n                    _GLTFAnimation.AddAnimation(`${animation.name}`,\r\n                        animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                        babylonTransformNode,\r\n                        animation,\r\n                        animationInfo.dataAccessorType,\r\n                        animationInfo.animationChannelTargetPath,\r\n                        nodeMap,\r\n                        binaryWriter,\r\n                        bufferViews,\r\n                        accessors,\r\n                        convertToRightHandedSystem,\r\n                        animationInfo.useQuaternion,\r\n                        animationSampleRate\r\n                    );\r\n                    if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                        idleGLTFAnimations.push(glTFAnimation);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the animation groups\r\n     * @param babylonScene\r\n     * @param glTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param convertToRightHandedSystem\r\n     */\r\n    public static _CreateNodeAnimationFromAnimationGroups(babylonScene: Scene, glTFAnimations: IAnimation[], nodeMap: { [key: number]: number }, nodes: INode[], binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, animationSampleRate: number) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonScene.animationGroups) {\r\n            let animationGroups = babylonScene.animationGroups;\r\n\r\n            for (let animationGroup of animationGroups) {\r\n                glTFAnimation = {\r\n                    name: animationGroup.name,\r\n                    channels: [],\r\n                    samplers: []\r\n                };\r\n                for (let targetAnimation of animationGroup.targetedAnimations) {\r\n                    let target = targetAnimation.target;\r\n                    let animation = targetAnimation.animation;\r\n                    if (target instanceof Mesh || target.length === 1 && target[0] instanceof Mesh) { // TODO: Update to support bones\r\n                        let animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            let babylonMesh = target instanceof Mesh ? target : target[0] as Mesh;\r\n                            _GLTFAnimation.AddAnimation(`${animation.name}`,\r\n                                glTFAnimation,\r\n                                babylonMesh,\r\n                                animation,\r\n                                animationInfo.dataAccessorType,\r\n                                animationInfo.animationChannelTargetPath,\r\n                                nodeMap,\r\n                                binaryWriter,\r\n                                bufferViews,\r\n                                accessors,\r\n                                convertToRightHandedSystem,\r\n                                animationInfo.useQuaternion,\r\n                                animationSampleRate\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n                if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {\r\n                    glTFAnimations.push(glTFAnimation);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static AddAnimation(name: string, glTFAnimation: IAnimation, babylonTransformNode: TransformNode, animation: Animation, dataAccessorType: AccessorType, animationChannelTargetPath: AnimationChannelTargetPath, nodeMap: { [key: number]: number }, binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, useQuaternion: boolean, animationSampleRate: number) {\r\n        let animationData = _GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion, animationSampleRate);\r\n        let bufferView: IBufferView;\r\n        let accessor: IAccessor;\r\n        let keyframeAccessorIndex: number;\r\n        let dataAccessorIndex: number;\r\n        let outputLength: number;\r\n        let animationSampler: IAnimationSampler;\r\n        let animationChannel: IAnimationChannel;\r\n\r\n        if (animationData) {\r\n            let nodeIndex = nodeMap[babylonTransformNode.uniqueId];\r\n\r\n            // Creates buffer view and accessor for key frames.\r\n            let byteLength = animationData.inputs.length * 4;\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  keyframe data view`);\r\n            bufferViews.push(bufferView);\r\n\r\n            animationData.inputs.forEach(function(input) {\r\n                binaryWriter.setFloat32(input);\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  keyframes`, AccessorType.SCALAR, AccessorComponentType.FLOAT, animationData.inputs.length, null, [animationData.inputsMin], [animationData.inputsMax]);\r\n            accessors.push(accessor);\r\n            keyframeAccessorIndex = accessors.length - 1;\r\n\r\n            // create bufferview and accessor for keyed values.\r\n            outputLength = animationData.outputs.length;\r\n            byteLength = dataAccessorType === AccessorType.VEC3 ? animationData.outputs.length * 12 : animationData.outputs.length * 16;\r\n\r\n            // check for in and out tangents\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  data view`);\r\n            bufferViews.push(bufferView);\r\n\r\n            animationData.outputs.forEach(function(output) {\r\n                output.forEach(function(entry) {\r\n                    binaryWriter.setFloat32(entry);\r\n                });\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  data`, dataAccessorType, AccessorComponentType.FLOAT, outputLength, null, null, null);\r\n            accessors.push(accessor);\r\n            dataAccessorIndex = accessors.length - 1;\r\n\r\n            // create sampler\r\n            animationSampler = {\r\n                interpolation: animationData.samplerInterpolation,\r\n                input: keyframeAccessorIndex,\r\n                output: dataAccessorIndex\r\n            };\r\n            glTFAnimation.samplers.push(animationSampler);\r\n\r\n            // create channel\r\n            animationChannel = {\r\n                sampler: glTFAnimation.samplers.length - 1,\r\n                target: {\r\n                    node: nodeIndex,\r\n                    path: animationChannelTargetPath\r\n                }\r\n            };\r\n            glTFAnimation.channels.push(animationChannel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a baked animation\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation corresponding to the BabylonJS mesh\r\n     * @param animationChannelTargetPath animation target channel\r\n     * @param minFrame minimum animation frame\r\n     * @param maxFrame maximum animation frame\r\n     * @param fps frames per second of the animation\r\n     * @param inputs input key frames of the animation\r\n     * @param outputs output key frame data of the animation\r\n     * @param convertToRightHandedSystem converts the values to right-handed\r\n     * @param useQuaternion specifies if quaternions should be used\r\n     */\r\n    private static _CreateBakedAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, minFrame: number, maxFrame: number, fps: number, sampleRate: number, inputs: number[], outputs: number[][], minMaxFrames: { min: number, max: number }, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let value: number | Vector3 | Quaternion;\r\n        let quaternionCache: Quaternion = Quaternion.Identity();\r\n        let previousTime: Nullable<number> = null;\r\n        let time: number;\r\n        let maxUsedFrame: Nullable<number> = null;\r\n        let currKeyFrame: Nullable<IAnimationKey> = null;\r\n        let nextKeyFrame: Nullable<IAnimationKey> = null;\r\n        let prevKeyFrame: Nullable<IAnimationKey> = null;\r\n        let endFrame: Nullable<number> = null;\r\n        minMaxFrames.min = Tools.FloatRound(minFrame / fps);\r\n\r\n        let keyFrames = animation.getKeys();\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            endFrame = null;\r\n            currKeyFrame = keyFrames[i];\r\n\r\n            if (i + 1 < length) {\r\n                nextKeyFrame = keyFrames[i + 1];\r\n                if (currKeyFrame.value.equals(nextKeyFrame.value)) {\r\n                    if (i === 0) { // set the first frame to itself\r\n                        endFrame = currKeyFrame.frame;\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    endFrame = nextKeyFrame.frame;\r\n                }\r\n            }\r\n            else {\r\n                // at the last key frame\r\n                prevKeyFrame = keyFrames[i - 1];\r\n                if (currKeyFrame.value.equals(prevKeyFrame.value)) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    endFrame = maxFrame;\r\n                }\r\n            }\r\n            if (endFrame) {\r\n                for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {\r\n                    time = Tools.FloatRound(f / fps);\r\n                    if (time === previousTime) {\r\n                        continue;\r\n                    }\r\n                    previousTime = time;\r\n                    maxUsedFrame = time;\r\n                    value = animation._interpolate(f, 0, undefined, animation.loopMode);\r\n\r\n                    _GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n                }\r\n            }\r\n        }\r\n        if (maxUsedFrame) {\r\n            minMaxFrames.max = maxUsedFrame;\r\n        }\r\n    }\r\n\r\n    private static _ConvertFactorToVector3OrQuaternion(factor: number, babylonTransformNode: TransformNode, animation: Animation, animationType: number, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean): Nullable<Vector3 | Quaternion> {\r\n        let property: string[];\r\n        let componentName: string;\r\n        let value: Nullable<Quaternion | Vector3> = null;\r\n        const basePositionRotationOrScale = _GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n        if (animationType === Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n            property = animation.targetProperty.split('.');\r\n            componentName = property ? property[1] : ''; // x, y, or z component\r\n            value = useQuaternion ? BABYLON.Quaternion.FromArray(basePositionRotationOrScale).normalize() : BABYLON.Vector3.FromArray(basePositionRotationOrScale);\r\n\r\n            switch (componentName) {\r\n                case 'x': {\r\n                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'y': {\r\n                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'z': {\r\n                    value[componentName] = (convertToRightHandedSystem && !useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'w': {\r\n                    (value as Quaternion).w = factor;\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`glTFAnimation: Unsupported component type \"${componentName}\" for scale animation!`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    private static _SetInterpolatedValue(babylonTransformNode: TransformNode, value: Nullable<number | Vector3 | Quaternion>, time: number, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, quaternionCache: Quaternion, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        const animationType = animation.dataType;\r\n        let cacheValue: Vector3 | Quaternion;\r\n        inputs.push(time);\r\n        if (typeof value === \"number\") {\r\n            value = this._ConvertFactorToVector3OrQuaternion(value as number, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n        if (value) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (useQuaternion) {\r\n                    quaternionCache = value as Quaternion;\r\n                }\r\n                else {\r\n                    cacheValue = value as Vector3;\r\n                    Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);\r\n                }\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedQuaternionFromRef(quaternionCache);\r\n\r\n                    if (!babylonTransformNode.parent) {\r\n                        quaternionCache = Quaternion.FromArray([0, 1, 0, 0]).multiply(quaternionCache);\r\n                    }\r\n                }\r\n                outputs.push(quaternionCache.asArray());\r\n            }\r\n            else {\r\n                cacheValue = value as Vector3;\r\n                if (convertToRightHandedSystem && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) {\r\n                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(cacheValue);\r\n                    if (!babylonTransformNode.parent) {\r\n                        cacheValue.x *= -1;\r\n                        cacheValue.z *= -1;\r\n                    }\r\n                }\r\n\r\n                outputs.push(cacheValue.asArray());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates linear animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateLinearOrStepAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, frameDelta: number, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        for (let keyFrame of animation.getKeys()) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates cubic spline animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateCubicSplineAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, frameDelta: number, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        animation.getKeys().forEach(function(keyFrame) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation.AddSplineTangent(\r\n                babylonTransformNode,\r\n                _TangentType.INTANGENT,\r\n                outputs,\r\n                animationChannelTargetPath,\r\n                AnimationSamplerInterpolation.CUBICSPLINE,\r\n                keyFrame,\r\n                frameDelta,\r\n                useQuaternion,\r\n                convertToRightHandedSystem\r\n            );\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);\r\n\r\n            _GLTFAnimation.AddSplineTangent(\r\n                babylonTransformNode,\r\n                _TangentType.OUTTANGENT,\r\n                outputs,\r\n                animationChannelTargetPath,\r\n                AnimationSamplerInterpolation.CUBICSPLINE,\r\n                keyFrame,\r\n                frameDelta,\r\n                useQuaternion,\r\n                convertToRightHandedSystem\r\n            );\r\n        });\r\n    }\r\n\r\n    private static _GetBasePositionRotationOrScale(babylonTransformNode: TransformNode, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let basePositionRotationOrScale: number[];\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                if (babylonTransformNode.rotationQuaternion) {\r\n                    basePositionRotationOrScale = babylonTransformNode.rotationQuaternion.asArray();\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(basePositionRotationOrScale);\r\n                        if (!babylonTransformNode.parent) {\r\n                            basePositionRotationOrScale = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(basePositionRotationOrScale)).asArray();\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    basePositionRotationOrScale = BABYLON.Quaternion.Identity().asArray();\r\n                }\r\n            }\r\n            else {\r\n                basePositionRotationOrScale = babylonTransformNode.rotation.asArray();\r\n                _GLTFUtilities._GetRightHandedNormalArray3FromRef(basePositionRotationOrScale);\r\n            }\r\n        }\r\n        else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n            basePositionRotationOrScale = babylonTransformNode.position.asArray();\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedPositionArray3FromRef(basePositionRotationOrScale);\r\n            }\r\n        }\r\n        else { // scale\r\n            basePositionRotationOrScale = babylonTransformNode.scaling.asArray();\r\n        }\r\n        return basePositionRotationOrScale;\r\n    }\r\n\r\n    /**\r\n     * Adds a key frame value\r\n     * @param keyFrame\r\n     * @param animation\r\n     * @param outputs\r\n     * @param animationChannelTargetPath\r\n     * @param basePositionRotationOrScale\r\n     * @param convertToRightHandedSystem\r\n     * @param useQuaternion\r\n     */\r\n    private static _AddKeyframeValue(keyFrame: IAnimationKey, animation: Animation, outputs: number[][], animationChannelTargetPath: AnimationChannelTargetPath, babylonTransformNode: TransformNode, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let value: number[];\r\n        let newPositionRotationOrScale: Nullable<Vector3 | Quaternion>;\r\n        const animationType = animation.dataType;\r\n        if (animationType === Animation.ANIMATIONTYPE_VECTOR3) {\r\n            value = keyFrame.value.asArray();\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                const array = Vector3.FromArray(value);\r\n                let rotationQuaternion = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n\r\n                    if (!babylonTransformNode.parent) {\r\n                        rotationQuaternion = Quaternion.FromArray([0, 1, 0, 0]).multiply(rotationQuaternion);\r\n                    }\r\n                }\r\n                value = rotationQuaternion.asArray();\r\n            }\r\n            else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedNormalArray3FromRef(value);\r\n                    if (!babylonTransformNode.parent) {\r\n                        value[0] *= -1;\r\n                        value[2] *= -1;\r\n                    }\r\n                }\r\n            }\r\n            outputs.push(value); // scale  vector.\r\n\r\n        }\r\n        else if (animationType === Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n            newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(keyFrame.value as number, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n            if (newPositionRotationOrScale) {\r\n                if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                    let posRotScale = useQuaternion ? newPositionRotationOrScale as Quaternion : Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionFromRef(posRotScale);\r\n\r\n                        if (!babylonTransformNode.parent) {\r\n                            posRotScale = Quaternion.FromArray([0, 1, 0, 0]).multiply(posRotScale);\r\n                        }\r\n                    }\r\n                    outputs.push(posRotScale.asArray());\r\n                }\r\n                else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(newPositionRotationOrScale as Vector3);\r\n\r\n                        if (!babylonTransformNode.parent) {\r\n                            newPositionRotationOrScale.x *= -1;\r\n                            newPositionRotationOrScale.z *= -1;\r\n                        }\r\n                    }\r\n                }\r\n                outputs.push(newPositionRotationOrScale.asArray());\r\n            }\r\n        }\r\n        else if (animationType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            value = (keyFrame.value as Quaternion).normalize().asArray();\r\n\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(value);\r\n\r\n                if (!babylonTransformNode.parent) {\r\n                    value = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(value)).asArray();\r\n                }\r\n            }\r\n\r\n            outputs.push(value);\r\n        }\r\n        else {\r\n            Tools.Error('glTFAnimation: Unsupported key frame values for animation!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine the interpolation based on the key frames\r\n     * @param keyFrames\r\n     * @param animationChannelTargetPath\r\n     * @param useQuaternion\r\n     */\r\n    private static _DeduceInterpolation(keyFrames: IAnimationKey[], animationChannelTargetPath: AnimationChannelTargetPath, useQuaternion: boolean): { interpolationType: AnimationSamplerInterpolation, shouldBakeAnimation: boolean } {\r\n        let interpolationType: AnimationSamplerInterpolation | undefined;\r\n        let shouldBakeAnimation = false;\r\n        let key: IAnimationKey;\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION && !useQuaternion) {\r\n            return { interpolationType: AnimationSamplerInterpolation.LINEAR, shouldBakeAnimation: true };\r\n        }\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            key = keyFrames[i];\r\n            if (key.inTangent || key.outTangent) {\r\n                if (interpolationType) {\r\n                    if (interpolationType !== AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    interpolationType = AnimationSamplerInterpolation.CUBICSPLINE;\r\n                }\r\n            }\r\n            else {\r\n                if (interpolationType) {\r\n                    if (interpolationType === AnimationSamplerInterpolation.CUBICSPLINE ||\r\n                        (key.interpolation && (key.interpolation === AnimationKeyInterpolation.STEP) && interpolationType !== AnimationSamplerInterpolation.STEP)) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (key.interpolation && (key.interpolation === AnimationKeyInterpolation.STEP)) {\r\n                        interpolationType = AnimationSamplerInterpolation.STEP;\r\n                    }\r\n                    else {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!interpolationType) {\r\n            interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n        }\r\n\r\n        return { interpolationType: interpolationType, shouldBakeAnimation: shouldBakeAnimation };\r\n    }\r\n\r\n    /**\r\n     * Adds an input tangent or output tangent to the output data\r\n     * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion\r\n     * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)\r\n     * @param outputs The animation data by keyframe\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param interpolation The interpolation type\r\n     * @param keyFrame The key frame with the animation data\r\n     * @param frameDelta Time difference between two frames used to scale the tangent by the frame delta\r\n     * @param useQuaternion Specifies if quaternions are used\r\n     * @param convertToRightHandedSystem Specifies if the values should be converted to right-handed\r\n     */\r\n    private static AddSplineTangent(babylonTransformNode: TransformNode, tangentType: _TangentType, outputs: number[][], animationChannelTargetPath: AnimationChannelTargetPath, interpolation: AnimationSamplerInterpolation, keyFrame: IAnimationKey, frameDelta: number, useQuaternion: boolean, convertToRightHandedSystem: boolean) {\r\n        let tangent: number[];\r\n        let tangentValue: Vector3 | Quaternion = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;\r\n        if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (tangentValue) {\r\n                    if (useQuaternion) {\r\n                        tangent = (tangentValue as Quaternion).scale(frameDelta).asArray();\r\n                    }\r\n                    else {\r\n                        const array = (tangentValue as Vector3).scale(frameDelta);\r\n                        tangent = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();\r\n                    }\r\n\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(tangent);\r\n                        if (!babylonTransformNode.parent) {\r\n                            tangent = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(tangent)).asArray();\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    tangent = [0, 0, 0, 0];\r\n                }\r\n            }\r\n            else {\r\n                if (tangentValue) {\r\n                    tangent = (tangentValue as Vector3).scale(frameDelta).asArray();\r\n                    if (convertToRightHandedSystem) {\r\n                        if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                            _GLTFUtilities._GetRightHandedPositionArray3FromRef(tangent);\r\n                            if (!babylonTransformNode.parent) {\r\n                                tangent[0] *= -1; // x\r\n                                tangent[2] *= -1; // z\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    tangent = [0, 0, 0];\r\n                }\r\n            }\r\n\r\n            outputs.push(tangent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the minimum and maximum key frames' frame values\r\n     * @param keyFrames animation key frames\r\n     * @returns the minimum and maximum key frame value\r\n     */\r\n    private static calculateMinMaxKeyFrames(keyFrames: IAnimationKey[]): { min: number, max: number } {\r\n        let min: number = Infinity;\r\n        let max: number = -Infinity;\r\n        keyFrames.forEach(function(keyFrame) {\r\n            min = Math.min(min, keyFrame.frame);\r\n            max = Math.max(max, keyFrame.frame);\r\n        });\r\n\r\n        return { min: min, max: max };\r\n\r\n    }\r\n}","import { Nullable, Color3, Scalar, Material, StandardMaterial, PBRMetallicRoughnessMaterial, PBRMaterial, Tools, Engine, Scene, Texture, PostProcess, RawTexture, BaseTexture, TextureTools } from \"babylonjs\";\r\nimport { ITextureInfo, ImageMimeType, IMaterial, IMaterialPbrMetallicRoughness, MaterialAlphaMode, IMaterialOcclusionTextureInfo, ISampler, TextureMagFilter, TextureMinFilter, TextureWrapMode, ITexture, IImage } from \"babylonjs-gltf2interface\";\r\nimport { _Exporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @hidden\r\n */\r\ninterface _IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n    */\r\n    diffuseColor: BABYLON.Color3;\r\n    /**\r\n     * Represents the linear specular factors of the material\r\n    */\r\n    specularColor: BABYLON.Color3;\r\n    /**\r\n     * Represents the smoothness of the material\r\n    */\r\n    glossiness: number;\r\n}\r\n\r\n/**\r\n * Interface for storing metallic roughness factors\r\n * @hidden\r\n */\r\ninterface _IPBRMetallicRoughness {\r\n    /**\r\n     * Represents the albedo color of the material\r\n    */\r\n    baseColor: BABYLON.Color3;\r\n    /**\r\n     * Represents the metallness of the material\r\n    */\r\n    metallic: Nullable<number>;\r\n    /**\r\n     * Represents the roughness of the material\r\n    */\r\n    roughness: Nullable<number>;\r\n    /**\r\n     * The metallic roughness texture as a base64 string\r\n    */\r\n    metallicRoughnessTextureBase64?: Nullable<string>;\r\n    /**\r\n     * The base color texture as a base64 string\r\n    */\r\n    baseColorTextureBase64?: Nullable<string>;\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.  This class should only be used internally\r\n * @hidden\r\n */\r\nexport class _GLTFMaterialExporter {\r\n    /**\r\n     * Represents the dielectric specular values for R, G and B\r\n     */\r\n    private static readonly _DielectricSpecular: Color3 = new Color3(0.04, 0.04, 0.04);\r\n\r\n    /**\r\n     * Allows the maximum specular power to be defined for material calculations\r\n     */\r\n    private static readonly _MaxSpecularPower = 1024;\r\n\r\n    /**\r\n     * Mapping to store textures\r\n     */\r\n    private _textureMap: { [textureId: string]: ITextureInfo } = {};\r\n\r\n    /**\r\n     * Numeric tolerance value\r\n     */\r\n    private static readonly _Epsilon = 1e-6;\r\n\r\n    /**\r\n     * Reference to the glTF Exporter\r\n     */\r\n    private _exporter: _Exporter;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._textureMap = {};\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /**\r\n     * Specifies if two colors are approximately equal in value\r\n     * @param color1 first color to compare to\r\n     * @param color2 second color to compare to\r\n     * @param epsilon threshold value\r\n     */\r\n    private static FuzzyEquals(color1: Color3, color2: Color3, epsilon: number): boolean {\r\n        return Scalar.WithinEpsilon(color1.r, color2.r, epsilon) &&\r\n            Scalar.WithinEpsilon(color1.g, color2.g, epsilon) &&\r\n            Scalar.WithinEpsilon(color1.b, color2.b, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Gets the materials from a Babylon scene and converts them to glTF materials\r\n     * @param scene babylonjs scene\r\n     * @param mimeType texture mime type\r\n     * @param images array of images\r\n     * @param textures array of textures\r\n     * @param materials array of materials\r\n     * @param imageData mapping of texture names to base64 textures\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the material\r\n     */\r\n    public _convertMaterialsToGLTFAsync(babylonMaterials: Material[], mimeType: ImageMimeType, hasTextureCoords: boolean) {\r\n        let promises: Promise<void>[] = [];\r\n        for (let babylonMaterial of babylonMaterials) {\r\n            if (babylonMaterial instanceof StandardMaterial) {\r\n                promises.push(this._convertStandardMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else if (babylonMaterial instanceof PBRMetallicRoughnessMaterial) {\r\n                promises.push(this._convertPBRMetallicRoughnessMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else if (babylonMaterial instanceof PBRMaterial) {\r\n                promises.push(this._convertPBRMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else {\r\n                Tools.Warn(`Unsupported material type: ${babylonMaterial.name}`);\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { /* do nothing */ });\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the glTF material without the texture parameters\r\n     * @param originalMaterial original glTF material\r\n     * @returns glTF material without texture parameters\r\n     */\r\n    public _stripTexturesFromMaterial(originalMaterial: IMaterial): IMaterial {\r\n        let newMaterial: IMaterial = {};\r\n        if (originalMaterial) {\r\n            newMaterial.name = originalMaterial.name;\r\n            newMaterial.doubleSided = originalMaterial.doubleSided;\r\n            newMaterial.alphaMode = originalMaterial.alphaMode;\r\n            newMaterial.alphaCutoff = originalMaterial.alphaCutoff;\r\n            newMaterial.emissiveFactor = originalMaterial.emissiveFactor;\r\n            const originalPBRMetallicRoughness = originalMaterial.pbrMetallicRoughness;\r\n            if (originalPBRMetallicRoughness) {\r\n                newMaterial.pbrMetallicRoughness = {};\r\n                newMaterial.pbrMetallicRoughness.baseColorFactor = originalPBRMetallicRoughness.baseColorFactor;\r\n                newMaterial.pbrMetallicRoughness.metallicFactor = originalPBRMetallicRoughness.metallicFactor;\r\n                newMaterial.pbrMetallicRoughness.roughnessFactor = originalPBRMetallicRoughness.roughnessFactor;\r\n            }\r\n        }\r\n        return newMaterial;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material has any texture parameters present\r\n     * @param material glTF Material\r\n     * @returns boolean specifying if texture parameters are present\r\n     */\r\n    public _hasTexturesPresent(material: IMaterial): boolean {\r\n        if (material.emissiveTexture || material.normalTexture || material.occlusionTexture) {\r\n            return true;\r\n        }\r\n        const pbrMat = material.pbrMetallicRoughness;\r\n        if (pbrMat) {\r\n            if (pbrMat.baseColorTexture || pbrMat.metallicRoughnessTexture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon StandardMaterial to a glTF Metallic Roughness Material\r\n     * @param babylonStandardMaterial\r\n     * @returns glTF Metallic Roughness Material representation\r\n     */\r\n    public _convertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n        const P0 = new BABYLON.Vector2(0, 1);\r\n        const P1 = new BABYLON.Vector2(0, 0.1);\r\n        const P2 = new BABYLON.Vector2(0, 0.1);\r\n        const P3 = new BABYLON.Vector2(1300, 0.1);\r\n\r\n        /**\r\n         * Given the control points, solve for x based on a given t for a cubic bezier curve\r\n         * @param t a value between 0 and 1\r\n         * @param p0 first control point\r\n         * @param p1 second control point\r\n         * @param p2 third control point\r\n         * @param p3 fourth control point\r\n         * @returns number result of cubic bezier curve at the specified t\r\n         */\r\n        function _cubicBezierCurve(t: number, p0: number, p1: number, p2: number, p3: number): number {\r\n            return (\r\n                (1 - t) * (1 - t) * (1 - t) * p0 +\r\n                3 * (1 - t) * (1 - t) * t * p1 +\r\n                3 * (1 - t) * t * t * p2 +\r\n                t * t * t * p3\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Evaluates a specified specular power value to determine the appropriate roughness value,\r\n         * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)\r\n         * and roughness on the ordinant axis (y-axis)\r\n         * @param specularPower specular power of standard material\r\n         * @returns Number representing the roughness value\r\n         */\r\n        function _solveForRoughness(specularPower: number): number {\r\n            var t = Math.pow(specularPower / P3.x, 0.333333);\r\n            return _cubicBezierCurve(t, P0.y, P1.y, P2.y, P3.y);\r\n        }\r\n\r\n        let diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace().scale(0.5);\r\n        let opacity = babylonStandardMaterial.alpha;\r\n        let specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, _GLTFMaterialExporter._MaxSpecularPower);\r\n\r\n        const roughness = _solveForRoughness(specularPower);\r\n\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n            baseColorFactor: [\r\n                diffuse.r,\r\n                diffuse.g,\r\n                diffuse.b,\r\n                opacity\r\n            ],\r\n            metallicFactor: 0,\r\n            roughnessFactor: roughness,\r\n        };\r\n\r\n        return glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Computes the metallic factor\r\n     * @param diffuse diffused value\r\n     * @param specular specular value\r\n     * @param oneMinusSpecularStrength one minus the specular strength\r\n     * @returns metallic value\r\n     */\r\n    public static _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n        if (specular < this._DielectricSpecular.r) {\r\n            this._DielectricSpecular;\r\n            return 0;\r\n        }\r\n\r\n        const a = this._DielectricSpecular.r;\r\n        const b = diffuse * oneMinusSpecularStrength / (1.0 - this._DielectricSpecular.r) + specular - 2.0 * this._DielectricSpecular.r;\r\n        const c = this._DielectricSpecular.r - specular;\r\n        const D = b * b - 4.0 * a * c;\r\n        return BABYLON.Scalar.Clamp((-b + Math.sqrt(D)) / (2.0 * a), 0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the glTF alpha mode from the Babylon Material\r\n     * @param babylonMaterial Babylon Material\r\n     * @returns The Babylon alpha mode value\r\n     */\r\n    public _getAlphaMode(babylonMaterial: Material): MaterialAlphaMode {\r\n        if (babylonMaterial.needAlphaBlending()) {\r\n            return MaterialAlphaMode.BLEND;\r\n        }\r\n        else if (babylonMaterial.needAlphaTesting()) {\r\n            return MaterialAlphaMode.MASK;\r\n        }\r\n        else {\r\n            return MaterialAlphaMode.OPAQUE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon Standard Material to a glTF Material\r\n     * @param babylonStandardMaterial BJS Standard Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<void> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        const alphaMode = this._getAlphaMode(babylonStandardMaterial);\r\n        let promises = [];\r\n        const glTFPbrMetallicRoughness = this._convertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const glTFMaterial: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            glTFMaterial.doubleSided = true;\r\n        }\r\n        if (hasTextureCoords) {\r\n            if (babylonStandardMaterial.diffuseTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.diffuseTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.bumpTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.normalTexture = glTFTexture;\r\n                        if (babylonStandardMaterial.bumpTexture != null && babylonStandardMaterial.bumpTexture.level !== 1) {\r\n                            glTFMaterial.normalTexture.scale = babylonStandardMaterial.bumpTexture.level;\r\n                        }\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.emissiveTexture) {\r\n                glTFMaterial.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.emissiveTexture, mimeType).then((glTFEmissiveTexture) => {\r\n                    if (glTFEmissiveTexture) {\r\n                        glTFMaterial.emissiveTexture = glTFEmissiveTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.ambientTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                            index: glTFTexture.index\r\n                        };\r\n                        glTFMaterial.occlusionTexture = occlusionTexture;\r\n                        occlusionTexture.strength = 1.0;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Engine.ALPHA_COMBINE) {\r\n                glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n            }\r\n            else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n        if (babylonStandardMaterial.emissiveColor && !_GLTFMaterialExporter.FuzzyEquals(babylonStandardMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n        if (alphaMode !== MaterialAlphaMode.OPAQUE) {\r\n            switch (alphaMode) {\r\n                case MaterialAlphaMode.BLEND: {\r\n                    glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n                    break;\r\n                }\r\n                case MaterialAlphaMode.MASK: {\r\n                    glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n                    glTFMaterial.alphaCutoff = babylonStandardMaterial.alphaCutOff;\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Warn(`Unsupported alpha mode ${alphaMode}`);\r\n                }\r\n            }\r\n        }\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonStandardMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return Promise.all(promises).then(() => { /* do nothing */ });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material\r\n     * @param babylonPBRMetalRoughMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMetallicRoughnessMaterialAsync(babylonPBRMetalRoughMaterial: PBRMetallicRoughnessMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<void> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        let promises: Promise<void>[] = [];\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n\r\n        if (babylonPBRMetalRoughMaterial.baseColor) {\r\n            glTFPbrMetallicRoughness.baseColorFactor = [\r\n                babylonPBRMetalRoughMaterial.baseColor.r,\r\n                babylonPBRMetalRoughMaterial.baseColor.g,\r\n                babylonPBRMetalRoughMaterial.baseColor.b,\r\n                babylonPBRMetalRoughMaterial.alpha\r\n            ];\r\n        }\r\n\r\n        if (babylonPBRMetalRoughMaterial.metallic != null && babylonPBRMetalRoughMaterial.metallic !== 1) {\r\n            glTFPbrMetallicRoughness.metallicFactor = babylonPBRMetalRoughMaterial.metallic;\r\n        }\r\n        if (babylonPBRMetalRoughMaterial.roughness != null && babylonPBRMetalRoughMaterial.roughness !== 1) {\r\n            glTFPbrMetallicRoughness.roughnessFactor = babylonPBRMetalRoughMaterial.roughness;\r\n        }\r\n\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMetalRoughMaterial.name\r\n        };\r\n        if (babylonPBRMetalRoughMaterial.doubleSided) {\r\n            glTFMaterial.doubleSided = babylonPBRMetalRoughMaterial.doubleSided;\r\n        }\r\n        let alphaMode: Nullable<MaterialAlphaMode> = null;\r\n        if (babylonPBRMetalRoughMaterial.transparencyMode != null) {\r\n            alphaMode = this._getAlphaMode(babylonPBRMetalRoughMaterial);\r\n            if (alphaMode) {\r\n                if (alphaMode !== MaterialAlphaMode.OPAQUE) { //glTF defaults to opaque\r\n                    glTFMaterial.alphaMode = alphaMode;\r\n                    if (alphaMode === MaterialAlphaMode.MASK) {\r\n                        glTFMaterial.alphaCutoff = babylonPBRMetalRoughMaterial.alphaCutOff;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (hasTextureCoords) {\r\n            if (babylonPBRMetalRoughMaterial.baseTexture != null) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.baseTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.normalTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.normalTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.normalTexture = glTFTexture;\r\n                        if (babylonPBRMetalRoughMaterial.normalTexture.level !== 1) {\r\n                            glTFMaterial.normalTexture.scale = babylonPBRMetalRoughMaterial.normalTexture.level;\r\n                        }\r\n                    }\r\n                }));\r\n\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.occlusionTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.occlusionTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.occlusionTexture = glTFTexture;\r\n                        if (babylonPBRMetalRoughMaterial.occlusionStrength != null) {\r\n                            glTFMaterial.occlusionTexture.strength = babylonPBRMetalRoughMaterial.occlusionStrength;\r\n                        }\r\n                    }\r\n                }));\r\n\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.emissiveTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.emissiveTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.emissiveTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n\r\n        }\r\n\r\n        if (_GLTFMaterialExporter.FuzzyEquals(babylonPBRMetalRoughMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonPBRMetalRoughMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonPBRMetalRoughMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return Promise.all(promises).then(() => { /* do nothing */ });\r\n    }\r\n\r\n    /**\r\n     * Converts an image typed array buffer to a base64 image\r\n     * @param buffer typed array buffer\r\n     * @param width width of the image\r\n     * @param height height of the image\r\n     * @param mimeType mimetype of the image\r\n     * @returns base64 image string\r\n     */\r\n    private _createBase64FromCanvasAsync(buffer: Uint8Array | Float32Array, width: number, height: number, mimeType: ImageMimeType): Promise<string> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            let hostingScene: Scene;\r\n\r\n            const textureType = Engine.TEXTURETYPE_UNSIGNED_INT;\r\n            const engine = this._exporter._getLocalEngine();\r\n\r\n            hostingScene = new Scene(engine);\r\n\r\n            // Create a temporary texture with the texture buffer data\r\n            const tempTexture = engine.createRawTexture(buffer, width, height, Engine.TEXTUREFORMAT_RGBA, false, true, Texture.NEAREST_SAMPLINGMODE, null, textureType);\r\n            const postProcess = new PostProcess(\"pass\", \"pass\", null, null, 1, null, Texture.NEAREST_SAMPLINGMODE, engine, false, undefined, Engine.TEXTURETYPE_UNSIGNED_INT, undefined, null, false);\r\n            postProcess.getEffect().executeWhenCompiled(() => {\r\n                postProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", tempTexture);\r\n                };\r\n\r\n                // Set the size of the texture\r\n                engine.setSize(width, height);\r\n                hostingScene.postProcessManager.directRender([postProcess], null);\r\n                postProcess.dispose();\r\n                tempTexture.dispose();\r\n\r\n                // Read data from WebGL\r\n                const canvas = engine.getRenderingCanvas();\r\n\r\n                if (canvas) {\r\n                    if (!canvas.toBlob) { // fallback for browsers without \"canvas.toBlob\"\r\n                        const dataURL = canvas.toDataURL();\r\n                        resolve(dataURL);\r\n                    }\r\n                    else {\r\n                        BABYLON.Tools.ToBlob(canvas, (blob) => {\r\n                            if (blob) {\r\n                                let fileReader = new FileReader();\r\n                                fileReader.onload = (event: any) => {\r\n                                    let base64String = event.target.result as string;\r\n                                    hostingScene.dispose();\r\n                                    resolve(base64String);\r\n                                };\r\n                                fileReader.readAsDataURL(blob);\r\n                            }\r\n                            else {\r\n                                reject(\"gltfMaterialExporter: Failed to get blob from image canvas!\");\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    reject(\"Engine is missing a canvas!\");\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a white texture based on the specified width and height\r\n     * @param width width of the texture in pixels\r\n     * @param height height of the texture in pixels\r\n     * @param scene babylonjs scene\r\n     * @returns white texture\r\n     */\r\n    private _createWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n        const data = new Uint8Array(width * height * 4);\r\n\r\n        for (let i = 0; i < data.length; i = i + 4) {\r\n            data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xFF;\r\n        }\r\n\r\n        const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n        return rawTexture;\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: BaseTexture, texture2: BaseTexture, scene: Scene): { \"texture1\": BaseTexture, \"texture2\": BaseTexture } {\r\n        let texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        let texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1;\r\n        let resizedTexture2;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            }\r\n            else {\r\n                resizedTexture1 = this._createWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2;\r\n        }\r\n        else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            }\r\n            else {\r\n                resizedTexture2 = this._createWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1;\r\n        }\r\n        else {\r\n            resizedTexture1 = texture1;\r\n            resizedTexture2 = texture2;\r\n        }\r\n\r\n        return {\r\n            \"texture1\": resizedTexture1,\r\n            \"texture2\": resizedTexture2\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts an array of pixels to a Float32Array\r\n     * Throws an error if the pixel format is not supported\r\n     * @param pixels - array buffer containing pixel values\r\n     * @returns Float32 of pixels\r\n     */\r\n    private _convertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n        if (pixels instanceof Uint8Array) {\r\n            const length = pixels.length;\r\n            const buffer = new Float32Array(pixels.length);\r\n            for (let i = 0; i < length; ++i) {\r\n                buffer[i] = pixels[i] / 255;\r\n            }\r\n            return buffer;\r\n        }\r\n        else if (pixels instanceof Float32Array) {\r\n            return pixels;\r\n        }\r\n        else {\r\n            throw new Error('Unsupported pixel format!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(diffuseTexture: BaseTexture, specularGlossinessTexture: BaseTexture, factors: _IPBRSpecularGlossiness, mimeType: ImageMimeType): Promise<_IPBRMetallicRoughness> {\r\n        let promises = [];\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return Promise.reject('_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!');\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            let diffuseSize = resizedTextures.texture1.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            let diffusePixels = resizedTextures.texture1.readPixels();\r\n            let specularPixels = resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = this._convertPixelArrayToFloat32(diffusePixels);\r\n            }\r\n            else {\r\n                return Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = this._convertPixelArrayToFloat32(specularPixels);\r\n            }\r\n            else {\r\n                return Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = Color3.Black();\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2]).toLinearSpace().multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2]).toLinearSpace().multiply(factors.specularColor);\r\n                    const glossiness = (specularGlossinessBuffer[offset + 3]) * factors.glossiness;\r\n\r\n                    const specularGlossiness: _IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: _IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(baseColorBuffer[destinationOffset], baseColorBuffer[destinationOffset + 1], baseColorBuffer[destinationOffset + 2]);\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace();\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!_GLTFMaterialExporter.FuzzyEquals(sRGBBaseColorPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!_GLTFMaterialExporter.FuzzyEquals(metallicRoughnessPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                let promise = this._createBase64FromCanvasAsync(metallicRoughnessBuffer, width, height, mimeType).then((metallicRoughnessBase64) => {\r\n                    metallicRoughnessFactors.metallicRoughnessTextureBase64 = metallicRoughnessBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                let promise = this._createBase64FromCanvasAsync(baseColorBuffer, width, height, mimeType).then((baseColorBase64) => {\r\n                    metallicRoughnessFactors.baseColorTextureBase64 = baseColorBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        }\r\n        else {\r\n            return Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: _IPBRSpecularGlossiness): _IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _GLTFMaterialExporter._SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1.0 - _GLTFMaterialExporter._DielectricSpecular.r) / Math.max(1 - metallic, _GLTFMaterialExporter._Epsilon));\r\n        const baseColorFromSpecular = specularGlossiness.specularColor.subtract(_GLTFMaterialExporter._DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic, _GLTFMaterialExporter._Epsilon));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        if (color) {\r\n            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        if (color) {\r\n            return Math.max(color.r, Math.max(color.g, color.b));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, hasTextureCoords: boolean): Promise<_IPBRMetallicRoughness> {\r\n        const promises = [];\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: babylonPBRMaterial.albedoColor,\r\n            metallic: babylonPBRMaterial.metallic,\r\n            roughness: babylonPBRMaterial.roughness\r\n        };\r\n\r\n        if (hasTextureCoords) {\r\n            if (babylonPBRMaterial.albedoTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMaterial.albedoTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonPBRMaterial.metallicTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMaterial.metallicTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            return metallicRoughness;\r\n        });\r\n    }\r\n\r\n    private _getGLTFTextureSampler(texture: BaseTexture): ISampler {\r\n        const sampler = this._getGLTFTextureWrapModesSampler(texture);\r\n\r\n        let samplingMode = texture instanceof Texture ? texture.samplingMode : null;\r\n        if (samplingMode != null) {\r\n            switch (samplingMode) {\r\n                case Texture.LINEAR_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGLTFTextureWrapModesSampler(texture: BaseTexture): ISampler {\r\n        let wrapS = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapU : Texture.WRAP_ADDRESSMODE);\r\n        let wrapT = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapV : Texture.WRAP_ADDRESSMODE);\r\n\r\n        if (wrapS === TextureWrapMode.REPEAT && wrapT === TextureWrapMode.REPEAT) { // default wrapping mode in glTF, so omitting\r\n            return {};\r\n        }\r\n\r\n        return { wrapS: wrapS, wrapT: wrapT };\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, hasTextureCoords: boolean): Promise<_IPBRMetallicRoughness> {\r\n        return Promise.resolve().then(() => {\r\n            const samplers = this._exporter._samplers;\r\n            const textures = this._exporter._textures;\r\n            const specGloss: _IPBRSpecularGlossiness = {\r\n                diffuseColor: babylonPBRMaterial.albedoColor || Color3.White(),\r\n                specularColor: babylonPBRMaterial.reflectivityColor || Color3.White(),\r\n                glossiness: babylonPBRMaterial.microSurface || 1,\r\n            };\r\n            let samplerIndex: Nullable<number> = null;\r\n            const sampler = this._getGLTFTextureSampler(babylonPBRMaterial.albedoTexture);\r\n            if (sampler.magFilter != null && sampler.minFilter != null && sampler.wrapS != null && sampler.wrapT != null) {\r\n                samplers.push(sampler);\r\n                samplerIndex = samplers.length - 1;\r\n            }\r\n            if (babylonPBRMaterial.reflectivityTexture && !babylonPBRMaterial.useMicroSurfaceFromReflectivityMapAlpha) {\r\n                return Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n            }\r\n            if ((babylonPBRMaterial.albedoTexture || babylonPBRMaterial.reflectivityTexture) && hasTextureCoords) {\r\n                return this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(babylonPBRMaterial.albedoTexture, babylonPBRMaterial.reflectivityTexture, specGloss, mimeType).then((metallicRoughnessFactors) => {\r\n                    if (metallicRoughnessFactors.baseColorTextureBase64) {\r\n                        const glTFBaseColorTexture = this._getTextureInfoFromBase64(metallicRoughnessFactors.baseColorTextureBase64, \"bjsBaseColorTexture_\" + (textures.length) + \".png\", mimeType, babylonPBRMaterial.albedoTexture ? babylonPBRMaterial.albedoTexture.coordinatesIndex : null, samplerIndex);\r\n                        if (glTFBaseColorTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFBaseColorTexture;\r\n                        }\r\n                    }\r\n                    if (metallicRoughnessFactors.metallicRoughnessTextureBase64) {\r\n                        const glTFMRColorTexture = this._getTextureInfoFromBase64(metallicRoughnessFactors.metallicRoughnessTextureBase64, \"bjsMetallicRoughnessTexture_\" + (textures.length) + \".png\", mimeType, babylonPBRMaterial.reflectivityTexture ? babylonPBRMaterial.reflectivityTexture.coordinatesIndex : null, samplerIndex);\r\n                        if (glTFMRColorTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFMRColorTexture;\r\n                        }\r\n                    }\r\n\r\n                    return metallicRoughnessFactors;\r\n                });\r\n            }\r\n            else {\r\n                return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMaterialAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<void> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name\r\n        };\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            if (babylonPBRMaterial.albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [\r\n                    babylonPBRMaterial.albedoColor.r,\r\n                    babylonPBRMaterial.albedoColor.g,\r\n                    babylonPBRMaterial.albedoColor.b,\r\n                    babylonPBRMaterial.alpha\r\n                ];\r\n            }\r\n            return this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n        else {\r\n            return this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n    }\r\n\r\n    private setMetallicRoughnessPbrMaterial(metallicRoughness: Nullable<_IPBRMetallicRoughness>, babylonPBRMaterial: PBRMaterial, glTFMaterial: IMaterial, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<void> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        let promises = [];\r\n        if (metallicRoughness) {\r\n            let alphaMode: Nullable<MaterialAlphaMode> = null;\r\n            if (babylonPBRMaterial.transparencyMode != null) {\r\n                alphaMode = this._getAlphaMode(babylonPBRMaterial);\r\n                if (alphaMode) {\r\n                    if (alphaMode !== MaterialAlphaMode.OPAQUE) { //glTF defaults to opaque\r\n                        glTFMaterial.alphaMode = alphaMode;\r\n                        if (alphaMode === MaterialAlphaMode.MASK) {\r\n                            glTFMaterial.alphaCutoff = babylonPBRMaterial.alphaCutOff;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!(_GLTFMaterialExporter.FuzzyEquals(metallicRoughness.baseColor, Color3.White(), _GLTFMaterialExporter._Epsilon) && babylonPBRMaterial.alpha >= _GLTFMaterialExporter._Epsilon)) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [\r\n                    metallicRoughness.baseColor.r,\r\n                    metallicRoughness.baseColor.g,\r\n                    metallicRoughness.baseColor.b,\r\n                    babylonPBRMaterial.alpha\r\n                ];\r\n            }\r\n\r\n            if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n                glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n            }\r\n            if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n                glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n            }\r\n\r\n            if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n                if (!babylonPBRMaterial.twoSidedLighting) {\r\n                    Tools.Warn(babylonPBRMaterial.name + \": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.\");\r\n                }\r\n                glTFMaterial.doubleSided = true;\r\n            }\r\n\r\n            if (hasTextureCoords) {\r\n                if (babylonPBRMaterial.bumpTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (babylonPBRMaterial.bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = babylonPBRMaterial.bumpTexture.level;\r\n                            }\r\n                        }\r\n                    }\r\n                    );\r\n                    promises.push(promise);\r\n\r\n                }\r\n                if (babylonPBRMaterial.ambientTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            let occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n\r\n                            if (babylonPBRMaterial.ambientTextureStrength) {\r\n                                occlusionTexture.strength = babylonPBRMaterial.ambientTextureStrength;\r\n                            }\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n\r\n                }\r\n                if (babylonPBRMaterial.emissiveTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.emissiveTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n            }\r\n            if (!_GLTFMaterialExporter.FuzzyEquals(babylonPBRMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n                glTFMaterial.emissiveFactor = babylonPBRMaterial.emissiveColor.asArray();\r\n            }\r\n\r\n            glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n            materials.push(glTFMaterial);\r\n            materialMap[babylonPBRMaterial.uniqueId] = materials.length - 1;\r\n        }\r\n        return Promise.all(promises).then((result) => { /* do nothing */ });\r\n    }\r\n\r\n    private getPixelsFromTexture(babylonTexture: BaseTexture): Uint8Array | Float32Array {\r\n        const pixels = babylonTexture.textureType === Engine.TEXTURETYPE_UNSIGNED_INT ? babylonTexture.readPixels() as Uint8Array : babylonTexture.readPixels() as Float32Array;\r\n        return pixels;\r\n    }\r\n\r\n    /**\r\n     * Extracts a texture from a Babylon texture into file data and glTF data\r\n     * @param babylonTexture Babylon texture to extract\r\n     * @param mimeType Mime Type of the babylonTexture\r\n     * @return glTF texture info, or null if the texture format is not supported\r\n     */\r\n    public _exportTextureAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const extensionPromise = this._exporter._extensionsPreExportTextureAsync(\"exporter\", babylonTexture as Texture, mimeType);\r\n        if (!extensionPromise) {\r\n            return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n        }\r\n\r\n        return extensionPromise.then((texture) => {\r\n            if (!texture) {\r\n                return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n            }\r\n            return this._exportTextureInfoAsync(texture, mimeType);\r\n        });\r\n    }\r\n\r\n    public _exportTextureInfoAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        return Promise.resolve().then(() => {\r\n            const textureUid = babylonTexture.uid;\r\n            if (textureUid in this._textureMap) {\r\n                return this._textureMap[textureUid];\r\n            }\r\n            else {\r\n                const samplers = this._exporter._samplers;\r\n                const sampler = this._getGLTFTextureSampler(babylonTexture);\r\n                let samplerIndex: Nullable<number> = null;\r\n\r\n                //  if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n                let foundSamplerIndex: Nullable<number> = null;\r\n                for (let i = 0; i < samplers.length; ++i) {\r\n                    let s = samplers[i];\r\n                    if (s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter &&\r\n                        s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT) {\r\n                        foundSamplerIndex = i;\r\n                        break;\r\n                    }\r\n                }\r\n                if (foundSamplerIndex == null) {\r\n                    samplers.push(sampler);\r\n                    samplerIndex = samplers.length - 1;\r\n                }\r\n                else {\r\n                    samplerIndex = foundSamplerIndex;\r\n                }\r\n                const pixels = this.getPixelsFromTexture(babylonTexture);\r\n                const size = babylonTexture.getSize();\r\n\r\n                return this._createBase64FromCanvasAsync(pixels, size.width, size.height, mimeType).then((base64Data) => {\r\n                    const textureInfo = this._getTextureInfoFromBase64(base64Data, babylonTexture.name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\"), mimeType, babylonTexture.coordinatesIndex, samplerIndex);\r\n                    if (textureInfo) {\r\n                        this._textureMap[textureUid] = textureInfo;\r\n                    }\r\n                    return textureInfo;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Builds a texture from base64 string\r\n     * @param base64Texture base64 texture string\r\n     * @param baseTextureName Name to use for the texture\r\n     * @param mimeType image mime type for the texture\r\n     * @param images array of images\r\n     * @param textures array of textures\r\n     * @param imageData map of image data\r\n     * @returns glTF texture info, or null if the texture format is not supported\r\n     */\r\n    private _getTextureInfoFromBase64(base64Texture: string, baseTextureName: string, mimeType: ImageMimeType, texCoordIndex: Nullable<number>, samplerIndex: Nullable<number>): Nullable<ITextureInfo> {\r\n        const textures = this._exporter._textures;\r\n        const images = this._exporter._images;\r\n        const imageData = this._exporter._imageData;\r\n        let textureInfo: Nullable<ITextureInfo> = null;\r\n\r\n        const glTFTexture: ITexture = {\r\n            source: images.length,\r\n            name: baseTextureName\r\n        };\r\n        if (samplerIndex != null) {\r\n            glTFTexture.sampler = samplerIndex;\r\n        }\r\n\r\n        const binStr = atob(base64Texture.split(',')[1]);\r\n        let arrBuff = new ArrayBuffer(binStr.length);\r\n        const arr = new Uint8Array(arrBuff);\r\n        for (let i = 0, length = binStr.length; i < length; ++i) {\r\n            arr[i] = binStr.charCodeAt(i);\r\n        }\r\n        const imageValues = { data: arr, mimeType: mimeType };\r\n\r\n        let extension = mimeType === ImageMimeType.JPEG ? '.jpeg' : '.png';\r\n        let textureName = baseTextureName + extension;\r\n        if (textureName in imageData) {\r\n            textureName = `${baseTextureName}_${Tools.RandomId()}${extension}`;\r\n        }\r\n\r\n        imageData[textureName] = imageValues;\r\n        if (mimeType === ImageMimeType.JPEG || mimeType === ImageMimeType.PNG) {\r\n            const glTFImage: IImage = {\r\n                name: baseTextureName,\r\n                uri: textureName\r\n            };\r\n            let foundIndex: Nullable<number> = null;\r\n            for (let i = 0; i < images.length; ++i) {\r\n                if (images[i].uri === textureName) {\r\n                    foundIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n            if (foundIndex == null) {\r\n                images.push(glTFImage);\r\n                glTFTexture.source = images.length - 1;\r\n            }\r\n            else {\r\n                glTFTexture.source = foundIndex;\r\n\r\n            }\r\n            textures.push(glTFTexture);\r\n            textureInfo = {\r\n                index: textures.length - 1\r\n            };\r\n            if (texCoordIndex != null) {\r\n                textureInfo.texCoord = texCoordIndex;\r\n            }\r\n        }\r\n        else {\r\n            Tools.Error(`Unsupported texture mime type ${mimeType}`);\r\n        }\r\n\r\n        return textureInfo;\r\n    }\r\n}","import { TransformNode, Scene } from \"babylonjs\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _Exporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Holds a collection of exporter options and parameters\r\n */\r\nexport interface IExportOptions {\r\n    /**\r\n     * Function which indicates whether a babylon mesh should be exported or not\r\n     * @param transformNode source Babylon transform node. It is used to check whether it should be exported to glTF or not\r\n     * @returns boolean, which indicates whether the mesh should be exported (true) or not (false)\r\n     */\r\n    shouldExportTransformNode?(transformNode: TransformNode): boolean;\r\n    /**\r\n     * The sample rate to bake animation curves\r\n     */\r\n    animationSampleRate?: number;\r\n\r\n    /**\r\n     * Begin serialization without waiting for the scene to be ready\r\n     */\r\n    exportWithoutWaitingForScene?: boolean;\r\n}\r\n\r\n/**\r\n * Class for generating glTF data from a Babylon scene.\r\n */\r\nexport class GLTF2Export {\r\n    /**\r\n     * Exports the geometry of the scene to .gltf file format asynchronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating the glTF file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .gltf file and associates texture names\r\n     * as keys and their data and paths as values\r\n     */\r\n    public static GLTFAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return scene.whenReadyAsync().then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLTFAsync(glTFPrefix);\r\n        });\r\n    }\r\n\r\n    private static _PreExportAsync(scene: Scene, options?: IExportOptions): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return Promise.resolve();\r\n            }\r\n            else {\r\n                return scene.whenReadyAsync();\r\n            }\r\n        });\r\n    }\r\n\r\n    private static _PostExportAsync(scene: Scene, glTFData: GLTFData, options?: IExportOptions): Promise<GLTFData> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return glTFData;\r\n            }\r\n            else {\r\n                return glTFData;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Exports the geometry of the scene to .glb file format asychronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating glb file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .glb filename as key and data as value\r\n     */\r\n    public static GLBAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return this._PreExportAsync(scene, options).then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLBAsync(glTFPrefix).then((glTFData) => {\r\n                return this._PostExportAsync(scene, glTFData, options);\r\n            });\r\n        });\r\n    }\r\n}\r\n","export * from \"./KHR_texture_transform\";","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import \"../src\";\r\nexport * from \"./legacy-glTF2Serializer\";\r\nexport * from \"./legacy-objSerializer\";","export * from \"./OBJ\";\r\nexport * from \"./glTF\";","import { Mesh, Nullable, Matrix, Geometry, Tools, StandardMaterial } from \"babylonjs\";\n\n/**\n * Class for generating OBJ data from a Babylon scene.\n */\nexport class OBJExport {\n    /**\n     * Exports the geometry of a Mesh array in .OBJ file format (text)\n     * @param mesh defines the list of meshes to serialize\n     * @param materials defines if materials should be exported\n     * @param matlibname defines the name of the associated mtl file\n     * @param globalposition defines if the exported positions are globals or local to the exported mesh\n     * @returns the OBJ content\n     */\n    public static OBJ(mesh: Mesh[], materials?: boolean, matlibname?: string, globalposition?: boolean): string {\n        const output: string[] = [];\n        let v = 1;\n        if (materials) {\n            if (!matlibname) {\n                matlibname = 'mat';\n            }\n            output.push(\"mtllib \" + matlibname + \".mtl\");\n        }\n        for (let j = 0; j < mesh.length; j++) {\n            output.push(\"g object\" + j);\n            output.push(\"o object_\" + j);\n\n            //Uses the position of the item in the scene, to the file (this back to normal in the end)\n            let lastMatrix: Nullable<Matrix> = null;\n            if (globalposition) {\n                var newMatrix = BABYLON.Matrix.Translation(mesh[j].position.x, mesh[j].position.y, mesh[j].position.z);\n                lastMatrix = BABYLON.Matrix.Translation(-(mesh[j].position.x), -(mesh[j].position.y), -(mesh[j].position.z));\n                mesh[j].bakeTransformIntoVertices(newMatrix);\n            }\n\n            //TODO: submeshes (groups)\n            //TODO: smoothing groups (s 1, s off);\n            if (materials) {\n                let mat = mesh[j].material;\n\n                if (mat) {\n                    output.push(\"usemtl \" + mat.id);\n                }\n            }\n            const g: Nullable<Geometry> = mesh[j].geometry;\n\n            if (!g) {\n                Tools.Warn(\"No geometry is present on the mesh\");\n                continue;\n            }\n\n            const trunkVerts = g.getVerticesData('position');\n            const trunkNormals = g.getVerticesData('normal');\n            const trunkUV = g.getVerticesData('uv');\n            const trunkFaces = g.getIndices();\n            var curV = 0;\n\n            if (!trunkVerts || !trunkFaces) {\n                Tools.Warn(\"There are no position vertices or indices on the mesh!\");\n                continue;\n            }\n\n            for (var i = 0; i < trunkVerts.length; i += 3) {\n                output.push(\"v \" + trunkVerts[i] + \" \" + trunkVerts[i + 1] + \" \" + trunkVerts[i + 2]);\n                curV++;\n            }\n\n            if (trunkNormals != null) {\n                for (i = 0; i < trunkNormals.length; i += 3) {\n                    output.push(\"vn \" + trunkNormals[i] + \" \" + trunkNormals[i + 1] + \" \" + trunkNormals[i + 2]);\n                }\n            }\n            if (trunkUV != null) {\n\n                for (i = 0; i < trunkUV.length; i += 2) {\n                    output.push(\"vt \" + trunkUV[i] + \" \" + trunkUV[i + 1]);\n                }\n            }\n\n            for (i = 0; i < trunkFaces.length; i += 3) {\n                const indices = [String(trunkFaces[i + 2] + v), String(trunkFaces[i + 1] + v), String(trunkFaces[i] + v)];\n                const blanks: string[] = [\"\", \"\", \"\"];\n\n                const facePositions = indices;\n                const faceUVs = trunkUV != null ? indices : blanks;\n                const faceNormals = trunkNormals != null ? indices : blanks;\n\n                output.push(\n                    \"f \" + facePositions[0] + \"/\" + faceUVs[0] + \"/\" + faceNormals[0] +\n                    \" \" + facePositions[1] + \"/\" + faceUVs[1] + \"/\" + faceNormals[1] +\n                    \" \" + facePositions[2] + \"/\" + faceUVs[2] + \"/\" + faceNormals[2]\n                );\n            }\n            //back de previous matrix, to not change the original mesh in the scene\n            if (globalposition && lastMatrix) {\n                mesh[j].bakeTransformIntoVertices(lastMatrix);\n            }\n            v += curV;\n        }\n        const text: string = output.join(\"\\n\");\n        return (text);\n    }\n\n    /**\n     * Exports the material(s) of a mesh in .MTL file format (text)\n     * @param mesh defines the mesh to extract the material from\n     * @returns the mtl content\n     */\n    //TODO: Export the materials of mesh array\n    public static MTL(mesh: Mesh): string {\n        var output = [];\n        var m = <StandardMaterial>mesh.material;\n        output.push(\"newmtl mat1\");\n        output.push(\"  Ns \" + m.specularPower.toFixed(4));\n        output.push(\"  Ni 1.5000\");\n        output.push(\"  d \" + m.alpha.toFixed(4));\n        output.push(\"  Tr 0.0000\");\n        output.push(\"  Tf 1.0000 1.0000 1.0000\");\n        output.push(\"  illum 2\");\n        output.push(\"  Ka \" + m.ambientColor.r.toFixed(4) + \" \" + m.ambientColor.g.toFixed(4) + \" \" + m.ambientColor.b.toFixed(4));\n        output.push(\"  Kd \" + m.diffuseColor.r.toFixed(4) + \" \" + m.diffuseColor.g.toFixed(4) + \" \" + m.diffuseColor.b.toFixed(4));\n        output.push(\"  Ks \" + m.specularColor.r.toFixed(4) + \" \" + m.specularColor.g.toFixed(4) + \" \" + m.specularColor.b.toFixed(4));\n        output.push(\"  Ke \" + m.emissiveColor.r.toFixed(4) + \" \" + m.emissiveColor.g.toFixed(4) + \" \" + m.emissiveColor.b.toFixed(4));\n\n        //TODO: uv scale, offset, wrap\n        //TODO: UV mirrored in Blender? second UV channel? lightMap? reflection textures?\n        var uvscale = \"\";\n\n        if (m.ambientTexture) {\n            output.push(\"  map_Ka \" + uvscale + m.ambientTexture.name);\n        }\n\n        if (m.diffuseTexture) {\n            output.push(\"  map_Kd \" + uvscale + m.diffuseTexture.name);\n            //TODO: alpha testing, opacity in diffuse texture alpha channel (diffuseTexture.hasAlpha -> map_d)\n        }\n\n        if (m.specularTexture) {\n            output.push(\"  map_Ks \" + uvscale + m.specularTexture.name);\n            /* TODO: glossiness = specular highlight component is in alpha channel of specularTexture. (???)\n            if (m.useGlossinessFromSpecularMapAlpha)  {\n                output.push(\"  map_Ns \"+uvscale + m.specularTexture.name);\n            }\n            */\n        }\n\n        /* TODO: emissive texture not in .MAT format (???)\n        if (m.emissiveTexture) {\n            output.push(\"  map_d \"+uvscale+m.emissiveTexture.name);\n        }\n        */\n\n        if (m.bumpTexture) {\n            output.push(\"  map_bump -imfchan z \" + uvscale + m.bumpTexture.name);\n        }\n\n        if (m.opacityTexture) {\n            output.push(\"  map_d \" + uvscale + m.opacityTexture.name);\n        }\n\n        var text = output.join(\"\\n\");\n        return (text);\n    }\n}\n","export * from \"./glTFFileExporter\";\r\nexport * from \"./2.0\";","import { IDisposable, Texture, Nullable, SubMesh } from \"babylonjs\";\r\n\r\nimport { ImageMimeType, IMeshPrimitive } from \"babylonjs-gltf2interface\";\r\n\r\nimport { _BinaryWriter } from \"./glTFExporter\";\r\nimport { IGLTFExporterExtension } from \"../glTFFileExporter\";\r\n\r\n/** @hidden */\r\nexport var __IGLTFExporterExtensionV2 = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for a glTF exporter extension\r\n * @hidden\r\n */\r\nexport interface IGLTFExporterExtensionV2 extends IGLTFExporterExtension, IDisposable {\r\n    /**\r\n     * Define this method to modify the default behavior before exporting a texture\r\n     * @param context The context when loading the asset\r\n     * @param babylonTexture The glTF texture info property\r\n     * @param mimeType The mime-type of the generated image\r\n     * @returns A promise that resolves with the exported glTF texture info when the export is complete, or null if not handled\r\n     */\r\n    preExportTextureAsync?(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Nullable<Promise<Texture>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when exporting texture info\r\n     * @param context The context when loading the asset\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param babylonSubMesh Babylon submesh\r\n     * @param binaryWriter glTF serializer binary writer instance\r\n     */\r\n    postExportMeshPrimitiveAsync?(context: string, meshPrimitive: IMeshPrimitive, babylonSubMesh: SubMesh, binaryWriter: _BinaryWriter): Nullable<Promise<IMeshPrimitive>>;\r\n}","import { Texture, Nullable, Vector2, Scene, BaseTexture, ProceduralTexture, Tools } from \"babylonjs\";\r\nimport { ImageMimeType } from \"babylonjs-gltf2interface\";\r\nimport { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\nimport \"../shaders/textureTransform.fragment\";\r\n\r\n/**\r\n * Interface for handling KHR texture transform\r\n * @hidden\r\n */\r\ninterface IKHRTextureTransform {\r\n    offset?: number[];\r\n    rotation?: number;\r\n    scale?: number[];\r\n    texCoord?: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class KHR_texture_transform implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _exporter: _Exporter;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {\r\n        delete this._exporter;\r\n    }\r\n\r\n    public preExportTextureAsync(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Nullable<Promise<Texture>> {\r\n        return new Promise((resolve, reject) => {\r\n            const texture_transform_extension: IKHRTextureTransform = {};\r\n\r\n            if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {\r\n                texture_transform_extension.offset = [babylonTexture.uOffset, babylonTexture.vOffset];\r\n            }\r\n\r\n            if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {\r\n                texture_transform_extension.scale = [babylonTexture.uScale, babylonTexture.vScale];\r\n            }\r\n\r\n            if (babylonTexture.wAng !== 0) {\r\n                texture_transform_extension.rotation = babylonTexture.wAng;\r\n            }\r\n\r\n            if (!Object.keys(texture_transform_extension).length) {\r\n                resolve(babylonTexture);\r\n            }\r\n\r\n            const scale = texture_transform_extension.scale ? new Vector2(texture_transform_extension.scale[0], texture_transform_extension.scale[1]) : Vector2.One();\r\n            const rotation = texture_transform_extension.rotation != null ? texture_transform_extension.rotation : 0;\r\n            const offset = texture_transform_extension.offset ? new Vector2(texture_transform_extension.offset[0], texture_transform_extension.offset[1]) : Vector2.Zero();\r\n            const scene = babylonTexture.getScene();\r\n            if (!scene) {\r\n                reject(`${context}: \"scene\" is not defined for Babylon texture ${babylonTexture.name}!`);\r\n            }\r\n            else {\r\n                this.textureTransformTextureAsync(babylonTexture, offset, rotation, scale, scene).then((texture) => {\r\n                    resolve(texture as Texture);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Transform the babylon texture by the offset, rotation and scale parameters using a procedural texture\r\n     * @param babylonTexture\r\n     * @param offset\r\n     * @param rotation\r\n     * @param scale\r\n     * @param scene\r\n     */\r\n    public textureTransformTextureAsync(babylonTexture: Texture, offset: Vector2, rotation: number, scale: Vector2, scene: Scene): Promise<BaseTexture> {\r\n        return new Promise((resolve, reject) => {\r\n            const proceduralTexture = new ProceduralTexture(`${babylonTexture.name}`, babylonTexture.getSize(), \"textureTransform\", scene);\r\n            if (!proceduralTexture) {\r\n                Tools.Log(`Cannot create procedural texture for ${babylonTexture.name}!`);\r\n                resolve(babylonTexture);\r\n            }\r\n\r\n            proceduralTexture.setTexture(\"textureSampler\", babylonTexture);\r\n            proceduralTexture.setMatrix(\"textureTransformMat\", babylonTexture.getTextureMatrix());\r\n\r\n            // isReady trigger creation of effect if it doesnt exist yet\r\n            if (proceduralTexture.isReady()) {\r\n                proceduralTexture.render();\r\n                resolve(proceduralTexture);\r\n            } else {\r\n                (proceduralTexture as any).getEffect().executeWhenCompiled(() => {\r\n                    proceduralTexture.render();\r\n                    resolve(proceduralTexture);\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_texture_transform(exporter));","import { Effect } from \"babylonjs\";\n\nlet name = 'textureTransformPixelShader';\nlet shader = `precision highp float;\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform mat4 textureTransformMat;\nvoid main(void) {\nvec2 uvTransformed=(textureTransformMat*vec4(vUV.xy,1,1)).xy;\ngl_FragColor=texture2D(textureSampler,uvTransformed);\n}`;\n\nEffect.ShadersStore[name] = shader;\n\nexport { shader, name };\n","import * as Exporters from \"../src/glTF/glTFFileExporter\";\r\nimport * as Datas from \"../src/glTF/2.0/glTFData\";\r\nimport * as Serializers from \"../src/glTF/2.0/glTFSerializer\";\r\nimport * as Extensions from \"../src/glTF/2.0/Extensions\";\r\nimport * as GLTF2 from \"../src/glTF/2.0\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    (<any>globalObject).BABYLON = (<any>globalObject).BABYLON || {};\r\n    var BABYLON = (<any>globalObject).BABYLON;\r\n    BABYLON.GLTF2 = BABYLON.GLTF2 || {};\r\n    BABYLON.GLTF2.Exporter = BABYLON.GLTF2.Exporter || {};\r\n    BABYLON.GLTF2.Exporter.Extensions = BABYLON.GLTF2.Exporter.Extensions || {};\r\n\r\n    const keys = [];\r\n    for (var key in Exporters) {\r\n        BABYLON[key] = (<any>Exporters)[key];\r\n        keys.push(key);\r\n    }\r\n    for (var key in Datas) {\r\n        BABYLON[key] = (<any>Datas)[key];\r\n        keys.push(key);\r\n    }\r\n    for (var key in Serializers) {\r\n        BABYLON[key] = (<any>Serializers)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (var key in Extensions) {\r\n        BABYLON.GLTF2.Exporter.Extensions[key] = (<any>Extensions)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (var key in GLTF2) {\r\n        // Prevent Reassignment.\r\n        if (keys.indexOf(key) > -1) {\r\n            continue;\r\n        }\r\n\r\n        BABYLON.GLTF2.Exporter[key] = (<any>GLTF2)[key];\r\n    }\r\n}\r\n\r\nexport * from \"../src/glTF/glTFFileExporter\";\r\nexport * from \"../src/glTF/2.0\";","import * as Serializers from \"../src/OBJ\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    for (var serializer in Serializers) {\r\n        (<any>globalObject).BABYLON[serializer] = (<any>Serializers)[serializer];\r\n    }\r\n}\r\n\r\nexport * from \"../src/OBJ\";"],"sourceRoot":""}