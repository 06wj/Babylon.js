{"version":3,"sources":["webpack://SERIALIZERS/webpack/universalModuleDefinition","webpack://SERIALIZERS/webpack/bootstrap","webpack://SERIALIZERS/external {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFUtilities.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFExporter.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFAnimation.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFData.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFMaterialExporter.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/legacy.ts","webpack://SERIALIZERS/../node_modules/webpack/buildin/global.js","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/OBJ/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/OBJ/objSerializer.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/glTFFileExporter.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFExporterExtension.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFSerializer.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/Extensions/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/Extensions/KHR_texture_transform.ts","webpack://SERIALIZERS/./src/glTF/2.0/shaders/textureTransform.fragment.fx"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","babylonjs_1","_GLTFUtilities","_CreateBufferView","bufferIndex","byteOffset","byteLength","byteStride","bufferview","buffer","_CreateAccessor","bufferviewIndex","type","componentType","count","min","max","accessor","bufferView","_CalculateMinMaxPositions","positions","vertexStart","vertexCount","convertToRightHandedSystem","indexOffset","position","vector","Infinity","length_1","Vector3","FromArray","_GetRightHandedPositionVector3FromRef","asArray","j","num","_GetRightHandedPositionVector3","x","y","z","_GetRightHandedPositionArray3FromRef","_GetRightHandedNormalVector3","_GetRightHandedNormalVector3FromRef","_GetRightHandedNormalArray3FromRef","_GetRightHandedVector4FromRef","w","_GetRightHandedArray4FromRef","_GetRightHandedQuaternionFromRef","quaternion","_GetRightHandedQuaternionArrayFromRef","_NormalizeTangentFromRef","tangent","length","Math","sqrt","glTFMaterialExporter_1","glTFUtilities_1","glTFData_1","glTFAnimation_1","_Exporter","babylonScene","options","this","_extensions","_asset","generator","version","_extensionsUsed","_extensionsRequired","_babylonScene","_bufferViews","_accessors","_meshes","_scenes","_nodes","_images","_materials","_materialMap","_textures","_samplers","_animations","_imageData","_convertToRightHandedSystem","useRightHandedSystem","_options","_shouldExportTransformNode","shouldExportTransformNode","babylonTransformNode","_animationSampleRate","animationSampleRate","_glTFMaterialExporter","_GLTFMaterialExporter","_loadExtensions","_applyExtensions","actionAsync","_i","_a","_ExtensionNames","name_1","extension","enabled","exporterProperty","_activeLoaderExtensions","activeLoaderExtensions","result","_extensionsPreExportTextureAsync","context","babylonTexture","mimeType","preExportTextureAsync","_extensionsPostExportMeshPrimitiveAsync","meshPrimitive","babylonSubMesh","binaryWriter","postExportMeshPrimitiveAsync","name_2","_ExtensionFactories","RegisterExtension","UnregisterExtension","Tools","Warn","push","index","indexOf","splice","_getLocalEngine","_localEngine","localCanvas","document","createElement","id","width","height","Engine","premultipliedAlpha","preserveDrawingBuffer","setViewport","Viewport","reorderIndicesBasedOnPrimitiveMode","submesh","primitiveMode","babylonIndices","Material","TriangleFillMode","indexStart","indexCount","secondIndex","getUInt32","thirdIndex","setUInt32","TriangleFanDrawMode","start","TriangleStripDrawMode","reorderVertexAttributeDataBasedOnPrimitiveMode","sideOrientation","vertexBufferKind","meshAttributeArray","ClockWiseSideOrientation","reorderTriangleFillMode","reorderTriangleStripDrawMode","reorderTriangleFanMode","vertexBuffer","getVertexBufferFromMesh","getMesh","stride","VertexBuffer","GetTypeByteLength","verticesCount","Error","vertexData","PositionKind","NormalKind","verticesStart","TangentKind","Vector4","ColorKind","size","getSize","UVKind","UV2Kind","Vector2","writeVertexAttributeData","vertices","vertexAttributeKind","vertices_1","vertex","normalize","_b","component","setFloat32","writeAttributeData","vertexAttributes","k","length_2","length_3","length_4","length_5","length_6","vertexAttributes_1","vertexAttribute_1","generateJSON","shouldUseGlb","glTFPrefix","prettyPrint","imageName","imageData","_this","_totalByteLength","glTF","asset","extensionsUsed","extensionsRequired","buffers","nodes","meshes","scenes","scene","bufferViews","accessors","animations","materials","textures","samplers","images","forEach","image","uri","split","data","undefined","JSON","stringify","_generateGLTFAsync","_generateBinaryAsync","then","binaryBuffer","jsonText","bin","Blob","glTFFileName","glTFBinFile","container","GLTFData","glTFFiles","_BinaryWriter","createSceneAsync","dispose","getArrayBuffer","_getPadding","remainder","_generateGLBAsync","glbFileName","jsonLength","imageByteLength","jsonPadding","binPadding","imagePadding","headerLength","headerBuffer","ArrayBuffer","headerBufferView","DataView","setUint32","jsonChunkBuffer","jsonChunkBufferView","jsonData","Uint8Array","charCodeAt","jsonPaddingView","binaryChunkBuffer","binaryChunkBufferView","binPaddingBuffer","binPaddingView","imagePaddingBuffer","imagePaddingView","glbData","glbFile","setNodeTransformation","node","getPivotPoint","equalsToFloats","BABYLON","translation","scaling","scale","rotationQuaternion","Quaternion","RotationYawPitchRoll","rotation","multiplyInPlace","attributeKind","bufferMesh","isVerticesDataPresent","getVertexBuffer","createBufferViewKind","kind","Mesh","InstancedMesh","sourceMesh","getVerticesData","getByteOffset","getMeshPrimitiveMode","babylonMesh","LinesMesh","LineListDrawMode","material","fillMode","setPrimitiveMode","PointListDrawMode","PointFillMode","LineLoopDrawMode","LineStripDrawMode","setAttributeKind","attributes","POSITION","NORMAL","COLOR_0","TANGENT","TEXCOORD_0","TEXCOORD_1","setPrimitiveAttributesAsync","mesh","uvCoordsPresent","minMax","promises","attributeData","accessorType","indexBufferViewIndex","vertexAttributeBufferViews","attributeData_1","attribute","DeduceStride","bufferViewIndex","getTotalIndices","indices","getIndices","length_7","subMeshes","babylonMaterial","getMaterial","getScene","defaultMaterial","materialIndex","color","equals","Color3","White","alpha","pbrMetallicRoughness","baseColorFactor","concat","MultiMaterial","subMaterial","subMaterials","uniqueId","glTFMaterial","_c","attributeData_2","_hasTexturesPresent","keys","_d","attributeData_3","byteOffset_1","newMat","_stripTexturesFromMaterial","primitives","Promise","all","glTFNodeIndex","glTFNode","directDescendents","transformNodes","_convertMaterialsToGLTFAsync","createNodeMapAndAnimationsAsync","nodeMap","_nodeMap","nodes_1","parent","multiply","Log","getDescendants","children","directDescendents_1","descendent","nodeIndex","promiseChain","resolve","runtimeGLTFAnimation","channels","idleGLTFAnimations","createNodeAsync","TransformNode","animationGroups","_GLTFAnimation","_CreateNodeAnimationFromTransformNodeAnimations","nodes_2","idleGLTFAnimation","_CreateNodeAnimationFromAnimationGroups","Array","_arrayBuffer","_dataView","_byteOffset","resizeBuffer","newBuffer","oldUint8Array","newUint8Array","length_8","setUInt8","entry","setUint8","getUint32","getVector3Float32FromRef","vector3","getFloat32","setVector3Float32FromRef","getVector4Float32FromRef","vector4","setVector4Float32FromRef","isNaN","__export","_TangentType","_CreateNodeAnimation","animation","animationChannelTargetPath","useQuaternion","inputs","outputs","keyFrames","getKeys","minMaxKeyFrames","calculateMinMaxKeyFrames","interpolationOrBake","_DeduceInterpolation","frameDelta","interpolation","interpolationType","shouldBakeAnimation","_CreateBakedAnimation","framePerSecond","_CreateLinearOrStepAnimation","_CreateCubicSplineAnimation","samplerInterpolation","inputsMin","FloatRound","inputsMax","_DeduceAnimationInfo","dataAccessorType","targetProperty","glTFAnimation","animationInfo","AddAnimation","hasRunningRuntimeAnimations","glTFAnimations","animationGroups_1","animationGroup","targetedAnimations","targetAnimation","target","keyframeAccessorIndex","dataAccessorIndex","outputLength","animationSampler","animationChannel","animationData","input","output","sampler","path","minFrame","maxFrame","fps","sampleRate","minMaxFrames","time","quaternionCache","Identity","previousTime","maxUsedFrame","currKeyFrame","nextKeyFrame","prevKeyFrame","endFrame","frame","f","_interpolate","loopMode","_SetInterpolatedValue","_ConvertFactorToVector3OrQuaternion","factor","animationType","componentName","basePositionRotationOrScale","_GetBasePositionRotationOrScale","Animation","ANIMATIONTYPE_FLOAT","cacheValue","dataType","RotationYawPitchRollToRef","keyFrame","_AddKeyframeValue","AddSplineTangent","INTANGENT","OUTTANGENT","newPositionRotationOrScale","ANIMATIONTYPE_VECTOR3","array","posRotScale","ANIMATIONTYPE_QUATERNION","inTangent","outTangent","AnimationKeyInterpolation","STEP","tangentType","tangentValue","downloadFiles","endsWith","str","suffix","link","body","appendChild","setAttribute","download","blob","href","URL","createObjectURL","click","exporter","_textureMap","_exporter","FuzzyEquals","color1","color2","epsilon","Scalar","WithinEpsilon","g","b","babylonMaterials","hasTextureCoords","babylonMaterials_1","StandardMaterial","_convertStandardMaterialAsync","PBRMetallicRoughnessMaterial","_convertPBRMetallicRoughnessMaterialAsync","PBRMaterial","_convertPBRMaterialAsync","originalMaterial","newMaterial","doubleSided","alphaMode","alphaCutoff","emissiveFactor","originalPBRMetallicRoughness","metallicFactor","roughnessFactor","emissiveTexture","normalTexture","occlusionTexture","pbrMat","baseColorTexture","metallicRoughnessTexture","_convertToGLTFPBRMetallicRoughness","babylonStandardMaterial","P0","P1","P2","P3","diffuse","diffuseColor","toLinearSpace","opacity","roughness","specularPower","p0","p1","p2","p3","_cubicBezierCurve","pow","_solveForRoughness","Clamp","_MaxSpecularPower","_SolveMetallic","specular","oneMinusSpecularStrength","_DielectricSpecular","a","D","_getAlphaMode","needAlphaBlending","needAlphaTesting","materialMap","glTFPbrMetallicRoughness","backFaceCulling","twoSidedLighting","diffuseTexture","_exportTextureAsync","glTFTexture","bumpTexture","level","glTFEmissiveTexture","ambientTexture","strength","opacityTexture","ALPHA_COMBINE","toString","emissiveColor","Black","_Epsilon","alphaCutOff","babylonPBRMetalRoughMaterial","baseColor","metallic","transparencyMode","baseTexture","occlusionStrength","_createBase64FromCanvasAsync","reject","hostingScene","textureType","TEXTURETYPE_UNSIGNED_INT","engine","Scene","tempTexture","createRawTexture","TEXTUREFORMAT_RGBA","Texture","NEAREST_SAMPLINGMODE","postProcess","PostProcess","getEffect","executeWhenCompiled","onApply","effect","_bindTexture","setSize","postProcessManager","directRender","canvas","getRenderingCanvas","toBlob","ToBlob","fileReader","FileReader","onload","event","base64String","readAsDataURL","dataURL","toDataURL","_createWhiteTexture","RawTexture","CreateRGBATexture","_resizeTexturesToSameDimensions","texture1","texture2","resizedTexture1","resizedTexture2","texture1Size","texture2Size","TextureTools","CreateResizedCopy","_convertPixelArrayToFloat32","pixels","Float32Array","_convertSpecularGlossinessTexturesToMetallicRoughnessAsync","specularGlossinessTexture","factors","resizedTextures","diffuseSize","diffuseBuffer","specularGlossinessBuffer","diffusePixels","readPixels","specularPixels","metallicRoughnessBuffer","baseColorBuffer","maxBaseColor","maxMetallic","maxRoughness","h","offset","specularGlossiness","specularColor","glossiness","metallicRoughness","_convertSpecularGlossinessToMetallicRoughness","hasAlpha","metallicRoughnessFactors_1","writeOutMetallicRoughnessTexture","writeOutBaseColorTexture","destinationOffset","sRGBBaseColorPixel","FromInts","toGammaSpace","metallicRoughnessPixel","promise","metallicRoughnessBase64","metallicRoughnessTextureBase64","baseColorBase64","baseColorTextureBase64","diffusePerceivedBrightness","_getPerceivedBrightness","specularPerceivedBrightness","_getMaxComponent","baseColorFromDiffuse","baseColorFromSpecular","subtract","Lerp","clampToRef","_convertMetalRoughFactorsToMetallicRoughnessAsync","babylonPBRMaterial","albedoColor","albedoTexture","metallicTexture","_getGLTFTextureSampler","texture","_getGLTFTextureWrapModesSampler","samplingMode","LINEAR_LINEAR","magFilter","minFilter","LINEAR_NEAREST","NEAREST_LINEAR","NEAREST_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","NEAREST_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","LINEAR_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPNEAREST","_getGLTFTextureWrapMode","wrapMode","WRAP_ADDRESSMODE","CLAMP_ADDRESSMODE","MIRROR_ADDRESSMODE","wrapS","wrapU","wrapT","wrapV","_convertSpecGlossFactorsToMetallicRoughnessAsync","specGloss","reflectivityColor","microSurface","samplerIndex","reflectivityTexture","useMicroSurfaceFromReflectivityMapAlpha","metallicRoughnessFactors","glTFBaseColorTexture","_getTextureInfoFromBase64","coordinatesIndex","glTFMRColorTexture","isMetallicWorkflow","setMetallicRoughnessPbrMaterial","ambientTextureStrength","getPixelsFromTexture","extensionPromise","_exportTextureInfoAsync","textureUid","uid","samplerIndex_1","foundSamplerIndex","base64Data","textureInfo","replace","base64Texture","baseTextureName","texCoordIndex","source","binStr","atob","arrBuff","arr","imageValues","textureName","RandomId","glTFImage","foundIndex","texCoord","Serializers","globalObject","global","serializer","Function","eval","e","OBJExport","OBJ","matlibname","globalposition","v","lastMatrix","newMatrix","Matrix","Translation","bakeTransformIntoVertices","mat","geometry","trunkVerts","trunkNormals","trunkUV","trunkFaces","curV","String","blanks","facePositions","faceUVs","faceNormals","join","MTL","toFixed","ambientColor","specularTexture","__IGLTFExporterExtension","__IGLTFExporterExtensionV2","glTFExporter_1","GLTF2Export","GLTFAsync","filePrefix","whenReadyAsync","_PreExportAsync","exportWithoutWaitingForScene","_PostExportAsync","glTFData","GLBAsync","NAME","Effect","ShadersStore","KHR_texture_transform","required","texture_transform_extension","uOffset","vOffset","uScale","vScale","wAng","One","Zero","textureTransformTextureAsync","proceduralTexture","ProceduralTexture","setTexture","setMatrix","getTextureMatrix","isReady","render"],"mappings":"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","file":"babylonjs.serializers.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-serializers\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-serializers\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"SERIALIZERS\"] = factory(root[\"BABYLON\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import { Nullable, FloatArray, Vector3, Vector4, Quaternion } from \"babylonjs\";\r\nimport { IBufferView, AccessorType, AccessorComponentType, IAccessor } from \"babylonjs-gltf2interface\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class _GLTFUtilities {\r\n    /**\r\n     * Creates a buffer view based on the supplied arguments\r\n     * @param bufferIndex index value of the specified buffer\r\n     * @param byteOffset byte offset value\r\n     * @param byteLength byte length of the bufferView\r\n     * @param byteStride byte distance between conequential elements\r\n     * @param name name of the buffer view\r\n     * @returns bufferView for glTF\r\n     */\r\n    public static _CreateBufferView(bufferIndex: number, byteOffset: number, byteLength: number, byteStride?: number, name?: string): IBufferView {\r\n        let bufferview: IBufferView = { buffer: bufferIndex, byteLength: byteLength };\r\n        if (byteOffset) {\r\n            bufferview.byteOffset = byteOffset;\r\n        }\r\n        if (name) {\r\n            bufferview.name = name;\r\n        }\r\n        if (byteStride) {\r\n            bufferview.byteStride = byteStride;\r\n        }\r\n\r\n        return bufferview;\r\n    }\r\n\r\n    /**\r\n     * Creates an accessor based on the supplied arguments\r\n     * @param bufferviewIndex The index of the bufferview referenced by this accessor\r\n     * @param name The name of the accessor\r\n     * @param type The type of the accessor\r\n     * @param componentType The datatype of components in the attribute\r\n     * @param count The number of attributes referenced by this accessor\r\n     * @param byteOffset The offset relative to the start of the bufferView in bytes\r\n     * @param min Minimum value of each component in this attribute\r\n     * @param max Maximum value of each component in this attribute\r\n     * @returns accessor for glTF\r\n     */\r\n    public static _CreateAccessor(bufferviewIndex: number, name: string, type: AccessorType, componentType: AccessorComponentType, count: number, byteOffset: Nullable<number>, min: Nullable<number[]>, max: Nullable<number[]>): IAccessor {\r\n        let accessor: IAccessor = { name: name, bufferView: bufferviewIndex, componentType: componentType, count: count, type: type };\r\n\r\n        if (min != null) {\r\n            accessor.min = min;\r\n        }\r\n        if (max != null) {\r\n            accessor.max = max;\r\n        }\r\n        if (byteOffset != null) {\r\n            accessor.byteOffset = byteOffset;\r\n        }\r\n\r\n        return accessor;\r\n    }\r\n\r\n    /**\r\n     * Calculates the minimum and maximum values of an array of position floats\r\n     * @param positions Positions array of a mesh\r\n     * @param vertexStart Starting vertex offset to calculate min and max values\r\n     * @param vertexCount Number of vertices to check for min and max values\r\n     * @returns min number array and max number array\r\n     */\r\n    public static _CalculateMinMaxPositions(positions: FloatArray, vertexStart: number, vertexCount: number, convertToRightHandedSystem: boolean): { min: number[], max: number[] } {\r\n        const min = [Infinity, Infinity, Infinity];\r\n        const max = [-Infinity, -Infinity, -Infinity];\r\n        const positionStrideSize = 3;\r\n        let indexOffset: number;\r\n        let position: Vector3;\r\n        let vector: number[];\r\n\r\n        if (vertexCount) {\r\n            for (let i = vertexStart, length = vertexStart + vertexCount; i < length; ++i) {\r\n                indexOffset = positionStrideSize * i;\r\n\r\n                position = Vector3.FromArray(positions, indexOffset);\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(position);\r\n                }\r\n                vector = position.asArray();\r\n\r\n                for (let j = 0; j < positionStrideSize; ++j) {\r\n                    let num = vector[j];\r\n                    if (num < min[j]) {\r\n                        min[j] = num;\r\n                    }\r\n                    if (num > max[j]) {\r\n                        max[j] = num;\r\n                    }\r\n                    ++indexOffset;\r\n                }\r\n            }\r\n        }\r\n        return { min, max };\r\n    }\r\n\r\n    /**\r\n     * Converts a new right-handed Vector3\r\n     * @param vector vector3 array\r\n     * @returns right-handed Vector3\r\n     */\r\n    public static _GetRightHandedPositionVector3(vector: Vector3): Vector3 {\r\n        return new Vector3(vector.x, vector.y, -vector.z);\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector3 to right-handed\r\n     * @param vector Vector3 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedPositionVector3FromRef(vector: Vector3) {\r\n        vector.z *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a three element number array to right-handed\r\n     * @param vector number array to convert to right-handed\r\n     */\r\n    public static _GetRightHandedPositionArray3FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a new right-handed Vector3\r\n     * @param vector vector3 array\r\n     * @returns right-handed Vector3\r\n     */\r\n    public static _GetRightHandedNormalVector3(vector: Vector3): Vector3 {\r\n        return new Vector3(vector.x, vector.y, -vector.z);\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector3 to right-handed\r\n     * @param vector Vector3 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedNormalVector3FromRef(vector: Vector3) {\r\n        vector.z *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a three element number array to right-handed\r\n     * @param vector number array to convert to right-handed\r\n     */\r\n    public static _GetRightHandedNormalArray3FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector4 to right-handed\r\n     * @param vector Vector4 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedVector4FromRef(vector: Vector4) {\r\n        vector.z *= -1;\r\n        vector.w *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector4 to right-handed\r\n     * @param vector Vector4 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedArray4FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n        vector[3] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Quaternion to right-handed\r\n     * @param quaternion Source quaternion to convert to right-handed\r\n     */\r\n    public static _GetRightHandedQuaternionFromRef(quaternion: Quaternion) {\r\n        quaternion.x *= -1;\r\n        quaternion.y *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Quaternion to right-handed\r\n     * @param quaternion Source quaternion to convert to right-handed\r\n     */\r\n    public static _GetRightHandedQuaternionArrayFromRef(quaternion: number[]) {\r\n        quaternion[0] *= -1;\r\n        quaternion[1] *= -1;\r\n    }\r\n\r\n    public static _NormalizeTangentFromRef(tangent: Vector4) {\r\n        const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);\r\n        if (length > 0) {\r\n            tangent.x /= length;\r\n            tangent.y /= length;\r\n            tangent.z /= length;\r\n        }\r\n    }\r\n}","import { Scene, TransformNode, Node, Engine, Nullable, Texture, BaseTexture, SubMesh, Tools, Viewport, IndicesArray, Material, FloatArray, Mesh, VertexBuffer, Vector2, Vector3, Vector4, Quaternion, InstancedMesh, AbstractMesh, LinesMesh, Color3, MultiMaterial } from \"babylonjs\";\r\nimport { AccessorType, IBufferView, IAccessor, INode, IAsset, IScene, IMesh, IMaterial, ITexture, IImage, ISampler, IAnimation, ImageMimeType, IMeshPrimitive, IBuffer, IGLTF, MeshPrimitiveMode, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\n\r\nimport { IGLTFExporterExtensionV2 } from \"./glTFExporterExtension\";\r\nimport { _GLTFMaterialExporter } from \"./glTFMaterialExporter\";\r\nimport { IExportOptions } from \"./glTFSerializer\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _GLTFAnimation } from \"./glTFAnimation\";\r\n\r\n/**\r\n * Utility interface for storing vertex attribute data\r\n * @hidden\r\n */\r\ninterface _IVertexAttributeData {\r\n    /**\r\n     * Specifies the Babylon Vertex Buffer Type (Position, Normal, Color, etc.)\r\n    */\r\n    kind: string;\r\n\r\n    /**\r\n     * Specifies the glTF Accessor Type (VEC2, VEC3, etc.)\r\n    */\r\n    accessorType: AccessorType;\r\n\r\n    /**\r\n     * Specifies the BufferView index for the vertex attribute data\r\n    */\r\n    bufferViewIndex?: number;\r\n\r\n    byteStride?: number;\r\n}\r\n/**\r\n * Converts Babylon Scene into glTF 2.0.\r\n * @hidden\r\n */\r\nexport class _Exporter {\r\n    /**\r\n     * Stores all generated buffer views, which represents views into the main glTF buffer data\r\n     */\r\n    public _bufferViews: IBufferView[];\r\n    /**\r\n     * Stores all the generated accessors, which is used for accessing the data within the buffer views in glTF\r\n     */\r\n    public _accessors: IAccessor[];\r\n    /**\r\n     * Stores all the generated nodes, which contains transform and/or mesh information per node\r\n     */\r\n    private _nodes: INode[];\r\n    /**\r\n     * Stores the glTF asset information, which represents the glTF version and this file generator\r\n     */\r\n    private _asset: IAsset;\r\n    /**\r\n     * Stores all the generated glTF scenes, which stores multiple node hierarchies\r\n     */\r\n    private _scenes: IScene[];\r\n    /**\r\n     * Stores all the generated mesh information, each containing a set of primitives to render in glTF\r\n     */\r\n    private _meshes: IMesh[];\r\n    /**\r\n     * Stores all the generated material information, which represents the appearance of each primitive\r\n     */\r\n    public _materials: IMaterial[];\r\n\r\n    public _materialMap: { [materialID: number]: number };\r\n    /**\r\n     * Stores all the generated texture information, which is referenced by glTF materials\r\n     */\r\n    public _textures: ITexture[];\r\n    /**\r\n     * Stores all the generated image information, which is referenced by glTF textures\r\n     */\r\n    public _images: IImage[];\r\n\r\n    /**\r\n     * Stores all the texture samplers\r\n     */\r\n    public _samplers: ISampler[];\r\n    /**\r\n     * Stores all the generated animation samplers, which is referenced by glTF animations\r\n     */\r\n    /**\r\n     * Stores the animations for glTF models\r\n     */\r\n    private _animations: IAnimation[];\r\n    /**\r\n     * Stores the total amount of bytes stored in the glTF buffer\r\n     */\r\n    private _totalByteLength: number;\r\n    /**\r\n     * Stores a reference to the Babylon scene containing the source geometry and material information\r\n     */\r\n    private _babylonScene: Scene;\r\n    /**\r\n     * Stores a map of the image data, where the key is the file name and the value\r\n     * is the image data\r\n     */\r\n    public _imageData: { [fileName: string]: { data: Uint8Array, mimeType: ImageMimeType } };\r\n\r\n    /**\r\n     * Stores a map of the unique id of a node to its index in the node array\r\n     */\r\n    private _nodeMap: { [key: number]: number };\r\n\r\n    /**\r\n     * Specifies if the Babylon scene should be converted to right-handed on export\r\n     */\r\n    private _convertToRightHandedSystem: boolean;\r\n\r\n    /**\r\n     * Baked animation sample rate\r\n     */\r\n    private _animationSampleRate: number;\r\n\r\n    /**\r\n     * Callback which specifies if a transform node should be exported or not\r\n     */\r\n    private _shouldExportTransformNode: ((babylonTransformNode: TransformNode) => boolean);\r\n\r\n    private _localEngine: Engine;\r\n\r\n    public _glTFMaterialExporter: _GLTFMaterialExporter;\r\n\r\n    private _extensions: { [name: string]: IGLTFExporterExtensionV2 } = {};\r\n\r\n    private _extensionsUsed: string[];\r\n    private _extensionsRequired: string[];\r\n\r\n    private static _ExtensionNames = new Array<string>();\r\n    private static _ExtensionFactories: { [name: string]: (exporter: _Exporter) => IGLTFExporterExtensionV2 } = {};\r\n\r\n    private _applyExtensions<T>(property: any, actionAsync: (extension: IGLTFExporterExtensionV2) => Nullable<T> | undefined): Nullable<T> {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                const exporterProperty = property as any;\r\n                exporterProperty._activeLoaderExtensions = exporterProperty._activeLoaderExtensions || {};\r\n                const activeLoaderExtensions = exporterProperty._activeLoaderExtensions;\r\n                if (!activeLoaderExtensions[name]) {\r\n                    activeLoaderExtensions[name] = true;\r\n\r\n                    try {\r\n                        const result = actionAsync(extension);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    }\r\n                    finally {\r\n                        delete activeLoaderExtensions[name];\r\n                        delete exporterProperty._activeLoaderExtensions;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    public _extensionsPreExportTextureAsync(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(babylonTexture, (extension) => extension.preExportTextureAsync && extension.preExportTextureAsync(context, babylonTexture, mimeType));\r\n    }\r\n\r\n    public _extensionsPostExportMeshPrimitiveAsync(context: string, meshPrimitive: IMeshPrimitive, babylonSubMesh: SubMesh, binaryWriter: _BinaryWriter): Nullable<Promise<IMeshPrimitive>> {\r\n        return this._applyExtensions(meshPrimitive, (extension) => extension.postExportMeshPrimitiveAsync && extension.postExportMeshPrimitiveAsync(context, meshPrimitive, babylonSubMesh, binaryWriter));\r\n    }\r\n\r\n    /**\r\n     * Load glTF serializer extensions\r\n     */\r\n    private _loadExtensions(): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = _Exporter._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF Exporter instance, which can accept optional exporter options\r\n     * @param babylonScene Babylon scene object\r\n     * @param options Options to modify the behavior of the exporter\r\n     */\r\n    public constructor(babylonScene: Scene, options?: IExportOptions) {\r\n        this._asset = { generator: \"BabylonJS\", version: \"2.0\" };\r\n        this._extensionsUsed = [];\r\n        this._extensionsRequired = [];\r\n        this._babylonScene = babylonScene;\r\n        this._bufferViews = [];\r\n        this._accessors = [];\r\n        this._meshes = [];\r\n        this._scenes = [];\r\n        this._nodes = [];\r\n        this._images = [];\r\n        this._materials = [];\r\n        this._materialMap = [];\r\n        this._textures = [];\r\n        this._samplers = [];\r\n        this._animations = [];\r\n        this._imageData = {};\r\n        this._convertToRightHandedSystem = this._babylonScene.useRightHandedSystem ? false : true;\r\n        const _options = options || {};\r\n        this._shouldExportTransformNode = _options.shouldExportTransformNode ? _options.shouldExportTransformNode : (babylonTransformNode: TransformNode) => true;\r\n        this._animationSampleRate = _options.animationSampleRate ? _options.animationSampleRate : 1 / 60;\r\n\r\n        this._glTFMaterialExporter = new _GLTFMaterialExporter(this);\r\n        this._loadExtensions();\r\n    }\r\n\r\n    /**\r\n     * Registers a glTF exporter extension\r\n     * @param name Name of the extension to export\r\n     * @param factory The factory function that creates the exporter extension\r\n     */\r\n    public static RegisterExtension(name: string, factory: (exporter: _Exporter) => IGLTFExporterExtensionV2): void {\r\n        if (_Exporter.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name ${name} already exists`);\r\n        }\r\n\r\n        _Exporter._ExtensionFactories[name] = factory;\r\n        _Exporter._ExtensionNames.push(name);\r\n    }\r\n\r\n    /**\r\n     * Un-registers an exporter extension\r\n     * @param name The name fo the exporter extension\r\n     * @returns A boolean indicating whether the extension has been un-registered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!_Exporter._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n        delete _Exporter._ExtensionFactories[name];\r\n\r\n        const index = _Exporter._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            _Exporter._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Lazy load a local engine with premultiplied alpha set to false\r\n     */\r\n    public _getLocalEngine(): Engine {\r\n        if (!this._localEngine) {\r\n            const localCanvas = document.createElement('canvas');\r\n            localCanvas.id = \"WriteCanvas\";\r\n            localCanvas.width = 2048;\r\n            localCanvas.height = 2048;\r\n            this._localEngine = new Engine(localCanvas, true, { premultipliedAlpha: false, preserveDrawingBuffer: true });\r\n            this._localEngine.setViewport(new Viewport(0, 0, 1, 1));\r\n        }\r\n\r\n        return this._localEngine;\r\n    }\r\n\r\n    private reorderIndicesBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, babylonIndices: IndicesArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                if (!byteOffset) { byteOffset = 0; }\r\n                for (let i = submesh.indexStart, length = submesh.indexStart + submesh.indexCount; i < length; i = i + 3) {\r\n                    const index = byteOffset + i * 4;\r\n                    // swap the second and third indices\r\n                    const secondIndex = binaryWriter.getUInt32(index + 4);\r\n                    const thirdIndex = binaryWriter.getUInt32(index + 8);\r\n                    binaryWriter.setUInt32(thirdIndex, index + 4);\r\n                    binaryWriter.setUInt32(secondIndex, index + 8);\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                for (let i = submesh.indexStart + submesh.indexCount - 1, start = submesh.indexStart; i >= start; --i) {\r\n                    binaryWriter.setUInt32(babylonIndices[i], byteOffset);\r\n                    byteOffset += 4;\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                if (submesh.indexCount >= 3) {\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 2], byteOffset + 4);\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 1], byteOffset + 8);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attribute data based on the primitive mode.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderVertexAttributeDataBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter): void {\r\n        if (this._convertToRightHandedSystem && sideOrientation === Material.ClockWiseSideOrientation) {\r\n            switch (primitiveMode) {\r\n                case Material.TriangleFillMode: {\r\n                    this.reorderTriangleFillMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                    break;\r\n                }\r\n                case Material.TriangleStripDrawMode: {\r\n                    this.reorderTriangleStripDrawMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                    break;\r\n                }\r\n                case Material.TriangleFanDrawMode: {\r\n                    this.reorderTriangleFanMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle mode order .  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderTriangleFillMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            let stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n            if (submesh.verticesCount % 3 !== 0) {\r\n                Tools.Error('The submesh vertices for the triangle fill mode is not divisible by 3!');\r\n            }\r\n            else {\r\n                let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n                let index = 0;\r\n                switch (vertexBufferKind) {\r\n                    case VertexBuffer.PositionKind:\r\n                    case VertexBuffer.NormalKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.TangentKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.ColorKind: {\r\n                        const size = vertexBuffer.getSize();\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + size) {\r\n                            index = x * stride;\r\n                            if (size === 4) {\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                            else {\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.UVKind:\r\n                    case VertexBuffer.UV2Kind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                    }\r\n                }\r\n                this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter);\r\n            }\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleFillMode: Vertex Buffer Kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle strip order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderTriangleStripDrawMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            const stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    index = submesh.verticesStart;\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        vertexBuffer.getSize() === 4 ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index)) : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this.writeVertexAttributeData(vertexData, byteOffset + 12, vertexBufferKind, meshAttributeArray, binaryWriter);\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleStripDrawMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle fan order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderTriangleFanMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            let stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                        vertexBuffer.getSize() === 4 ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index)) : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter);\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleFanMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes the vertex attribute data to binary\r\n     * @param vertices The vertices to write to the binary writer\r\n     * @param byteOffset The offset into the binary writer to overwrite binary data\r\n     * @param vertexAttributeKind The vertex attribute type\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param binaryWriter The writer containing the binary data\r\n     */\r\n    private writeVertexAttributeData(vertices: Vector2[] | Vector3[] | Vector4[], byteOffset: number, vertexAttributeKind: string, meshAttributeArray: FloatArray, binaryWriter: _BinaryWriter) {\r\n        for (let vertex of vertices) {\r\n            if (this._convertToRightHandedSystem && !(vertexAttributeKind === VertexBuffer.ColorKind) && !(vertex instanceof Vector2)) {\r\n                if (vertex instanceof Vector3) {\r\n                    if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertex);\r\n                    }\r\n                    else if (vertexAttributeKind === VertexBuffer.PositionKind) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertex);\r\n                    }\r\n                    else {\r\n                        Tools.Error('Unsupported vertex attribute kind!');\r\n                    }\r\n                }\r\n                else {\r\n                    _GLTFUtilities._GetRightHandedVector4FromRef(vertex);\r\n                }\r\n            }\r\n            if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                vertex.normalize();\r\n            }\r\n            else if (vertexAttributeKind === VertexBuffer.TangentKind && vertex instanceof Vector4) {\r\n                _GLTFUtilities._NormalizeTangentFromRef(vertex);\r\n            }\r\n\r\n            for (let component of vertex.asArray()) {\r\n                binaryWriter.setFloat32(component, byteOffset);\r\n                byteOffset += 4;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes mesh attribute data to a data buffer\r\n     * Returns the bytelength of the data\r\n     * @param vertexBufferKind Indicates what kind of vertex data is being passed in\r\n     * @param meshAttributeArray Array containing the attribute data\r\n     * @param binaryWriter The buffer to write the binary data to\r\n     * @param indices Used to specify the order of the vertex data\r\n     */\r\n    public writeAttributeData(vertexBufferKind: string, meshAttributeArray: FloatArray, byteStride: number, binaryWriter: _BinaryWriter) {\r\n        const stride = byteStride / 4;\r\n        let vertexAttributes: number[][] = [];\r\n        let index: number;\r\n\r\n        switch (vertexBufferKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (this._convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertexData);\r\n                    }\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (this._convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertexData);\r\n                    }\r\n                    vertexData.normalize();\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    if (this._convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedVector4FromRef(vertexData);\r\n                    }\r\n                    _GLTFUtilities._NormalizeTangentFromRef(vertexData);\r\n\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = stride === 3 ? Vector3.FromArray(meshAttributeArray, index) : Vector4.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    vertexAttributes.push(this._convertToRightHandedSystem ? [meshAttributeArray[index], meshAttributeArray[index + 1]] : [meshAttributeArray[index], meshAttributeArray[index + 1]]);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + vertexBufferKind);\r\n                vertexAttributes = [];\r\n            }\r\n        }\r\n        for (let vertexAttribute of vertexAttributes) {\r\n            for (let component of vertexAttribute) {\r\n                binaryWriter.setFloat32(component);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates glTF json data\r\n     * @param shouldUseGlb Indicates whether the json should be written for a glb file\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @param prettyPrint Indicates whether the json file should be pretty printed (true) or not (false)\r\n     * @returns json data as string\r\n     */\r\n    private generateJSON(shouldUseGlb: boolean, glTFPrefix?: string, prettyPrint?: boolean): string {\r\n        let buffer: IBuffer = { byteLength: this._totalByteLength };\r\n        let imageName: string;\r\n        let imageData: { data: Uint8Array, mimeType: ImageMimeType };\r\n        let bufferView: IBufferView;\r\n        let byteOffset: number = this._totalByteLength;\r\n\r\n        let glTF: IGLTF = {\r\n            asset: this._asset\r\n        };\r\n        if (this._extensionsUsed && this._extensionsUsed.length) {\r\n            glTF.extensionsUsed = this._extensionsUsed;\r\n        }\r\n        if (this._extensionsRequired && this._extensionsRequired.length) {\r\n            glTF.extensionsRequired = this._extensionsRequired;\r\n        }\r\n        if (buffer.byteLength) {\r\n            glTF.buffers = [buffer];\r\n        }\r\n        if (this._nodes && this._nodes.length) {\r\n            glTF.nodes = this._nodes;\r\n        }\r\n        if (this._meshes && this._meshes.length) {\r\n            glTF.meshes = this._meshes;\r\n        }\r\n        if (this._scenes && this._scenes.length) {\r\n            glTF.scenes = this._scenes;\r\n            glTF.scene = 0;\r\n        }\r\n        if (this._bufferViews && this._bufferViews.length) {\r\n            glTF.bufferViews = this._bufferViews;\r\n        }\r\n        if (this._accessors && this._accessors.length) {\r\n            glTF.accessors = this._accessors;\r\n        }\r\n        if (this._animations && this._animations.length) {\r\n            glTF.animations = this._animations;\r\n        }\r\n        if (this._materials && this._materials.length) {\r\n            glTF.materials = this._materials;\r\n        }\r\n        if (this._textures && this._textures.length) {\r\n            glTF.textures = this._textures;\r\n        }\r\n        if (this._samplers && this._samplers.length) {\r\n            glTF.samplers = this._samplers;\r\n        }\r\n        if (this._images && this._images.length) {\r\n            if (!shouldUseGlb) {\r\n                glTF.images = this._images;\r\n            }\r\n            else {\r\n                glTF.images = [];\r\n\r\n                this._images.forEach((image) => {\r\n                    if (image.uri) {\r\n                        imageData = this._imageData[image.uri];\r\n                        imageName = image.uri.split('.')[0] + \" image\";\r\n                        bufferView = _GLTFUtilities._CreateBufferView(0, byteOffset, imageData.data.length, undefined, imageName);\r\n                        byteOffset += imageData.data.buffer.byteLength;\r\n                        this._bufferViews.push(bufferView);\r\n                        image.bufferView = this._bufferViews.length - 1;\r\n                        image.name = imageName;\r\n                        image.mimeType = imageData.mimeType;\r\n                        image.uri = undefined;\r\n                        if (!glTF.images) {\r\n                            glTF.images = [];\r\n                        }\r\n                        glTF.images.push(image);\r\n                    }\r\n                });\r\n                // Replace uri with bufferview and mime type for glb\r\n                buffer.byteLength = byteOffset;\r\n            }\r\n        }\r\n\r\n        if (!shouldUseGlb) {\r\n            buffer.uri = glTFPrefix + \".bin\";\r\n        }\r\n\r\n        const jsonText = prettyPrint ? JSON.stringify(glTF, null, 2) : JSON.stringify(glTF);\r\n\r\n        return jsonText;\r\n    }\r\n\r\n    /**\r\n     * Generates data for .gltf and .bin files based on the glTF prefix string\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @returns GLTFData with glTF file data\r\n     */\r\n    public _generateGLTFAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            const jsonText = this.generateJSON(false, glTFPrefix, true);\r\n            const bin = new Blob([binaryBuffer], { type: 'application/octet-stream' });\r\n\r\n            const glTFFileName = glTFPrefix + '.gltf';\r\n            const glTFBinFile = glTFPrefix + '.bin';\r\n\r\n            const container = new GLTFData();\r\n\r\n            container.glTFFiles[glTFFileName] = jsonText;\r\n            container.glTFFiles[glTFBinFile] = bin;\r\n\r\n            if (this._imageData) {\r\n                for (let image in this._imageData) {\r\n                    container.glTFFiles[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });\r\n                }\r\n            }\r\n\r\n            return container;\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Creates a binary buffer for glTF\r\n     * @returns array buffer for binary data\r\n     */\r\n    private _generateBinaryAsync(): Promise<ArrayBuffer> {\r\n        let binaryWriter = new _BinaryWriter(4);\r\n        return this.createSceneAsync(this._babylonScene, binaryWriter).then(() => {\r\n            if (this._localEngine) {\r\n                this._localEngine.dispose();\r\n            }\r\n            return binaryWriter.getArrayBuffer();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Pads the number to a multiple of 4\r\n     * @param num number to pad\r\n     * @returns padded number\r\n     */\r\n    private _getPadding(num: number): number {\r\n        let remainder = num % 4;\r\n        let padding = remainder === 0 ? remainder : 4 - remainder;\r\n\r\n        return padding;\r\n    }\r\n\r\n    /**\r\n     * Generates a glb file from the json and binary data\r\n     * Returns an object with the glb file name as the key and data as the value\r\n     * @param glTFPrefix\r\n     * @returns object with glb filename as key and data as value\r\n     */\r\n    public _generateGLBAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            const jsonText = this.generateJSON(true);\r\n            const glbFileName = glTFPrefix + '.glb';\r\n            const headerLength = 12;\r\n            const chunkLengthPrefix = 8;\r\n            const jsonLength = jsonText.length;\r\n            let imageByteLength = 0;\r\n\r\n            for (let key in this._imageData) {\r\n                imageByteLength += this._imageData[key].data.byteLength;\r\n            }\r\n            const jsonPadding = this._getPadding(jsonLength);\r\n            const binPadding = this._getPadding(binaryBuffer.byteLength);\r\n            const imagePadding = this._getPadding(imageByteLength);\r\n\r\n            const byteLength = headerLength + (2 * chunkLengthPrefix) + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding + imageByteLength + imagePadding;\r\n\r\n            //header\r\n            const headerBuffer = new ArrayBuffer(headerLength);\r\n            const headerBufferView = new DataView(headerBuffer);\r\n            headerBufferView.setUint32(0, 0x46546C67, true); //glTF\r\n            headerBufferView.setUint32(4, 2, true); // version\r\n            headerBufferView.setUint32(8, byteLength, true); // total bytes in file\r\n\r\n            //json chunk\r\n            const jsonChunkBuffer = new ArrayBuffer(chunkLengthPrefix + jsonLength + jsonPadding);\r\n            const jsonChunkBufferView = new DataView(jsonChunkBuffer);\r\n            jsonChunkBufferView.setUint32(0, jsonLength + jsonPadding, true);\r\n            jsonChunkBufferView.setUint32(4, 0x4E4F534A, true);\r\n\r\n            //json chunk bytes\r\n            const jsonData = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix);\r\n            for (let i = 0; i < jsonLength; ++i) {\r\n                jsonData[i] = jsonText.charCodeAt(i);\r\n            }\r\n\r\n            //json padding\r\n            const jsonPaddingView = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix + jsonLength);\r\n            for (let i = 0; i < jsonPadding; ++i) {\r\n                jsonPaddingView[i] = 0x20;\r\n            }\r\n\r\n            //binary chunk\r\n            const binaryChunkBuffer = new ArrayBuffer(chunkLengthPrefix);\r\n            const binaryChunkBufferView = new DataView(binaryChunkBuffer);\r\n            binaryChunkBufferView.setUint32(0, binaryBuffer.byteLength + imageByteLength + imagePadding, true);\r\n            binaryChunkBufferView.setUint32(4, 0x004E4942, true);\r\n\r\n            // binary padding\r\n            const binPaddingBuffer = new ArrayBuffer(binPadding);\r\n            const binPaddingView = new Uint8Array(binPaddingBuffer);\r\n            for (let i = 0; i < binPadding; ++i) {\r\n                binPaddingView[i] = 0;\r\n            }\r\n\r\n            const imagePaddingBuffer = new ArrayBuffer(imagePadding);\r\n            const imagePaddingView = new Uint8Array(imagePaddingBuffer);\r\n            for (let i = 0; i < imagePadding; ++i) {\r\n                imagePaddingView[i] = 0;\r\n            }\r\n\r\n            const glbData = [headerBuffer, jsonChunkBuffer, binaryChunkBuffer, binaryBuffer];\r\n\r\n            // binary data\r\n            for (let key in this._imageData) {\r\n                glbData.push(this._imageData[key].data.buffer);\r\n            }\r\n            glbData.push(binPaddingBuffer);\r\n\r\n            glbData.push(imagePaddingBuffer);\r\n\r\n            const glbFile = new Blob(glbData, { type: 'application/octet-stream' });\r\n\r\n            const container = new GLTFData();\r\n            container.glTFFiles[glbFileName] = glbFile;\r\n\r\n            if (this._localEngine != null) {\r\n                this._localEngine.dispose();\r\n            }\r\n\r\n            return container;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the TRS for each node\r\n     * @param node glTF Node for storing the transformation data\r\n     * @param babylonTransformNode Babylon mesh used as the source for the transformation data\r\n     */\r\n    private setNodeTransformation(node: INode, babylonTransformNode: TransformNode): void {\r\n        if (!babylonTransformNode.getPivotPoint().equalsToFloats(0, 0, 0)) {\r\n            BABYLON.Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\r\n        }\r\n        if (!babylonTransformNode.position.equalsToFloats(0, 0, 0)) {\r\n            node.translation = this._convertToRightHandedSystem ? _GLTFUtilities._GetRightHandedPositionVector3(babylonTransformNode.position).asArray() : babylonTransformNode.position.asArray();\r\n        }\r\n\r\n        if (!babylonTransformNode.scaling.equalsToFloats(1, 1, 1)) {\r\n            node.scale = babylonTransformNode.scaling.asArray();\r\n        }\r\n\r\n        let rotationQuaternion = Quaternion.RotationYawPitchRoll(babylonTransformNode.rotation.y, babylonTransformNode.rotation.x, babylonTransformNode.rotation.z);\r\n        if (babylonTransformNode.rotationQuaternion) {\r\n            rotationQuaternion.multiplyInPlace(babylonTransformNode.rotationQuaternion);\r\n        }\r\n        if (!(rotationQuaternion.x === 0 && rotationQuaternion.y === 0 && rotationQuaternion.z === 0 && rotationQuaternion.w === 1)) {\r\n            if (this._convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n\r\n            }\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private getVertexBufferFromMesh(attributeKind: string, bufferMesh: Mesh): Nullable<VertexBuffer> {\r\n        if (bufferMesh.isVerticesDataPresent(attributeKind)) {\r\n            const vertexBuffer = bufferMesh.getVertexBuffer(attributeKind);\r\n            if (vertexBuffer) {\r\n                return vertexBuffer;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a bufferview based on the vertices type for the Babylon mesh\r\n     * @param kind Indicates the type of vertices data\r\n     * @param babylonTransformNode The Babylon mesh to get the vertices data from\r\n     * @param binaryWriter The buffer to write the bufferview data to\r\n     */\r\n    private createBufferViewKind(kind: string, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter, byteStride: number) {\r\n        const bufferMesh = babylonTransformNode instanceof Mesh ?\r\n            babylonTransformNode as Mesh : babylonTransformNode instanceof InstancedMesh ?\r\n                (babylonTransformNode as InstancedMesh).sourceMesh : null;\r\n\r\n        if (bufferMesh) {\r\n            const vertexData = bufferMesh.getVerticesData(kind);\r\n\r\n            if (vertexData) {\r\n                const byteLength = vertexData.length * 4;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, kind + \" - \" + bufferMesh.name);\r\n                this._bufferViews.push(bufferView);\r\n\r\n                this.writeAttributeData(\r\n                    kind,\r\n                    vertexData,\r\n                    byteStride,\r\n                    binaryWriter\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The primitive mode of the Babylon mesh\r\n     * @param babylonMesh The BabylonJS mesh\r\n     */\r\n    private getMeshPrimitiveMode(babylonMesh: AbstractMesh): number {\r\n        if (babylonMesh instanceof LinesMesh) {\r\n            return Material.LineListDrawMode;\r\n        }\r\n        return babylonMesh.material ? babylonMesh.material.fillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the primitive mode of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param primitiveMode The primitive mode\r\n     */\r\n    private setPrimitiveMode(meshPrimitive: IMeshPrimitive, primitiveMode: number) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                // glTF defaults to using Triangle Mode\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_STRIP;\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_FAN;\r\n                break;\r\n            }\r\n            case Material.PointListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n            }\r\n            case Material.PointFillMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n                break;\r\n            }\r\n            case Material.LineLoopDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_LOOP;\r\n                break;\r\n            }\r\n            case Material.LineListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINES;\r\n                break;\r\n            }\r\n            case Material.LineStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_STRIP;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex attribute accessor based of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param attributeKind vertex attribute\r\n     * @returns boolean specifying if uv coordinates are present\r\n     */\r\n    private setAttributeKind(meshPrimitive: IMeshPrimitive, attributeKind: string): void {\r\n        switch (attributeKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                meshPrimitive.attributes.POSITION = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                meshPrimitive.attributes.NORMAL = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                meshPrimitive.attributes.COLOR_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                meshPrimitive.attributes.TANGENT = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind: {\r\n                meshPrimitive.attributes.TEXCOORD_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UV2Kind: {\r\n                meshPrimitive.attributes.TEXCOORD_1 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + attributeKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets data for the primitive attributes of each submesh\r\n     * @param mesh glTF Mesh object to store the primitive attribute information\r\n     * @param babylonTransformNode Babylon mesh to get the primitive attribute data from\r\n     * @param binaryWriter Buffer to write the attribute data to\r\n     */\r\n    private setPrimitiveAttributesAsync(mesh: IMesh, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter): Promise<void> {\r\n        let promises: Promise<IMeshPrimitive>[] = [];\r\n        let bufferMesh: Nullable<Mesh> = null;\r\n        let bufferView: IBufferView;\r\n        let uvCoordsPresent: boolean;\r\n        let minMax: { min: Nullable<number[]>, max: Nullable<number[]> };\r\n\r\n        if (babylonTransformNode instanceof Mesh) {\r\n            bufferMesh = (babylonTransformNode as Mesh);\r\n        }\r\n        else if (babylonTransformNode instanceof InstancedMesh) {\r\n            bufferMesh = (babylonTransformNode as InstancedMesh).sourceMesh;\r\n        }\r\n        const attributeData: _IVertexAttributeData[] = [\r\n            { kind: VertexBuffer.PositionKind, accessorType: AccessorType.VEC3, byteStride: 12 },\r\n            { kind: VertexBuffer.NormalKind, accessorType: AccessorType.VEC3, byteStride: 12 },\r\n            { kind: VertexBuffer.ColorKind, accessorType: AccessorType.VEC4, byteStride: 16 },\r\n            { kind: VertexBuffer.TangentKind, accessorType: AccessorType.VEC4, byteStride: 16 },\r\n            { kind: VertexBuffer.UVKind, accessorType: AccessorType.VEC2, byteStride: 8 },\r\n            { kind: VertexBuffer.UV2Kind, accessorType: AccessorType.VEC2, byteStride: 8 },\r\n        ];\r\n\r\n        if (bufferMesh) {\r\n            let indexBufferViewIndex: Nullable<number> = null;\r\n            const primitiveMode = this.getMeshPrimitiveMode(bufferMesh);\r\n            let vertexAttributeBufferViews: { [attributeKind: string]: number } = {};\r\n\r\n            // For each BabylonMesh, create bufferviews for each 'kind'\r\n            for (const attribute of attributeData) {\r\n                const attributeKind = attribute.kind;\r\n                if (bufferMesh.isVerticesDataPresent(attributeKind)) {\r\n                    const vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                    attribute.byteStride = vertexBuffer ? vertexBuffer.getSize() * 4 : VertexBuffer.DeduceStride(attributeKind) * 4;\r\n                    if (attribute.byteStride === 12) {\r\n                        attribute.accessorType = AccessorType.VEC3;\r\n                    }\r\n\r\n                    this.createBufferViewKind(attributeKind, babylonTransformNode, binaryWriter, attribute.byteStride);\r\n                    attribute.bufferViewIndex = this._bufferViews.length - 1;\r\n                    vertexAttributeBufferViews[attributeKind] = attribute.bufferViewIndex;\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.getTotalIndices()) {\r\n                const indices = bufferMesh.getIndices();\r\n                if (indices) {\r\n                    const byteLength = indices.length * 4;\r\n                    bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, \"Indices - \" + bufferMesh.name);\r\n                    this._bufferViews.push(bufferView);\r\n                    indexBufferViewIndex = this._bufferViews.length - 1;\r\n\r\n                    for (let k = 0, length = indices.length; k < length; ++k) {\r\n                        binaryWriter.setUInt32(indices[k]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.subMeshes) {\r\n                // go through all mesh primitives (submeshes)\r\n                for (const submesh of bufferMesh.subMeshes) {\r\n                    uvCoordsPresent = false;\r\n                    let babylonMaterial = submesh.getMaterial() || bufferMesh.getScene().defaultMaterial;\r\n\r\n                    let materialIndex: Nullable<number> = null;\r\n                    if (babylonMaterial) {\r\n                        if (bufferMesh instanceof LinesMesh) {\r\n                            // get the color from the lines mesh and set it in the material\r\n                            const material: IMaterial = {\r\n                                name: bufferMesh.name + ' material'\r\n                            };\r\n                            if (!bufferMesh.color.equals(Color3.White()) || bufferMesh.alpha < 1) {\r\n                                material.pbrMetallicRoughness = {\r\n                                    baseColorFactor: bufferMesh.color.asArray().concat([bufferMesh.alpha])\r\n                                };\r\n                            }\r\n                            this._materials.push(material);\r\n                            materialIndex = this._materials.length - 1;\r\n                        }\r\n                        else if (babylonMaterial instanceof MultiMaterial) {\r\n                            const subMaterial = babylonMaterial.subMaterials[submesh.materialIndex];\r\n                            if (subMaterial) {\r\n                                babylonMaterial = subMaterial;\r\n                                materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                            }\r\n                        }\r\n                        else {\r\n                            materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                        }\r\n                    }\r\n\r\n                    let glTFMaterial: Nullable<IMaterial> = materialIndex != null ? this._materials[materialIndex] : null;\r\n\r\n                    const meshPrimitive: IMeshPrimitive = { attributes: {} };\r\n                    this.setPrimitiveMode(meshPrimitive, primitiveMode);\r\n\r\n                    for (const attribute of attributeData) {\r\n                        const attributeKind = attribute.kind;\r\n                        if (attributeKind === VertexBuffer.UVKind || attributeKind === VertexBuffer.UV2Kind) {\r\n                            if (glTFMaterial && !this._glTFMaterialExporter._hasTexturesPresent(glTFMaterial)) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        let vertexData = bufferMesh.getVerticesData(attributeKind);\r\n                        if (vertexData) {\r\n                            const vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                            if (vertexBuffer) {\r\n                                const stride = vertexBuffer.getSize();\r\n                                const bufferViewIndex = attribute.bufferViewIndex;\r\n                                if (bufferViewIndex != undefined) { // check to see if bufferviewindex has a numeric value assigned.\r\n                                    minMax = { min: null, max: null };\r\n                                    if (attributeKind == VertexBuffer.PositionKind) {\r\n                                        minMax = _GLTFUtilities._CalculateMinMaxPositions(vertexData, 0, vertexData.length / stride, this._convertToRightHandedSystem);\r\n                                    }\r\n                                    const accessor = _GLTFUtilities._CreateAccessor(bufferViewIndex, attributeKind + \" - \" + babylonTransformNode.name, attribute.accessorType, AccessorComponentType.FLOAT, vertexData.length / stride, 0, minMax.min, minMax.max);\r\n                                    this._accessors.push(accessor);\r\n                                    this.setAttributeKind(meshPrimitive, attributeKind);\r\n                                    if (meshPrimitive.attributes.TEXCOORD_0 != null || meshPrimitive.attributes.TEXCOORD_1 != null) {\r\n                                        uvCoordsPresent = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (indexBufferViewIndex) {\r\n                        // Create accessor\r\n                        const accessor = _GLTFUtilities._CreateAccessor(indexBufferViewIndex, \"indices - \" + babylonTransformNode.name, AccessorType.SCALAR, AccessorComponentType.UNSIGNED_INT, submesh.indexCount, submesh.indexStart * 4, null, null);\r\n                        this._accessors.push(accessor);\r\n                        meshPrimitive.indices = this._accessors.length - 1;\r\n                    }\r\n                    if (materialIndex != null && Object.keys(meshPrimitive.attributes).length > 0) {\r\n                        let sideOrientation = babylonMaterial.sideOrientation;\r\n\r\n                        if (this._convertToRightHandedSystem && sideOrientation === Material.ClockWiseSideOrientation) {\r\n                            //Overwrite the indices to be counter-clockwise\r\n                            let byteOffset = indexBufferViewIndex != null ? this._bufferViews[indexBufferViewIndex].byteOffset : null;\r\n                            if (byteOffset == null) { byteOffset = 0; }\r\n                            let babylonIndices: Nullable<IndicesArray> = null;\r\n                            if (indexBufferViewIndex != null) {\r\n                                babylonIndices = bufferMesh.getIndices();\r\n                            }\r\n                            if (babylonIndices) {\r\n                                this.reorderIndicesBasedOnPrimitiveMode(submesh, primitiveMode, babylonIndices, byteOffset, binaryWriter);\r\n                            }\r\n                            else {\r\n                                for (let attribute of attributeData) {\r\n                                    let vertexData = bufferMesh.getVerticesData(attribute.kind);\r\n                                    if (vertexData) {\r\n                                        let byteOffset = this._bufferViews[vertexAttributeBufferViews[attribute.kind]].byteOffset;\r\n                                        if (!byteOffset) {\r\n                                            byteOffset = 0;\r\n                                        }\r\n                                        this.reorderVertexAttributeDataBasedOnPrimitiveMode(submesh, primitiveMode, sideOrientation, attribute.kind, vertexData, byteOffset, binaryWriter);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (!uvCoordsPresent && this._glTFMaterialExporter._hasTexturesPresent(this._materials[materialIndex])) {\r\n                            const newMat = this._glTFMaterialExporter._stripTexturesFromMaterial(this._materials[materialIndex]);\r\n                            this._materials.push(newMat);\r\n                            materialIndex = this._materials.length - 1;\r\n                        }\r\n\r\n                        meshPrimitive.material = materialIndex;\r\n\r\n                    }\r\n                    mesh.primitives.push(meshPrimitive);\r\n\r\n                    const promise = this._extensionsPostExportMeshPrimitiveAsync(\"postExport\", meshPrimitive, submesh, binaryWriter);\r\n                    if (promise) {\r\n                        promises.push();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            /* do nothing */\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF scene based on the array of meshes\r\n     * Returns the the total byte offset\r\n     * @param babylonScene Babylon scene to get the mesh data from\r\n     * @param binaryWriter Buffer to write binary data to\r\n     */\r\n    private createSceneAsync(babylonScene: Scene, binaryWriter: _BinaryWriter): Promise<void> {\r\n        const scene: IScene = { nodes: [] };\r\n        let glTFNodeIndex: number;\r\n        let glTFNode: INode;\r\n        let directDescendents: Node[];\r\n        const nodes = [...babylonScene.transformNodes, ...babylonScene.meshes];\r\n\r\n        return this._glTFMaterialExporter._convertMaterialsToGLTFAsync(babylonScene.materials, ImageMimeType.PNG, true).then(() => {\r\n            return this.createNodeMapAndAnimationsAsync(babylonScene, nodes, this._shouldExportTransformNode, binaryWriter).then((nodeMap) => {\r\n                this._nodeMap = nodeMap;\r\n\r\n                this._totalByteLength = binaryWriter.getByteOffset();\r\n                if (this._totalByteLength == undefined) {\r\n                    throw new Error(\"undefined byte length!\");\r\n                }\r\n\r\n                // Build Hierarchy with the node map.\r\n                for (let babylonTransformNode of nodes) {\r\n                    glTFNodeIndex = this._nodeMap[babylonTransformNode.uniqueId];\r\n                    if (glTFNodeIndex != null) {\r\n                        glTFNode = this._nodes[glTFNodeIndex];\r\n                        if (!babylonTransformNode.parent) {\r\n                            if (!this._shouldExportTransformNode(babylonTransformNode)) {\r\n                                Tools.Log(\"Omitting \" + babylonTransformNode.name + \" from scene.\");\r\n                            }\r\n                            else {\r\n                                if (this._convertToRightHandedSystem) {\r\n                                    if (glTFNode.translation) {\r\n                                        glTFNode.translation[2] *= -1;\r\n                                        glTFNode.translation[0] *= -1;\r\n                                    }\r\n                                    glTFNode.rotation = glTFNode.rotation ? Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(glTFNode.rotation)).asArray() : (Quaternion.FromArray([0, 1, 0, 0])).asArray();\r\n                                }\r\n\r\n                                scene.nodes.push(glTFNodeIndex);\r\n                            }\r\n                        }\r\n\r\n                        directDescendents = babylonTransformNode.getDescendants(true);\r\n                        if (!glTFNode.children && directDescendents && directDescendents.length) {\r\n                            const children: number[] = [];\r\n                            for (let descendent of directDescendents) {\r\n                                if (this._nodeMap[descendent.uniqueId] != null) {\r\n                                    children.push(this._nodeMap[descendent.uniqueId]);\r\n                                }\r\n                            }\r\n                            if (children.length) {\r\n                                glTFNode.children = children;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (scene.nodes.length) {\r\n                    this._scenes.push(scene);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a mapping of Node unique id to node index and handles animations\r\n     * @param babylonScene Babylon Scene\r\n     * @param nodes Babylon transform nodes\r\n     * @param shouldExportTransformNode Callback specifying if a transform node should be exported\r\n     * @param binaryWriter Buffer to write binary data to\r\n     * @returns Node mapping of unique id to index\r\n     */\r\n    private createNodeMapAndAnimationsAsync(babylonScene: Scene, nodes: TransformNode[], shouldExportTransformNode: (babylonTransformNode: TransformNode) => boolean, binaryWriter: _BinaryWriter): Promise<{ [key: number]: number }> {\r\n        let promiseChain = Promise.resolve();\r\n        const nodeMap: { [key: number]: number } = {};\r\n        let nodeIndex: number;\r\n        let runtimeGLTFAnimation: IAnimation = {\r\n            name: 'runtime animations',\r\n            channels: [],\r\n            samplers: []\r\n        };\r\n        let idleGLTFAnimations: IAnimation[] = [];\r\n\r\n        for (let babylonTransformNode of nodes) {\r\n            if (shouldExportTransformNode(babylonTransformNode)) {\r\n                promiseChain = promiseChain.then(() => {\r\n                    return this.createNodeAsync(babylonTransformNode, binaryWriter).then((node) => {\r\n                        const directDescendents = babylonTransformNode.getDescendants(true, (node: Node) => { return (node instanceof TransformNode); });\r\n                        if (directDescendents.length || node.mesh != null) {\r\n                            this._nodes.push(node);\r\n                            nodeIndex = this._nodes.length - 1;\r\n                            nodeMap[babylonTransformNode.uniqueId] = nodeIndex;\r\n                        }\r\n\r\n                        if (!babylonScene.animationGroups.length && babylonTransformNode.animations.length) {\r\n                            _GLTFAnimation._CreateNodeAnimationFromTransformNodeAnimations(babylonTransformNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, this._nodes, binaryWriter, this._bufferViews, this._accessors, this._convertToRightHandedSystem, this._animationSampleRate);\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                `Excluding mesh ${babylonTransformNode.name}`;\r\n            }\r\n        }\r\n\r\n        return promiseChain.then(() => {\r\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\r\n                this._animations.push(runtimeGLTFAnimation);\r\n            }\r\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\r\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\r\n                    this._animations.push(idleGLTFAnimation);\r\n                }\r\n            });\r\n\r\n            if (babylonScene.animationGroups.length) {\r\n                _GLTFAnimation._CreateNodeAnimationFromAnimationGroups(babylonScene, this._animations, nodeMap, this._nodes, binaryWriter, this._bufferViews, this._accessors, this._convertToRightHandedSystem, this._animationSampleRate);\r\n            }\r\n\r\n            return nodeMap;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF node from a Babylon mesh\r\n     * @param babylonMesh Source Babylon mesh\r\n     * @param binaryWriter Buffer for storing geometry data\r\n     * @returns glTF node\r\n     */\r\n    private createNodeAsync(babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter): Promise<INode> {\r\n        return Promise.resolve().then(() => {\r\n            // create node to hold translation/rotation/scale and the mesh\r\n            const node: INode = {};\r\n            // create mesh\r\n            const mesh: IMesh = { primitives: [] };\r\n\r\n            if (babylonTransformNode.name) {\r\n                node.name = babylonTransformNode.name;\r\n            }\r\n\r\n            // Set transformation\r\n            this.setNodeTransformation(node, babylonTransformNode);\r\n\r\n            return this.setPrimitiveAttributesAsync(mesh, babylonTransformNode, binaryWriter).then(() => {\r\n                if (mesh.primitives.length) {\r\n                    this._meshes.push(mesh);\r\n                    node.mesh = this._meshes.length - 1;\r\n                }\r\n\r\n                return node;\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * @hidden\r\n *\r\n * Stores glTF binary data.  If the array buffer byte length is exceeded, it doubles in size dynamically\r\n */\r\nexport class _BinaryWriter {\r\n    /**\r\n     * Array buffer which stores all binary data\r\n     */\r\n    private _arrayBuffer: ArrayBuffer;\r\n    /**\r\n     * View of the array buffer\r\n     */\r\n    private _dataView: DataView;\r\n    /**\r\n     * byte offset of data in array buffer\r\n     */\r\n    private _byteOffset: number;\r\n    /**\r\n     * Initialize binary writer with an initial byte length\r\n     * @param byteLength Initial byte length of the array buffer\r\n     */\r\n    constructor(byteLength: number) {\r\n        this._arrayBuffer = new ArrayBuffer(byteLength);\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n        this._byteOffset = 0;\r\n    }\r\n    /**\r\n     * Resize the array buffer to the specified byte length\r\n     * @param byteLength\r\n     */\r\n    private resizeBuffer(byteLength: number): ArrayBuffer {\r\n        let newBuffer = new ArrayBuffer(byteLength);\r\n        let oldUint8Array = new Uint8Array(this._arrayBuffer);\r\n        let newUint8Array = new Uint8Array(newBuffer);\r\n        for (let i = 0, length = newUint8Array.byteLength; i < length; ++i) {\r\n            newUint8Array[i] = oldUint8Array[i];\r\n        }\r\n        this._arrayBuffer = newBuffer;\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n\r\n        return newBuffer;\r\n    }\r\n    /**\r\n     * Get an array buffer with the length of the byte offset\r\n     * @returns ArrayBuffer resized to the byte offset\r\n     */\r\n    public getArrayBuffer(): ArrayBuffer {\r\n        return this.resizeBuffer(this.getByteOffset());\r\n    }\r\n    /**\r\n     * Get the byte offset of the array buffer\r\n     * @returns byte offset\r\n     */\r\n    public getByteOffset(): number {\r\n        if (this._byteOffset == undefined) {\r\n            throw new Error(\"Byte offset is undefined!\");\r\n        }\r\n        return this._byteOffset;\r\n    }\r\n    /**\r\n     * Stores an UInt8 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt8(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint8(byteOffset, entry);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            }\r\n        }\r\n        else {\r\n            if (this._byteOffset + 1 > this._arrayBuffer.byteLength) {\r\n                this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint8(this._byteOffset++, entry);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public getUInt32(byteOffset: number): number {\r\n        if (byteOffset < this._byteOffset) {\r\n            return this._dataView.getUint32(byteOffset, true);\r\n        }\r\n        else {\r\n            Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            throw new Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n        }\r\n    }\r\n\r\n    public getVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            vector3.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector3.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector3.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n        }\r\n    }\r\n\r\n    public setVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            this._dataView.setFloat32(byteOffset, vector3.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector3.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector3.z, true);\r\n        }\r\n    }\r\n\r\n    public getVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            vector4.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector4.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector4.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n            vector4.w = this._dataView.getFloat32(byteOffset + 12, true);\r\n        }\r\n    }\r\n\r\n    public setVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            this._dataView.setFloat32(byteOffset, vector4.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector4.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector4.z, true);\r\n            this._dataView.setFloat32(byteOffset + 12, vector4.w, true);\r\n        }\r\n    }\r\n    /**\r\n     * Stores a Float32 in the array buffer\r\n     * @param entry\r\n     */\r\n    public setFloat32(entry: number, byteOffset?: number) {\r\n        if (isNaN(entry)) {\r\n            Tools.Error('Invalid data being written!');\r\n        }\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setFloat32(byteOffset, entry, true);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary length!');\r\n            }\r\n        }\r\n        if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n            this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n        }\r\n        this._dataView.setFloat32(this._byteOffset, entry, true);\r\n        this._byteOffset += 4;\r\n    }\r\n    /**\r\n     * Stores an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt32(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint32(byteOffset, entry, true);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            }\r\n        }\r\n        else {\r\n            if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n                this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint32(this._byteOffset, entry, true);\r\n            this._byteOffset += 4;\r\n        }\r\n    }\r\n}","export * from \"./OBJ\";\r\nexport * from \"./glTF\";","import { Animation, TransformNode, Nullable, Tools, Scene, Mesh, Vector3, Quaternion, IAnimationKey, AnimationKeyInterpolation } from \"babylonjs\";\r\nimport { AnimationSamplerInterpolation, AnimationChannelTargetPath, AccessorType, IAnimation, INode, IBufferView, IAccessor, IAnimationSampler, IAnimationChannel, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport { _BinaryWriter } from \"./glTFExporter\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\n\r\n/**\r\n * @hidden\r\n * Interface to store animation data.\r\n */\r\nexport interface _IAnimationData {\r\n    /**\r\n     * Keyframe data.\r\n     */\r\n    inputs: number[];\r\n    /**\r\n     * Value data.\r\n     */\r\n    outputs: number[][];\r\n    /**\r\n     * Animation interpolation data.\r\n     */\r\n    samplerInterpolation: AnimationSamplerInterpolation;\r\n    /**\r\n     * Minimum keyframe value.\r\n     */\r\n    inputsMin: number;\r\n    /**\r\n     * Maximum keyframe value.\r\n     */\r\n    inputsMax: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport interface _IAnimationInfo {\r\n    /**\r\n     * The target channel for the animation\r\n     */\r\n    animationChannelTargetPath: AnimationChannelTargetPath;\r\n    /**\r\n     * The glTF accessor type for the data.\r\n     */\r\n    dataAccessorType: AccessorType.VEC3 | AccessorType.VEC4;\r\n    /**\r\n     * Specifies if quaternions should be used.\r\n     */\r\n    useQuaternion: boolean;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * Enum for handling in tangent and out tangent.\r\n */\r\nenum _TangentType {\r\n    /**\r\n     * Specifies that input tangents are used.\r\n     */\r\n    INTANGENT,\r\n    /**\r\n     * Specifies that output tangents are used.\r\n     */\r\n    OUTTANGENT\r\n}\r\n/**\r\n * @hidden\r\n * Utility class for generating glTF animation data from BabylonJS.\r\n */\r\nexport class _GLTFAnimation {\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Creates glTF channel animation from BabylonJS animation.\r\n     * @param babylonTransformNode - BabylonJS mesh.\r\n     * @param animation - animation.\r\n     * @param animationChannelTargetPath - The target animation channel.\r\n     * @param convertToRightHandedSystem - Specifies if the values should be converted to right-handed.\r\n     * @param useQuaternion - Specifies if quaternions are used.\r\n     * @returns nullable IAnimationData\r\n     */\r\n    public static _CreateNodeAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean, animationSampleRate: number): Nullable<_IAnimationData> {\r\n        const inputs: number[] = [];\r\n        const outputs: number[][] = [];\r\n        const keyFrames = animation.getKeys();\r\n        const minMaxKeyFrames = _GLTFAnimation.calculateMinMaxKeyFrames(keyFrames);\r\n        const interpolationOrBake = _GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);\r\n        const frameDelta = minMaxKeyFrames.max - minMaxKeyFrames.min;\r\n\r\n        const interpolation = interpolationOrBake.interpolationType;\r\n        const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;\r\n\r\n        if (shouldBakeAnimation) {\r\n            _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n        else {\r\n            if (interpolation === AnimationSamplerInterpolation.LINEAR || interpolation === AnimationSamplerInterpolation.STEP) {\r\n                _GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n\r\n            }\r\n            else if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                _GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n            }\r\n            else {\r\n                _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);\r\n            }\r\n        }\r\n\r\n        if (inputs.length && outputs.length) {\r\n            const result: _IAnimationData = {\r\n                inputs: inputs,\r\n                outputs: outputs,\r\n                samplerInterpolation: interpolation,\r\n                inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),\r\n                inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond)\r\n            };\r\n\r\n            return result;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _DeduceAnimationInfo(animation: Animation): Nullable<_IAnimationInfo> {\r\n        let animationChannelTargetPath: Nullable<AnimationChannelTargetPath> = null;\r\n        let dataAccessorType = AccessorType.VEC3;\r\n        let useQuaternion: boolean = false;\r\n        let property = animation.targetProperty.split('.');\r\n        switch (property[0]) {\r\n            case 'scaling': {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.SCALE;\r\n                break;\r\n            }\r\n            case 'position': {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.TRANSLATION;\r\n                break;\r\n            }\r\n            case 'rotation': {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case 'rotationQuaternion': {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                useQuaternion = true;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported animatable property ${property[0]}`);\r\n            }\r\n        }\r\n        if (animationChannelTargetPath) {\r\n            return { animationChannelTargetPath: animationChannelTargetPath, dataAccessorType: dataAccessorType, useQuaternion: useQuaternion };\r\n        }\r\n        else {\r\n            Tools.Error('animation channel target path and data accessor type could be deduced');\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the transform node animations\r\n     * @param babylonTransformNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param convertToRightHandedSystem\r\n     */\r\n    public static _CreateNodeAnimationFromTransformNodeAnimations(babylonTransformNode: TransformNode, runtimeGLTFAnimation: IAnimation, idleGLTFAnimations: IAnimation[], nodeMap: { [key: number]: number }, nodes: INode[], binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, animationSampleRate: number) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonTransformNode.animations) {\r\n            for (let animation of babylonTransformNode.animations) {\r\n                let animationInfo = _GLTFAnimation._DeduceAnimationInfo(animation);\r\n                if (animationInfo) {\r\n                    glTFAnimation = {\r\n                        name: animation.name,\r\n                        samplers: [],\r\n                        channels: []\r\n                    };\r\n                    _GLTFAnimation.AddAnimation(`${animation.name}`,\r\n                        animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                        babylonTransformNode,\r\n                        animation,\r\n                        animationInfo.dataAccessorType,\r\n                        animationInfo.animationChannelTargetPath,\r\n                        nodeMap,\r\n                        binaryWriter,\r\n                        bufferViews,\r\n                        accessors,\r\n                        convertToRightHandedSystem,\r\n                        animationInfo.useQuaternion,\r\n                        animationSampleRate\r\n                    );\r\n                    if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                        idleGLTFAnimations.push(glTFAnimation);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the animation groups\r\n     * @param babylonScene\r\n     * @param glTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param convertToRightHandedSystem\r\n     */\r\n    public static _CreateNodeAnimationFromAnimationGroups(babylonScene: Scene, glTFAnimations: IAnimation[], nodeMap: { [key: number]: number }, nodes: INode[], binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, animationSampleRate: number) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonScene.animationGroups) {\r\n            let animationGroups = babylonScene.animationGroups;\r\n\r\n            for (let animationGroup of animationGroups) {\r\n                glTFAnimation = {\r\n                    name: animationGroup.name,\r\n                    channels: [],\r\n                    samplers: []\r\n                };\r\n                for (let targetAnimation of animationGroup.targetedAnimations) {\r\n                    let target = targetAnimation.target;\r\n                    let animation = targetAnimation.animation;\r\n                    if (target instanceof Mesh || target.length === 1 && target[0] instanceof Mesh) { // TODO: Update to support bones\r\n                        let animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            let babylonMesh = target instanceof Mesh ? target : target[0] as Mesh;\r\n                            _GLTFAnimation.AddAnimation(`${animation.name}`,\r\n                                glTFAnimation,\r\n                                babylonMesh,\r\n                                animation,\r\n                                animationInfo.dataAccessorType,\r\n                                animationInfo.animationChannelTargetPath,\r\n                                nodeMap,\r\n                                binaryWriter,\r\n                                bufferViews,\r\n                                accessors,\r\n                                convertToRightHandedSystem,\r\n                                animationInfo.useQuaternion,\r\n                                animationSampleRate\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n                if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {\r\n                    glTFAnimations.push(glTFAnimation);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static AddAnimation(name: string, glTFAnimation: IAnimation, babylonTransformNode: TransformNode, animation: Animation, dataAccessorType: AccessorType, animationChannelTargetPath: AnimationChannelTargetPath, nodeMap: { [key: number]: number }, binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, useQuaternion: boolean, animationSampleRate: number) {\r\n        let animationData = _GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion, animationSampleRate);\r\n        let bufferView: IBufferView;\r\n        let accessor: IAccessor;\r\n        let keyframeAccessorIndex: number;\r\n        let dataAccessorIndex: number;\r\n        let outputLength: number;\r\n        let animationSampler: IAnimationSampler;\r\n        let animationChannel: IAnimationChannel;\r\n\r\n        if (animationData) {\r\n            let nodeIndex = nodeMap[babylonTransformNode.uniqueId];\r\n\r\n            // Creates buffer view and accessor for key frames.\r\n            let byteLength = animationData.inputs.length * 4;\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  keyframe data view`);\r\n            bufferViews.push(bufferView);\r\n\r\n            animationData.inputs.forEach(function(input) {\r\n                binaryWriter.setFloat32(input);\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  keyframes`, AccessorType.SCALAR, AccessorComponentType.FLOAT, animationData.inputs.length, null, [animationData.inputsMin], [animationData.inputsMax]);\r\n            accessors.push(accessor);\r\n            keyframeAccessorIndex = accessors.length - 1;\r\n\r\n            // create bufferview and accessor for keyed values.\r\n            outputLength = animationData.outputs.length;\r\n            byteLength = dataAccessorType === AccessorType.VEC3 ? animationData.outputs.length * 12 : animationData.outputs.length * 16;\r\n\r\n            // check for in and out tangents\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  data view`);\r\n            bufferViews.push(bufferView);\r\n\r\n            animationData.outputs.forEach(function(output) {\r\n                output.forEach(function(entry) {\r\n                    binaryWriter.setFloat32(entry);\r\n                });\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  data`, dataAccessorType, AccessorComponentType.FLOAT, outputLength, null, null, null);\r\n            accessors.push(accessor);\r\n            dataAccessorIndex = accessors.length - 1;\r\n\r\n            // create sampler\r\n            animationSampler = {\r\n                interpolation: animationData.samplerInterpolation,\r\n                input: keyframeAccessorIndex,\r\n                output: dataAccessorIndex\r\n            };\r\n            glTFAnimation.samplers.push(animationSampler);\r\n\r\n            // create channel\r\n            animationChannel = {\r\n                sampler: glTFAnimation.samplers.length - 1,\r\n                target: {\r\n                    node: nodeIndex,\r\n                    path: animationChannelTargetPath\r\n                }\r\n            };\r\n            glTFAnimation.channels.push(animationChannel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a baked animation\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation corresponding to the BabylonJS mesh\r\n     * @param animationChannelTargetPath animation target channel\r\n     * @param minFrame minimum animation frame\r\n     * @param maxFrame maximum animation frame\r\n     * @param fps frames per second of the animation\r\n     * @param inputs input key frames of the animation\r\n     * @param outputs output key frame data of the animation\r\n     * @param convertToRightHandedSystem converts the values to right-handed\r\n     * @param useQuaternion specifies if quaternions should be used\r\n     */\r\n    private static _CreateBakedAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, minFrame: number, maxFrame: number, fps: number, sampleRate: number, inputs: number[], outputs: number[][], minMaxFrames: { min: number, max: number }, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let value: number | Vector3 | Quaternion;\r\n        let quaternionCache: Quaternion = Quaternion.Identity();\r\n        let previousTime: Nullable<number> = null;\r\n        let time: number;\r\n        let maxUsedFrame: Nullable<number> = null;\r\n        let currKeyFrame: Nullable<IAnimationKey> = null;\r\n        let nextKeyFrame: Nullable<IAnimationKey> = null;\r\n        let prevKeyFrame: Nullable<IAnimationKey> = null;\r\n        let endFrame: Nullable<number> = null;\r\n        minMaxFrames.min = Tools.FloatRound(minFrame / fps);\r\n\r\n        let keyFrames = animation.getKeys();\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            endFrame = null;\r\n            currKeyFrame = keyFrames[i];\r\n\r\n            if (i + 1 < length) {\r\n                nextKeyFrame = keyFrames[i + 1];\r\n                if (currKeyFrame.value.equals(nextKeyFrame.value)) {\r\n                    if (i === 0) { // set the first frame to itself\r\n                        endFrame = currKeyFrame.frame;\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    endFrame = nextKeyFrame.frame;\r\n                }\r\n            }\r\n            else {\r\n                // at the last key frame\r\n                prevKeyFrame = keyFrames[i - 1];\r\n                if (currKeyFrame.value.equals(prevKeyFrame.value)) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    endFrame = maxFrame;\r\n                }\r\n            }\r\n            if (endFrame) {\r\n                for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {\r\n                    time = Tools.FloatRound(f / fps);\r\n                    if (time === previousTime) {\r\n                        continue;\r\n                    }\r\n                    previousTime = time;\r\n                    maxUsedFrame = time;\r\n                    value = animation._interpolate(f, 0, undefined, animation.loopMode);\r\n\r\n                    _GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n                }\r\n            }\r\n        }\r\n        if (maxUsedFrame) {\r\n            minMaxFrames.max = maxUsedFrame;\r\n        }\r\n    }\r\n\r\n    private static _ConvertFactorToVector3OrQuaternion(factor: number, babylonTransformNode: TransformNode, animation: Animation, animationType: number, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean): Nullable<Vector3 | Quaternion> {\r\n        let property: string[];\r\n        let componentName: string;\r\n        let value: Nullable<Quaternion | Vector3> = null;\r\n        const basePositionRotationOrScale = _GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n        if (animationType === Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n            property = animation.targetProperty.split('.');\r\n            componentName = property ? property[1] : ''; // x, y, or z component\r\n            value = useQuaternion ? BABYLON.Quaternion.FromArray(basePositionRotationOrScale).normalize() : BABYLON.Vector3.FromArray(basePositionRotationOrScale);\r\n\r\n            switch (componentName) {\r\n                case 'x': {\r\n                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'y': {\r\n                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'z': {\r\n                    value[componentName] = (convertToRightHandedSystem && !useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'w': {\r\n                    (value as Quaternion).w = factor;\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`glTFAnimation: Unsupported component type \"${componentName}\" for scale animation!`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    private static _SetInterpolatedValue(babylonTransformNode: TransformNode, value: Nullable<number | Vector3 | Quaternion>, time: number, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, quaternionCache: Quaternion, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        const animationType = animation.dataType;\r\n        let cacheValue: Vector3 | Quaternion;\r\n        inputs.push(time);\r\n        if (typeof value === \"number\") {\r\n            value = this._ConvertFactorToVector3OrQuaternion(value as number, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n        if (value) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (useQuaternion) {\r\n                    quaternionCache = value as Quaternion;\r\n                }\r\n                else {\r\n                    cacheValue = value as Vector3;\r\n                    Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);\r\n                }\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedQuaternionFromRef(quaternionCache);\r\n\r\n                    if (!babylonTransformNode.parent) {\r\n                        quaternionCache = Quaternion.FromArray([0, 1, 0, 0]).multiply(quaternionCache);\r\n                    }\r\n                }\r\n                outputs.push(quaternionCache.asArray());\r\n            }\r\n            else {\r\n                cacheValue = value as Vector3;\r\n                if (convertToRightHandedSystem && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) {\r\n                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(cacheValue);\r\n                    if (!babylonTransformNode.parent) {\r\n                        cacheValue.x *= -1;\r\n                        cacheValue.z *= -1;\r\n                    }\r\n                }\r\n\r\n                outputs.push(cacheValue.asArray());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates linear animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateLinearOrStepAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, frameDelta: number, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        for (let keyFrame of animation.getKeys()) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates cubic spline animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateCubicSplineAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, frameDelta: number, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        animation.getKeys().forEach(function(keyFrame) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation.AddSplineTangent(\r\n                babylonTransformNode,\r\n                _TangentType.INTANGENT,\r\n                outputs,\r\n                animationChannelTargetPath,\r\n                AnimationSamplerInterpolation.CUBICSPLINE,\r\n                keyFrame,\r\n                frameDelta,\r\n                useQuaternion,\r\n                convertToRightHandedSystem\r\n            );\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);\r\n\r\n            _GLTFAnimation.AddSplineTangent(\r\n                babylonTransformNode,\r\n                _TangentType.OUTTANGENT,\r\n                outputs,\r\n                animationChannelTargetPath,\r\n                AnimationSamplerInterpolation.CUBICSPLINE,\r\n                keyFrame,\r\n                frameDelta,\r\n                useQuaternion,\r\n                convertToRightHandedSystem\r\n            );\r\n        });\r\n    }\r\n\r\n    private static _GetBasePositionRotationOrScale(babylonTransformNode: TransformNode, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let basePositionRotationOrScale: number[];\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                if (babylonTransformNode.rotationQuaternion) {\r\n                    basePositionRotationOrScale = babylonTransformNode.rotationQuaternion.asArray();\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(basePositionRotationOrScale);\r\n                        if (!babylonTransformNode.parent) {\r\n                            basePositionRotationOrScale = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(basePositionRotationOrScale)).asArray();\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    basePositionRotationOrScale = BABYLON.Quaternion.Identity().asArray();\r\n                }\r\n            }\r\n            else {\r\n                basePositionRotationOrScale = babylonTransformNode.rotation.asArray();\r\n                _GLTFUtilities._GetRightHandedNormalArray3FromRef(basePositionRotationOrScale);\r\n            }\r\n        }\r\n        else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n            basePositionRotationOrScale = babylonTransformNode.position.asArray();\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedPositionArray3FromRef(basePositionRotationOrScale);\r\n            }\r\n        }\r\n        else { // scale\r\n            basePositionRotationOrScale = babylonTransformNode.scaling.asArray();\r\n        }\r\n        return basePositionRotationOrScale;\r\n    }\r\n\r\n    /**\r\n     * Adds a key frame value\r\n     * @param keyFrame\r\n     * @param animation\r\n     * @param outputs\r\n     * @param animationChannelTargetPath\r\n     * @param basePositionRotationOrScale\r\n     * @param convertToRightHandedSystem\r\n     * @param useQuaternion\r\n     */\r\n    private static _AddKeyframeValue(keyFrame: IAnimationKey, animation: Animation, outputs: number[][], animationChannelTargetPath: AnimationChannelTargetPath, babylonTransformNode: TransformNode, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let value: number[];\r\n        let newPositionRotationOrScale: Nullable<Vector3 | Quaternion>;\r\n        const animationType = animation.dataType;\r\n        if (animationType === Animation.ANIMATIONTYPE_VECTOR3) {\r\n            value = keyFrame.value.asArray();\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                const array = Vector3.FromArray(value);\r\n                let rotationQuaternion = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n\r\n                    if (!babylonTransformNode.parent) {\r\n                        rotationQuaternion = Quaternion.FromArray([0, 1, 0, 0]).multiply(rotationQuaternion);\r\n                    }\r\n                }\r\n                value = rotationQuaternion.asArray();\r\n            }\r\n            else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedNormalArray3FromRef(value);\r\n                    if (!babylonTransformNode.parent) {\r\n                        value[0] *= -1;\r\n                        value[2] *= -1;\r\n                    }\r\n                }\r\n            }\r\n            outputs.push(value); // scale  vector.\r\n\r\n        }\r\n        else if (animationType === Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n            newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(keyFrame.value as number, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n            if (newPositionRotationOrScale) {\r\n                if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                    let posRotScale = useQuaternion ? newPositionRotationOrScale as Quaternion : Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionFromRef(posRotScale);\r\n\r\n                        if (!babylonTransformNode.parent) {\r\n                            posRotScale = Quaternion.FromArray([0, 1, 0, 0]).multiply(posRotScale);\r\n                        }\r\n                    }\r\n                    outputs.push(posRotScale.asArray());\r\n                }\r\n                else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(newPositionRotationOrScale as Vector3);\r\n\r\n                        if (!babylonTransformNode.parent) {\r\n                            newPositionRotationOrScale.x *= -1;\r\n                            newPositionRotationOrScale.z *= -1;\r\n                        }\r\n                    }\r\n                }\r\n                outputs.push(newPositionRotationOrScale.asArray());\r\n            }\r\n        }\r\n        else if (animationType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            value = (keyFrame.value as Quaternion).normalize().asArray();\r\n\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(value);\r\n\r\n                if (!babylonTransformNode.parent) {\r\n                    value = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(value)).asArray();\r\n                }\r\n            }\r\n\r\n            outputs.push(value);\r\n        }\r\n        else {\r\n            Tools.Error('glTFAnimation: Unsupported key frame values for animation!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine the interpolation based on the key frames\r\n     * @param keyFrames\r\n     * @param animationChannelTargetPath\r\n     * @param useQuaternion\r\n     */\r\n    private static _DeduceInterpolation(keyFrames: IAnimationKey[], animationChannelTargetPath: AnimationChannelTargetPath, useQuaternion: boolean): { interpolationType: AnimationSamplerInterpolation, shouldBakeAnimation: boolean } {\r\n        let interpolationType: AnimationSamplerInterpolation | undefined;\r\n        let shouldBakeAnimation = false;\r\n        let key: IAnimationKey;\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION && !useQuaternion) {\r\n            return { interpolationType: AnimationSamplerInterpolation.LINEAR, shouldBakeAnimation: true };\r\n        }\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            key = keyFrames[i];\r\n            if (key.inTangent || key.outTangent) {\r\n                if (interpolationType) {\r\n                    if (interpolationType !== AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    interpolationType = AnimationSamplerInterpolation.CUBICSPLINE;\r\n                }\r\n            }\r\n            else {\r\n                if (interpolationType) {\r\n                    if (interpolationType === AnimationSamplerInterpolation.CUBICSPLINE ||\r\n                        (key.interpolation && (key.interpolation === AnimationKeyInterpolation.STEP) && interpolationType !== AnimationSamplerInterpolation.STEP)) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (key.interpolation && (key.interpolation === AnimationKeyInterpolation.STEP)) {\r\n                        interpolationType = AnimationSamplerInterpolation.STEP;\r\n                    }\r\n                    else {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!interpolationType) {\r\n            interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n        }\r\n\r\n        return { interpolationType: interpolationType, shouldBakeAnimation: shouldBakeAnimation };\r\n    }\r\n\r\n    /**\r\n     * Adds an input tangent or output tangent to the output data\r\n     * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion\r\n     * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)\r\n     * @param outputs The animation data by keyframe\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param interpolation The interpolation type\r\n     * @param keyFrame The key frame with the animation data\r\n     * @param frameDelta Time difference between two frames used to scale the tangent by the frame delta\r\n     * @param useQuaternion Specifies if quaternions are used\r\n     * @param convertToRightHandedSystem Specifies if the values should be converted to right-handed\r\n     */\r\n    private static AddSplineTangent(babylonTransformNode: TransformNode, tangentType: _TangentType, outputs: number[][], animationChannelTargetPath: AnimationChannelTargetPath, interpolation: AnimationSamplerInterpolation, keyFrame: IAnimationKey, frameDelta: number, useQuaternion: boolean, convertToRightHandedSystem: boolean) {\r\n        let tangent: number[];\r\n        let tangentValue: Vector3 | Quaternion = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;\r\n        if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (tangentValue) {\r\n                    if (useQuaternion) {\r\n                        tangent = (tangentValue as Quaternion).scale(frameDelta).asArray();\r\n                    }\r\n                    else {\r\n                        const array = (tangentValue as Vector3).scale(frameDelta);\r\n                        tangent = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();\r\n                    }\r\n\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(tangent);\r\n                        if (!babylonTransformNode.parent) {\r\n                            tangent = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(tangent)).asArray();\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    tangent = [0, 0, 0, 0];\r\n                }\r\n            }\r\n            else {\r\n                if (tangentValue) {\r\n                    tangent = (tangentValue as Vector3).scale(frameDelta).asArray();\r\n                    if (convertToRightHandedSystem) {\r\n                        if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                            _GLTFUtilities._GetRightHandedPositionArray3FromRef(tangent);\r\n                            if (!babylonTransformNode.parent) {\r\n                                tangent[0] *= -1; // x\r\n                                tangent[2] *= -1; // z\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    tangent = [0, 0, 0];\r\n                }\r\n            }\r\n\r\n            outputs.push(tangent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the minimum and maximum key frames' frame values\r\n     * @param keyFrames animation key frames\r\n     * @returns the minimum and maximum key frame value\r\n     */\r\n    private static calculateMinMaxKeyFrames(keyFrames: IAnimationKey[]): { min: number, max: number } {\r\n        let min: number = Infinity;\r\n        let max: number = -Infinity;\r\n        keyFrames.forEach(function(keyFrame) {\r\n            min = Math.min(min, keyFrame.frame);\r\n            max = Math.max(max, keyFrame.frame);\r\n        });\r\n\r\n        return { min: min, max: max };\r\n\r\n    }\r\n}","import { ImageMimeType } from \"babylonjs-gltf2interface\";\r\n\r\n/**\r\n * Class for holding and downloading glTF file data\r\n */\r\nexport class GLTFData {\r\n    /**\r\n     * Object which contains the file name as the key and its data as the value\r\n     */\r\n    glTFFiles: { [fileName: string]: string | Blob };\r\n\r\n    /**\r\n     * Initializes the glTF file object\r\n     */\r\n    public constructor() {\r\n        this.glTFFiles = {};\r\n    }\r\n\r\n    /**\r\n     * Downloads the glTF data as files based on their names and data\r\n     */\r\n    public downloadFiles(): void {\r\n        /**\r\n        * Checks for a matching suffix at the end of a string (for ES5 and lower)\r\n        * @param str Source string\r\n        * @param suffix Suffix to search for in the source string\r\n        * @returns Boolean indicating whether the suffix was found (true) or not (false)\r\n        */\r\n        function endsWith(str: string, suffix: string): boolean {\r\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n        }\r\n\r\n        for (let key in this.glTFFiles) {\r\n            let link = document.createElement('a');\r\n            document.body.appendChild(link);\r\n            link.setAttribute(\"type\", \"hidden\");\r\n            link.download = key;\r\n            let blob = this.glTFFiles[key];\r\n            let mimeType;\r\n\r\n            if (endsWith(key, \".glb\")) {\r\n                mimeType = { type: \"model/gltf-binary\" };\r\n            }\r\n            else if (endsWith(key, \".bin\")) {\r\n                mimeType = { type: \"application/octet-stream\" };\r\n            }\r\n            else if (endsWith(key, \".gltf\")) {\r\n                mimeType = { type: \"model/gltf+json\" };\r\n            }\r\n            else if (endsWith(key, \".jpeg\" || \".jpg\")) {\r\n                mimeType = {type: ImageMimeType.JPEG};\r\n            }\r\n            else if (endsWith(key, \".png\")) {\r\n                mimeType = {type: ImageMimeType.PNG};\r\n            }\r\n\r\n            link.href = window.URL.createObjectURL(new Blob([blob], mimeType));\r\n            link.click();\r\n        }\r\n    }\r\n}\r\n","import { Nullable, Color3, Scalar, Material, StandardMaterial, PBRMetallicRoughnessMaterial, PBRMaterial, Tools, Engine, Scene, Texture, PostProcess, RawTexture, BaseTexture, TextureTools } from \"babylonjs\";\r\nimport { ITextureInfo, ImageMimeType, IMaterial, IMaterialPbrMetallicRoughness, MaterialAlphaMode, IMaterialOcclusionTextureInfo, ISampler, TextureMagFilter, TextureMinFilter, TextureWrapMode, ITexture, IImage } from \"babylonjs-gltf2interface\";\r\nimport { _Exporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @hidden\r\n */\r\ninterface _IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n    */\r\n    diffuseColor: BABYLON.Color3;\r\n    /**\r\n     * Represents the linear specular factors of the material\r\n    */\r\n    specularColor: BABYLON.Color3;\r\n    /**\r\n     * Represents the smoothness of the material\r\n    */\r\n    glossiness: number;\r\n}\r\n\r\n/**\r\n * Interface for storing metallic roughness factors\r\n * @hidden\r\n */\r\ninterface _IPBRMetallicRoughness {\r\n    /**\r\n     * Represents the albedo color of the material\r\n    */\r\n    baseColor: BABYLON.Color3;\r\n    /**\r\n     * Represents the metallness of the material\r\n    */\r\n    metallic: Nullable<number>;\r\n    /**\r\n     * Represents the roughness of the material\r\n    */\r\n    roughness: Nullable<number>;\r\n    /**\r\n     * The metallic roughness texture as a base64 string\r\n    */\r\n    metallicRoughnessTextureBase64?: Nullable<string>;\r\n    /**\r\n     * The base color texture as a base64 string\r\n    */\r\n    baseColorTextureBase64?: Nullable<string>;\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.  This class should only be used internally\r\n * @hidden\r\n */\r\nexport class _GLTFMaterialExporter {\r\n    /**\r\n     * Represents the dielectric specular values for R, G and B\r\n     */\r\n    private static readonly _DielectricSpecular: Color3 = new Color3(0.04, 0.04, 0.04);\r\n\r\n    /**\r\n     * Allows the maximum specular power to be defined for material calculations\r\n     */\r\n    private static readonly _MaxSpecularPower = 1024;\r\n\r\n    /**\r\n     * Mapping to store textures\r\n     */\r\n    private _textureMap: { [textureId: string]: ITextureInfo } = {};\r\n\r\n    /**\r\n     * Numeric tolerance value\r\n     */\r\n    private static readonly _Epsilon = 1e-6;\r\n\r\n    /**\r\n     * Reference to the glTF Exporter\r\n     */\r\n    private _exporter: _Exporter;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._textureMap = {};\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /**\r\n     * Specifies if two colors are approximately equal in value\r\n     * @param color1 first color to compare to\r\n     * @param color2 second color to compare to\r\n     * @param epsilon threshold value\r\n     */\r\n    private static FuzzyEquals(color1: Color3, color2: Color3, epsilon: number): boolean {\r\n        return Scalar.WithinEpsilon(color1.r, color2.r, epsilon) &&\r\n            Scalar.WithinEpsilon(color1.g, color2.g, epsilon) &&\r\n            Scalar.WithinEpsilon(color1.b, color2.b, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Gets the materials from a Babylon scene and converts them to glTF materials\r\n     * @param scene babylonjs scene\r\n     * @param mimeType texture mime type\r\n     * @param images array of images\r\n     * @param textures array of textures\r\n     * @param materials array of materials\r\n     * @param imageData mapping of texture names to base64 textures\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the material\r\n     */\r\n    public _convertMaterialsToGLTFAsync(babylonMaterials: Material[], mimeType: ImageMimeType, hasTextureCoords: boolean) {\r\n        let promises: Promise<void>[] = [];\r\n        for (let babylonMaterial of babylonMaterials) {\r\n            if (babylonMaterial instanceof StandardMaterial) {\r\n                promises.push(this._convertStandardMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else if (babylonMaterial instanceof PBRMetallicRoughnessMaterial) {\r\n                promises.push(this._convertPBRMetallicRoughnessMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else if (babylonMaterial instanceof PBRMaterial) {\r\n                promises.push(this._convertPBRMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else {\r\n                Tools.Warn(`Unsupported material type: ${babylonMaterial.name}`);\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { /* do nothing */ });\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the glTF material without the texture parameters\r\n     * @param originalMaterial original glTF material\r\n     * @returns glTF material without texture parameters\r\n     */\r\n    public _stripTexturesFromMaterial(originalMaterial: IMaterial): IMaterial {\r\n        let newMaterial: IMaterial = {};\r\n        if (originalMaterial) {\r\n            newMaterial.name = originalMaterial.name;\r\n            newMaterial.doubleSided = originalMaterial.doubleSided;\r\n            newMaterial.alphaMode = originalMaterial.alphaMode;\r\n            newMaterial.alphaCutoff = originalMaterial.alphaCutoff;\r\n            newMaterial.emissiveFactor = originalMaterial.emissiveFactor;\r\n            const originalPBRMetallicRoughness = originalMaterial.pbrMetallicRoughness;\r\n            if (originalPBRMetallicRoughness) {\r\n                newMaterial.pbrMetallicRoughness = {};\r\n                newMaterial.pbrMetallicRoughness.baseColorFactor = originalPBRMetallicRoughness.baseColorFactor;\r\n                newMaterial.pbrMetallicRoughness.metallicFactor = originalPBRMetallicRoughness.metallicFactor;\r\n                newMaterial.pbrMetallicRoughness.roughnessFactor = originalPBRMetallicRoughness.roughnessFactor;\r\n            }\r\n        }\r\n        return newMaterial;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material has any texture parameters present\r\n     * @param material glTF Material\r\n     * @returns boolean specifying if texture parameters are present\r\n     */\r\n    public _hasTexturesPresent(material: IMaterial): boolean {\r\n        if (material.emissiveTexture || material.normalTexture || material.occlusionTexture) {\r\n            return true;\r\n        }\r\n        const pbrMat = material.pbrMetallicRoughness;\r\n        if (pbrMat) {\r\n            if (pbrMat.baseColorTexture || pbrMat.metallicRoughnessTexture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon StandardMaterial to a glTF Metallic Roughness Material\r\n     * @param babylonStandardMaterial\r\n     * @returns glTF Metallic Roughness Material representation\r\n     */\r\n    public _convertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n        const P0 = new BABYLON.Vector2(0, 1);\r\n        const P1 = new BABYLON.Vector2(0, 0.1);\r\n        const P2 = new BABYLON.Vector2(0, 0.1);\r\n        const P3 = new BABYLON.Vector2(1300, 0.1);\r\n\r\n        /**\r\n         * Given the control points, solve for x based on a given t for a cubic bezier curve\r\n         * @param t a value between 0 and 1\r\n         * @param p0 first control point\r\n         * @param p1 second control point\r\n         * @param p2 third control point\r\n         * @param p3 fourth control point\r\n         * @returns number result of cubic bezier curve at the specified t\r\n         */\r\n        function _cubicBezierCurve(t: number, p0: number, p1: number, p2: number, p3: number): number {\r\n            return (\r\n                (1 - t) * (1 - t) * (1 - t) * p0 +\r\n                3 * (1 - t) * (1 - t) * t * p1 +\r\n                3 * (1 - t) * t * t * p2 +\r\n                t * t * t * p3\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Evaluates a specified specular power value to determine the appropriate roughness value,\r\n         * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)\r\n         * and roughness on the ordinant axis (y-axis)\r\n         * @param specularPower specular power of standard material\r\n         * @returns Number representing the roughness value\r\n         */\r\n        function _solveForRoughness(specularPower: number): number {\r\n            var t = Math.pow(specularPower / P3.x, 0.333333);\r\n            return _cubicBezierCurve(t, P0.y, P1.y, P2.y, P3.y);\r\n        }\r\n\r\n        let diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace().scale(0.5);\r\n        let opacity = babylonStandardMaterial.alpha;\r\n        let specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, _GLTFMaterialExporter._MaxSpecularPower);\r\n\r\n        const roughness = _solveForRoughness(specularPower);\r\n\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n            baseColorFactor: [\r\n                diffuse.r,\r\n                diffuse.g,\r\n                diffuse.b,\r\n                opacity\r\n            ],\r\n            metallicFactor: 0,\r\n            roughnessFactor: roughness,\r\n        };\r\n\r\n        return glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Computes the metallic factor\r\n     * @param diffuse diffused value\r\n     * @param specular specular value\r\n     * @param oneMinusSpecularStrength one minus the specular strength\r\n     * @returns metallic value\r\n     */\r\n    public static _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n        if (specular < this._DielectricSpecular.r) {\r\n            this._DielectricSpecular;\r\n            return 0;\r\n        }\r\n\r\n        const a = this._DielectricSpecular.r;\r\n        const b = diffuse * oneMinusSpecularStrength / (1.0 - this._DielectricSpecular.r) + specular - 2.0 * this._DielectricSpecular.r;\r\n        const c = this._DielectricSpecular.r - specular;\r\n        const D = b * b - 4.0 * a * c;\r\n        return BABYLON.Scalar.Clamp((-b + Math.sqrt(D)) / (2.0 * a), 0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the glTF alpha mode from the Babylon Material\r\n     * @param babylonMaterial Babylon Material\r\n     * @returns The Babylon alpha mode value\r\n     */\r\n    public _getAlphaMode(babylonMaterial: Material): MaterialAlphaMode {\r\n        if (babylonMaterial.needAlphaBlending()) {\r\n            return MaterialAlphaMode.BLEND;\r\n        }\r\n        else if (babylonMaterial.needAlphaTesting()) {\r\n            return MaterialAlphaMode.MASK;\r\n        }\r\n        else {\r\n            return MaterialAlphaMode.OPAQUE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon Standard Material to a glTF Material\r\n     * @param babylonStandardMaterial BJS Standard Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<void> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        const alphaMode = this._getAlphaMode(babylonStandardMaterial);\r\n        let promises = [];\r\n        const glTFPbrMetallicRoughness = this._convertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const glTFMaterial: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            glTFMaterial.doubleSided = true;\r\n        }\r\n        if (hasTextureCoords) {\r\n            if (babylonStandardMaterial.diffuseTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.diffuseTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.bumpTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.normalTexture = glTFTexture;\r\n                        if (babylonStandardMaterial.bumpTexture != null && babylonStandardMaterial.bumpTexture.level !== 1) {\r\n                            glTFMaterial.normalTexture.scale = babylonStandardMaterial.bumpTexture.level;\r\n                        }\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.emissiveTexture) {\r\n                glTFMaterial.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.emissiveTexture, mimeType).then((glTFEmissiveTexture) => {\r\n                    if (glTFEmissiveTexture) {\r\n                        glTFMaterial.emissiveTexture = glTFEmissiveTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.ambientTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                            index: glTFTexture.index\r\n                        };\r\n                        glTFMaterial.occlusionTexture = occlusionTexture;\r\n                        occlusionTexture.strength = 1.0;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Engine.ALPHA_COMBINE) {\r\n                glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n            }\r\n            else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n        if (babylonStandardMaterial.emissiveColor && !_GLTFMaterialExporter.FuzzyEquals(babylonStandardMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n        if (alphaMode !== MaterialAlphaMode.OPAQUE) {\r\n            switch (alphaMode) {\r\n                case MaterialAlphaMode.BLEND: {\r\n                    glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n                    break;\r\n                }\r\n                case MaterialAlphaMode.MASK: {\r\n                    glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n                    glTFMaterial.alphaCutoff = babylonStandardMaterial.alphaCutOff;\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Warn(`Unsupported alpha mode ${alphaMode}`);\r\n                }\r\n            }\r\n        }\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonStandardMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return Promise.all(promises).then(() => { /* do nothing */ });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material\r\n     * @param babylonPBRMetalRoughMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMetallicRoughnessMaterialAsync(babylonPBRMetalRoughMaterial: PBRMetallicRoughnessMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<void> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        let promises: Promise<void>[] = [];\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n\r\n        if (babylonPBRMetalRoughMaterial.baseColor) {\r\n            glTFPbrMetallicRoughness.baseColorFactor = [\r\n                babylonPBRMetalRoughMaterial.baseColor.r,\r\n                babylonPBRMetalRoughMaterial.baseColor.g,\r\n                babylonPBRMetalRoughMaterial.baseColor.b,\r\n                babylonPBRMetalRoughMaterial.alpha\r\n            ];\r\n        }\r\n\r\n        if (babylonPBRMetalRoughMaterial.metallic != null && babylonPBRMetalRoughMaterial.metallic !== 1) {\r\n            glTFPbrMetallicRoughness.metallicFactor = babylonPBRMetalRoughMaterial.metallic;\r\n        }\r\n        if (babylonPBRMetalRoughMaterial.roughness != null && babylonPBRMetalRoughMaterial.roughness !== 1) {\r\n            glTFPbrMetallicRoughness.roughnessFactor = babylonPBRMetalRoughMaterial.roughness;\r\n        }\r\n\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMetalRoughMaterial.name\r\n        };\r\n        if (babylonPBRMetalRoughMaterial.doubleSided) {\r\n            glTFMaterial.doubleSided = babylonPBRMetalRoughMaterial.doubleSided;\r\n        }\r\n        let alphaMode: Nullable<MaterialAlphaMode> = null;\r\n        if (babylonPBRMetalRoughMaterial.transparencyMode != null) {\r\n            alphaMode = this._getAlphaMode(babylonPBRMetalRoughMaterial);\r\n            if (alphaMode) {\r\n                if (alphaMode !== MaterialAlphaMode.OPAQUE) { //glTF defaults to opaque\r\n                    glTFMaterial.alphaMode = alphaMode;\r\n                    if (alphaMode === MaterialAlphaMode.MASK) {\r\n                        glTFMaterial.alphaCutoff = babylonPBRMetalRoughMaterial.alphaCutOff;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (hasTextureCoords) {\r\n            if (babylonPBRMetalRoughMaterial.baseTexture != null) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.baseTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.normalTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.normalTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.normalTexture = glTFTexture;\r\n                        if (babylonPBRMetalRoughMaterial.normalTexture.level !== 1) {\r\n                            glTFMaterial.normalTexture.scale = babylonPBRMetalRoughMaterial.normalTexture.level;\r\n                        }\r\n                    }\r\n                }));\r\n\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.occlusionTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.occlusionTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.occlusionTexture = glTFTexture;\r\n                        if (babylonPBRMetalRoughMaterial.occlusionStrength != null) {\r\n                            glTFMaterial.occlusionTexture.strength = babylonPBRMetalRoughMaterial.occlusionStrength;\r\n                        }\r\n                    }\r\n                }));\r\n\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.emissiveTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.emissiveTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.emissiveTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n\r\n        }\r\n\r\n        if (_GLTFMaterialExporter.FuzzyEquals(babylonPBRMetalRoughMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonPBRMetalRoughMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonPBRMetalRoughMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return Promise.all(promises).then(() => { /* do nothing */ });\r\n    }\r\n\r\n    /**\r\n     * Converts an image typed array buffer to a base64 image\r\n     * @param buffer typed array buffer\r\n     * @param width width of the image\r\n     * @param height height of the image\r\n     * @param mimeType mimetype of the image\r\n     * @returns base64 image string\r\n     */\r\n    private _createBase64FromCanvasAsync(buffer: Uint8Array | Float32Array, width: number, height: number, mimeType: ImageMimeType): Promise<string> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            let hostingScene: Scene;\r\n\r\n            const textureType = Engine.TEXTURETYPE_UNSIGNED_INT;\r\n            const engine = this._exporter._getLocalEngine();\r\n\r\n            hostingScene = new Scene(engine);\r\n\r\n            // Create a temporary texture with the texture buffer data\r\n            const tempTexture = engine.createRawTexture(buffer, width, height, Engine.TEXTUREFORMAT_RGBA, false, true, Texture.NEAREST_SAMPLINGMODE, null, textureType);\r\n            const postProcess = new PostProcess(\"pass\", \"pass\", null, null, 1, null, Texture.NEAREST_SAMPLINGMODE, engine, false, undefined, Engine.TEXTURETYPE_UNSIGNED_INT, undefined, null, false);\r\n            postProcess.getEffect().executeWhenCompiled(() => {\r\n                postProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", tempTexture);\r\n                };\r\n\r\n                // Set the size of the texture\r\n                engine.setSize(width, height);\r\n                hostingScene.postProcessManager.directRender([postProcess], null);\r\n                postProcess.dispose();\r\n                tempTexture.dispose();\r\n\r\n                // Read data from WebGL\r\n                const canvas = engine.getRenderingCanvas();\r\n\r\n                if (canvas) {\r\n                    if (!canvas.toBlob) { // fallback for browsers without \"canvas.toBlob\"\r\n                        const dataURL = canvas.toDataURL();\r\n                        resolve(dataURL);\r\n                    }\r\n                    else {\r\n                        BABYLON.Tools.ToBlob(canvas, (blob) => {\r\n                            if (blob) {\r\n                                let fileReader = new FileReader();\r\n                                fileReader.onload = (event: any) => {\r\n                                    let base64String = event.target.result as string;\r\n                                    hostingScene.dispose();\r\n                                    resolve(base64String);\r\n                                };\r\n                                fileReader.readAsDataURL(blob);\r\n                            }\r\n                            else {\r\n                                reject(\"gltfMaterialExporter: Failed to get blob from image canvas!\");\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    reject(\"Engine is missing a canvas!\");\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a white texture based on the specified width and height\r\n     * @param width width of the texture in pixels\r\n     * @param height height of the texture in pixels\r\n     * @param scene babylonjs scene\r\n     * @returns white texture\r\n     */\r\n    private _createWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n        const data = new Uint8Array(width * height * 4);\r\n\r\n        for (let i = 0; i < data.length; i = i + 4) {\r\n            data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xFF;\r\n        }\r\n\r\n        const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n        return rawTexture;\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: BaseTexture, texture2: BaseTexture, scene: Scene): { \"texture1\": BaseTexture, \"texture2\": BaseTexture } {\r\n        let texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        let texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1;\r\n        let resizedTexture2;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            }\r\n            else {\r\n                resizedTexture1 = this._createWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2;\r\n        }\r\n        else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            }\r\n            else {\r\n                resizedTexture2 = this._createWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1;\r\n        }\r\n        else {\r\n            resizedTexture1 = texture1;\r\n            resizedTexture2 = texture2;\r\n        }\r\n\r\n        return {\r\n            \"texture1\": resizedTexture1,\r\n            \"texture2\": resizedTexture2\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts an array of pixels to a Float32Array\r\n     * Throws an error if the pixel format is not supported\r\n     * @param pixels - array buffer containing pixel values\r\n     * @returns Float32 of pixels\r\n     */\r\n    private _convertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n        if (pixels instanceof Uint8Array) {\r\n            const length = pixels.length;\r\n            const buffer = new Float32Array(pixels.length);\r\n            for (let i = 0; i < length; ++i) {\r\n                buffer[i] = pixels[i] / 255;\r\n            }\r\n            return buffer;\r\n        }\r\n        else if (pixels instanceof Float32Array) {\r\n            return pixels;\r\n        }\r\n        else {\r\n            throw new Error('Unsupported pixel format!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(diffuseTexture: BaseTexture, specularGlossinessTexture: BaseTexture, factors: _IPBRSpecularGlossiness, mimeType: ImageMimeType): Promise<_IPBRMetallicRoughness> {\r\n        let promises = [];\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return Promise.reject('_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!');\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            let diffuseSize = resizedTextures.texture1.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            let diffusePixels = resizedTextures.texture1.readPixels();\r\n            let specularPixels = resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = this._convertPixelArrayToFloat32(diffusePixels);\r\n            }\r\n            else {\r\n                return Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = this._convertPixelArrayToFloat32(specularPixels);\r\n            }\r\n            else {\r\n                return Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = Color3.Black();\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2]).toLinearSpace().multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2]).toLinearSpace().multiply(factors.specularColor);\r\n                    const glossiness = (specularGlossinessBuffer[offset + 3]) * factors.glossiness;\r\n\r\n                    const specularGlossiness: _IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: _IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(baseColorBuffer[destinationOffset], baseColorBuffer[destinationOffset + 1], baseColorBuffer[destinationOffset + 2]);\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace();\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!_GLTFMaterialExporter.FuzzyEquals(sRGBBaseColorPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!_GLTFMaterialExporter.FuzzyEquals(metallicRoughnessPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                let promise = this._createBase64FromCanvasAsync(metallicRoughnessBuffer, width, height, mimeType).then((metallicRoughnessBase64) => {\r\n                    metallicRoughnessFactors.metallicRoughnessTextureBase64 = metallicRoughnessBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                let promise = this._createBase64FromCanvasAsync(baseColorBuffer, width, height, mimeType).then((baseColorBase64) => {\r\n                    metallicRoughnessFactors.baseColorTextureBase64 = baseColorBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        }\r\n        else {\r\n            return Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: _IPBRSpecularGlossiness): _IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _GLTFMaterialExporter._SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1.0 - _GLTFMaterialExporter._DielectricSpecular.r) / Math.max(1 - metallic, _GLTFMaterialExporter._Epsilon));\r\n        const baseColorFromSpecular = specularGlossiness.specularColor.subtract(_GLTFMaterialExporter._DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic, _GLTFMaterialExporter._Epsilon));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        if (color) {\r\n            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        if (color) {\r\n            return Math.max(color.r, Math.max(color.g, color.b));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, hasTextureCoords: boolean): Promise<_IPBRMetallicRoughness> {\r\n        const promises = [];\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: babylonPBRMaterial.albedoColor,\r\n            metallic: babylonPBRMaterial.metallic,\r\n            roughness: babylonPBRMaterial.roughness\r\n        };\r\n\r\n        if (hasTextureCoords) {\r\n            if (babylonPBRMaterial.albedoTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMaterial.albedoTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonPBRMaterial.metallicTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMaterial.metallicTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            return metallicRoughness;\r\n        });\r\n    }\r\n\r\n    private _getGLTFTextureSampler(texture: BaseTexture): ISampler {\r\n        const sampler = this._getGLTFTextureWrapModesSampler(texture);\r\n\r\n        let samplingMode = texture instanceof Texture ? texture.samplingMode : null;\r\n        if (samplingMode != null) {\r\n            switch (samplingMode) {\r\n                case Texture.LINEAR_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGLTFTextureWrapModesSampler(texture: BaseTexture): ISampler {\r\n        let wrapS = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapU : Texture.WRAP_ADDRESSMODE);\r\n        let wrapT = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapV : Texture.WRAP_ADDRESSMODE);\r\n\r\n        if (wrapS === TextureWrapMode.REPEAT && wrapT === TextureWrapMode.REPEAT) { // default wrapping mode in glTF, so omitting\r\n            return {};\r\n        }\r\n\r\n        return { wrapS: wrapS, wrapT: wrapT };\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, hasTextureCoords: boolean): Promise<_IPBRMetallicRoughness> {\r\n        return Promise.resolve().then(() => {\r\n            const samplers = this._exporter._samplers;\r\n            const textures = this._exporter._textures;\r\n            const specGloss: _IPBRSpecularGlossiness = {\r\n                diffuseColor: babylonPBRMaterial.albedoColor || Color3.White(),\r\n                specularColor: babylonPBRMaterial.reflectivityColor || Color3.White(),\r\n                glossiness: babylonPBRMaterial.microSurface || 1,\r\n            };\r\n            let samplerIndex: Nullable<number> = null;\r\n            const sampler = this._getGLTFTextureSampler(babylonPBRMaterial.albedoTexture);\r\n            if (sampler.magFilter != null && sampler.minFilter != null && sampler.wrapS != null && sampler.wrapT != null) {\r\n                samplers.push(sampler);\r\n                samplerIndex = samplers.length - 1;\r\n            }\r\n            if (babylonPBRMaterial.reflectivityTexture && !babylonPBRMaterial.useMicroSurfaceFromReflectivityMapAlpha) {\r\n                return Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n            }\r\n            if ((babylonPBRMaterial.albedoTexture || babylonPBRMaterial.reflectivityTexture) && hasTextureCoords) {\r\n                return this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(babylonPBRMaterial.albedoTexture, babylonPBRMaterial.reflectivityTexture, specGloss, mimeType).then((metallicRoughnessFactors) => {\r\n                    if (metallicRoughnessFactors.baseColorTextureBase64) {\r\n                        const glTFBaseColorTexture = this._getTextureInfoFromBase64(metallicRoughnessFactors.baseColorTextureBase64, \"bjsBaseColorTexture_\" + (textures.length) + \".png\", mimeType, babylonPBRMaterial.albedoTexture ? babylonPBRMaterial.albedoTexture.coordinatesIndex : null, samplerIndex);\r\n                        if (glTFBaseColorTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFBaseColorTexture;\r\n                        }\r\n                    }\r\n                    if (metallicRoughnessFactors.metallicRoughnessTextureBase64) {\r\n                        const glTFMRColorTexture = this._getTextureInfoFromBase64(metallicRoughnessFactors.metallicRoughnessTextureBase64, \"bjsMetallicRoughnessTexture_\" + (textures.length) + \".png\", mimeType, babylonPBRMaterial.reflectivityTexture ? babylonPBRMaterial.reflectivityTexture.coordinatesIndex : null, samplerIndex);\r\n                        if (glTFMRColorTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFMRColorTexture;\r\n                        }\r\n                    }\r\n\r\n                    return metallicRoughnessFactors;\r\n                });\r\n            }\r\n            else {\r\n                return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMaterialAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<void> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name\r\n        };\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            if (babylonPBRMaterial.albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [\r\n                    babylonPBRMaterial.albedoColor.r,\r\n                    babylonPBRMaterial.albedoColor.g,\r\n                    babylonPBRMaterial.albedoColor.b,\r\n                    babylonPBRMaterial.alpha\r\n                ];\r\n            }\r\n            return this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n        else {\r\n            return this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n    }\r\n\r\n    private setMetallicRoughnessPbrMaterial(metallicRoughness: Nullable<_IPBRMetallicRoughness>, babylonPBRMaterial: PBRMaterial, glTFMaterial: IMaterial, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<void> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        let promises = [];\r\n        if (metallicRoughness) {\r\n            let alphaMode: Nullable<MaterialAlphaMode> = null;\r\n            if (babylonPBRMaterial.transparencyMode != null) {\r\n                alphaMode = this._getAlphaMode(babylonPBRMaterial);\r\n                if (alphaMode) {\r\n                    if (alphaMode !== MaterialAlphaMode.OPAQUE) { //glTF defaults to opaque\r\n                        glTFMaterial.alphaMode = alphaMode;\r\n                        if (alphaMode === MaterialAlphaMode.MASK) {\r\n                            glTFMaterial.alphaCutoff = babylonPBRMaterial.alphaCutOff;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!(_GLTFMaterialExporter.FuzzyEquals(metallicRoughness.baseColor, Color3.White(), _GLTFMaterialExporter._Epsilon) && babylonPBRMaterial.alpha >= _GLTFMaterialExporter._Epsilon)) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [\r\n                    metallicRoughness.baseColor.r,\r\n                    metallicRoughness.baseColor.g,\r\n                    metallicRoughness.baseColor.b,\r\n                    babylonPBRMaterial.alpha\r\n                ];\r\n            }\r\n\r\n            if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n                glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n            }\r\n            if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n                glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n            }\r\n\r\n            if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n                if (!babylonPBRMaterial.twoSidedLighting) {\r\n                    Tools.Warn(babylonPBRMaterial.name + \": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.\");\r\n                }\r\n                glTFMaterial.doubleSided = true;\r\n            }\r\n\r\n            if (hasTextureCoords) {\r\n                if (babylonPBRMaterial.bumpTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (babylonPBRMaterial.bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = babylonPBRMaterial.bumpTexture.level;\r\n                            }\r\n                        }\r\n                    }\r\n                    );\r\n                    promises.push(promise);\r\n\r\n                }\r\n                if (babylonPBRMaterial.ambientTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            let occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n\r\n                            if (babylonPBRMaterial.ambientTextureStrength) {\r\n                                occlusionTexture.strength = babylonPBRMaterial.ambientTextureStrength;\r\n                            }\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n\r\n                }\r\n                if (babylonPBRMaterial.emissiveTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.emissiveTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n            }\r\n            if (!_GLTFMaterialExporter.FuzzyEquals(babylonPBRMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n                glTFMaterial.emissiveFactor = babylonPBRMaterial.emissiveColor.asArray();\r\n            }\r\n\r\n            glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n            materials.push(glTFMaterial);\r\n            materialMap[babylonPBRMaterial.uniqueId] = materials.length - 1;\r\n        }\r\n        return Promise.all(promises).then((result) => { /* do nothing */ });\r\n    }\r\n\r\n    private getPixelsFromTexture(babylonTexture: BaseTexture): Uint8Array | Float32Array {\r\n        const pixels = babylonTexture.textureType === Engine.TEXTURETYPE_UNSIGNED_INT ? babylonTexture.readPixels() as Uint8Array : babylonTexture.readPixels() as Float32Array;\r\n        return pixels;\r\n    }\r\n\r\n    /**\r\n     * Extracts a texture from a Babylon texture into file data and glTF data\r\n     * @param babylonTexture Babylon texture to extract\r\n     * @param mimeType Mime Type of the babylonTexture\r\n     * @return glTF texture info, or null if the texture format is not supported\r\n     */\r\n    public _exportTextureAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const extensionPromise = this._exporter._extensionsPreExportTextureAsync(\"exporter\", babylonTexture as Texture, mimeType);\r\n        if (!extensionPromise) {\r\n            return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n        }\r\n\r\n        return extensionPromise.then((texture) => {\r\n            if (!texture) {\r\n                return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n            }\r\n            return this._exportTextureInfoAsync(texture, mimeType);\r\n        });\r\n    }\r\n\r\n    public _exportTextureInfoAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        return Promise.resolve().then(() => {\r\n            const textureUid = babylonTexture.uid;\r\n            if (textureUid in this._textureMap) {\r\n                return this._textureMap[textureUid];\r\n            }\r\n            else {\r\n                const samplers = this._exporter._samplers;\r\n                const sampler = this._getGLTFTextureSampler(babylonTexture);\r\n                let samplerIndex: Nullable<number> = null;\r\n\r\n                //  if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n                let foundSamplerIndex: Nullable<number> = null;\r\n                for (let i = 0; i < samplers.length; ++i) {\r\n                    let s = samplers[i];\r\n                    if (s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter &&\r\n                        s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT) {\r\n                        foundSamplerIndex = i;\r\n                        break;\r\n                    }\r\n                }\r\n                if (foundSamplerIndex == null) {\r\n                    samplers.push(sampler);\r\n                    samplerIndex = samplers.length - 1;\r\n                }\r\n                else {\r\n                    samplerIndex = foundSamplerIndex;\r\n                }\r\n                const pixels = this.getPixelsFromTexture(babylonTexture);\r\n                const size = babylonTexture.getSize();\r\n\r\n                return this._createBase64FromCanvasAsync(pixels, size.width, size.height, mimeType).then((base64Data) => {\r\n                    const textureInfo = this._getTextureInfoFromBase64(base64Data, babylonTexture.name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\"), mimeType, babylonTexture.coordinatesIndex, samplerIndex);\r\n                    if (textureInfo) {\r\n                        this._textureMap[textureUid] = textureInfo;\r\n                    }\r\n                    return textureInfo;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Builds a texture from base64 string\r\n     * @param base64Texture base64 texture string\r\n     * @param baseTextureName Name to use for the texture\r\n     * @param mimeType image mime type for the texture\r\n     * @param images array of images\r\n     * @param textures array of textures\r\n     * @param imageData map of image data\r\n     * @returns glTF texture info, or null if the texture format is not supported\r\n     */\r\n    private _getTextureInfoFromBase64(base64Texture: string, baseTextureName: string, mimeType: ImageMimeType, texCoordIndex: Nullable<number>, samplerIndex: Nullable<number>): Nullable<ITextureInfo> {\r\n        const textures = this._exporter._textures;\r\n        const images = this._exporter._images;\r\n        const imageData = this._exporter._imageData;\r\n        let textureInfo: Nullable<ITextureInfo> = null;\r\n\r\n        const glTFTexture: ITexture = {\r\n            source: images.length,\r\n            name: baseTextureName\r\n        };\r\n        if (samplerIndex != null) {\r\n            glTFTexture.sampler = samplerIndex;\r\n        }\r\n\r\n        const binStr = atob(base64Texture.split(',')[1]);\r\n        let arrBuff = new ArrayBuffer(binStr.length);\r\n        const arr = new Uint8Array(arrBuff);\r\n        for (let i = 0, length = binStr.length; i < length; ++i) {\r\n            arr[i] = binStr.charCodeAt(i);\r\n        }\r\n        const imageValues = { data: arr, mimeType: mimeType };\r\n\r\n        let extension = mimeType === ImageMimeType.JPEG ? '.jpeg' : '.png';\r\n        let textureName = baseTextureName + extension;\r\n        if (textureName in imageData) {\r\n            textureName = `${baseTextureName}_${Tools.RandomId()}${extension}`;\r\n        }\r\n\r\n        imageData[textureName] = imageValues;\r\n        if (mimeType === ImageMimeType.JPEG || mimeType === ImageMimeType.PNG) {\r\n            const glTFImage: IImage = {\r\n                name: baseTextureName,\r\n                uri: textureName\r\n            };\r\n            let foundIndex: Nullable<number> = null;\r\n            for (let i = 0; i < images.length; ++i) {\r\n                if (images[i].uri === textureName) {\r\n                    foundIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n            if (foundIndex == null) {\r\n                images.push(glTFImage);\r\n                glTFTexture.source = images.length - 1;\r\n            }\r\n            else {\r\n                glTFTexture.source = foundIndex;\r\n\r\n            }\r\n            textures.push(glTFTexture);\r\n            textureInfo = {\r\n                index: textures.length - 1\r\n            };\r\n            if (texCoordIndex != null) {\r\n                textureInfo.texCoord = texCoordIndex;\r\n            }\r\n        }\r\n        else {\r\n            Tools.Error(`Unsupported texture mime type ${mimeType}`);\r\n        }\r\n\r\n        return textureInfo;\r\n    }\r\n}","import * as Serializers from \"./index\";\r\n\r\n/**\r\n * Legacy support, defining window.BABYLON.OBJSerializer... (global variable).\r\n *\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    (<any>globalObject).BABYLON = (<any>globalObject).BABYLON || {};\r\n    for (var serializer in Serializers) {\r\n        if (Serializers.hasOwnProperty(serializer)) {\r\n            (<any>globalObject).BABYLON[serializer] = (<any>Serializers)[serializer];\r\n        }\r\n    }\r\n}\r\n\r\nexport * from \"./index\";","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","export * from \"./objSerializer\";","import { Mesh, Nullable, Matrix, Geometry, Tools, StandardMaterial } from \"babylonjs\";\n\n/**\n * Class for generating OBJ data from a Babylon scene.\n */\nexport class OBJExport {\n    /**\n     * Exports the geometry of a Mesh array in .OBJ file format (text)\n     * @param mesh defines the list of meshes to serialize\n     * @param materials defines if materials should be exported\n     * @param matlibname defines the name of the associated mtl file\n     * @param globalposition defines if the exported positions are globals or local to the exported mesh\n     * @returns the OBJ content\n     */\n    public static OBJ(mesh: Mesh[], materials?: boolean, matlibname?: string, globalposition?: boolean): string {\n        const output: string[] = [];\n        let v = 1;\n        if (materials) {\n            if (!matlibname) {\n                matlibname = 'mat';\n            }\n            output.push(\"mtllib \" + matlibname + \".mtl\");\n        }\n        for (let j = 0; j < mesh.length; j++) {\n            output.push(\"g object\" + j);\n            output.push(\"o object_\" + j);\n\n            //Uses the position of the item in the scene, to the file (this back to normal in the end)\n            let lastMatrix: Nullable<Matrix> = null;\n            if (globalposition) {\n                var newMatrix = BABYLON.Matrix.Translation(mesh[j].position.x, mesh[j].position.y, mesh[j].position.z);\n                lastMatrix = BABYLON.Matrix.Translation(-(mesh[j].position.x), -(mesh[j].position.y), -(mesh[j].position.z));\n                mesh[j].bakeTransformIntoVertices(newMatrix);\n            }\n\n            //TODO: submeshes (groups)\n            //TODO: smoothing groups (s 1, s off);\n            if (materials) {\n                let mat = mesh[j].material;\n\n                if (mat) {\n                    output.push(\"usemtl \" + mat.id);\n                }\n            }\n            const g: Nullable<Geometry> = mesh[j].geometry;\n\n            if (!g) {\n                Tools.Warn(\"No geometry is present on the mesh\");\n                continue;\n            }\n\n            const trunkVerts = g.getVerticesData('position');\n            const trunkNormals = g.getVerticesData('normal');\n            const trunkUV = g.getVerticesData('uv');\n            const trunkFaces = g.getIndices();\n            var curV = 0;\n\n            if (!trunkVerts || !trunkFaces) {\n                Tools.Warn(\"There are no position vertices or indices on the mesh!\");\n                continue;\n            }\n\n            for (var i = 0; i < trunkVerts.length; i += 3) {\n                output.push(\"v \" + trunkVerts[i] + \" \" + trunkVerts[i + 1] + \" \" + trunkVerts[i + 2]);\n                curV++;\n            }\n\n            if (trunkNormals != null) {\n                for (i = 0; i < trunkNormals.length; i += 3) {\n                    output.push(\"vn \" + trunkNormals[i] + \" \" + trunkNormals[i + 1] + \" \" + trunkNormals[i + 2]);\n                }\n            }\n            if (trunkUV != null) {\n\n                for (i = 0; i < trunkUV.length; i += 2) {\n                    output.push(\"vt \" + trunkUV[i] + \" \" + trunkUV[i + 1]);\n                }\n            }\n\n            for (i = 0; i < trunkFaces.length; i += 3) {\n                const indices = [String(trunkFaces[i + 2] + v), String(trunkFaces[i + 1] + v), String(trunkFaces[i] + v)];\n                const blanks: string[] = [\"\", \"\", \"\"];\n\n                const facePositions = indices;\n                const faceUVs = trunkUV != null ? indices : blanks;\n                const faceNormals = trunkNormals != null ? indices : blanks;\n\n                output.push(\n                    \"f \" + facePositions[0] + \"/\" + faceUVs[0] + \"/\" + faceNormals[0] +\n                    \" \" + facePositions[1] + \"/\" + faceUVs[1] + \"/\" + faceNormals[1] +\n                    \" \" + facePositions[2] + \"/\" + faceUVs[2] + \"/\" + faceNormals[2]\n                );\n            }\n            //back de previous matrix, to not change the original mesh in the scene\n            if (globalposition && lastMatrix) {\n                mesh[j].bakeTransformIntoVertices(lastMatrix);\n            }\n            v += curV;\n        }\n        const text: string = output.join(\"\\n\");\n        return (text);\n    }\n\n    /**\n     * Exports the material(s) of a mesh in .MTL file format (text)\n     * @param mesh defines the mesh to extract the material from\n     * @returns the mtl content\n     */\n    //TODO: Export the materials of mesh array\n    public static MTL(mesh: Mesh): string {\n        var output = [];\n        var m = <StandardMaterial>mesh.material;\n        output.push(\"newmtl mat1\");\n        output.push(\"  Ns \" + m.specularPower.toFixed(4));\n        output.push(\"  Ni 1.5000\");\n        output.push(\"  d \" + m.alpha.toFixed(4));\n        output.push(\"  Tr 0.0000\");\n        output.push(\"  Tf 1.0000 1.0000 1.0000\");\n        output.push(\"  illum 2\");\n        output.push(\"  Ka \" + m.ambientColor.r.toFixed(4) + \" \" + m.ambientColor.g.toFixed(4) + \" \" + m.ambientColor.b.toFixed(4));\n        output.push(\"  Kd \" + m.diffuseColor.r.toFixed(4) + \" \" + m.diffuseColor.g.toFixed(4) + \" \" + m.diffuseColor.b.toFixed(4));\n        output.push(\"  Ks \" + m.specularColor.r.toFixed(4) + \" \" + m.specularColor.g.toFixed(4) + \" \" + m.specularColor.b.toFixed(4));\n        output.push(\"  Ke \" + m.emissiveColor.r.toFixed(4) + \" \" + m.emissiveColor.g.toFixed(4) + \" \" + m.emissiveColor.b.toFixed(4));\n\n        //TODO: uv scale, offset, wrap\n        //TODO: UV mirrored in Blender? second UV channel? lightMap? reflection textures?\n        var uvscale = \"\";\n\n        if (m.ambientTexture) {\n            output.push(\"  map_Ka \" + uvscale + m.ambientTexture.name);\n        }\n\n        if (m.diffuseTexture) {\n            output.push(\"  map_Kd \" + uvscale + m.diffuseTexture.name);\n            //TODO: alpha testing, opacity in diffuse texture alpha channel (diffuseTexture.hasAlpha -> map_d)\n        }\n\n        if (m.specularTexture) {\n            output.push(\"  map_Ks \" + uvscale + m.specularTexture.name);\n            /* TODO: glossiness = specular highlight component is in alpha channel of specularTexture. (???)\n            if (m.useGlossinessFromSpecularMapAlpha)  {\n                output.push(\"  map_Ns \"+uvscale + m.specularTexture.name);\n            }\n            */\n        }\n\n        /* TODO: emissive texture not in .MAT format (???)\n        if (m.emissiveTexture) {\n            output.push(\"  map_d \"+uvscale+m.emissiveTexture.name);\n        }\n        */\n\n        if (m.bumpTexture) {\n            output.push(\"  map_bump -imfchan z \" + uvscale + m.bumpTexture.name);\n        }\n\n        if (m.opacityTexture) {\n            output.push(\"  map_d \" + uvscale + m.opacityTexture.name);\n        }\n\n        var text = output.join(\"\\n\");\n        return (text);\n    }\n}\n","export * from \"./glTFFileExporter\";\r\nexport * from \"./2.0\";","/** @hidden */\r\nexport var __IGLTFExporterExtension = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for extending the exporter\r\n * @hidden\r\n */\r\nexport interface IGLTFExporterExtension {\r\n    /**\r\n     * The name of this extension\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * Defines whether this extension is enabled\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines whether this extension is required\r\n     */\r\n    required: boolean;\r\n}","export * from \"./glTFAnimation\";\r\nexport * from \"./glTFData\";\r\nexport * from \"./glTFExporter\";\r\nexport * from \"./glTFExporterExtension\";\r\nexport * from \"./glTFMaterialExporter\";\r\nexport * from \"./glTFSerializer\";\r\nexport * from \"./glTFUtilities\";\r\nexport * from \"./Extensions\";","import { IDisposable, Texture, Nullable, SubMesh } from \"babylonjs\";\r\n\r\nimport { ImageMimeType, IMeshPrimitive } from \"babylonjs-gltf2interface\";\r\n\r\nimport { _BinaryWriter } from \"./glTFExporter\";\r\nimport { IGLTFExporterExtension } from \"../glTFFileExporter\";\r\n\r\n/** @hidden */\r\nexport var __IGLTFExporterExtensionV2 = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for a glTF exporter extension\r\n * @hidden\r\n */\r\nexport interface IGLTFExporterExtensionV2 extends IGLTFExporterExtension, IDisposable {\r\n    /**\r\n     * Define this method to modify the default behavior before exporting a texture\r\n     * @param context The context when loading the asset\r\n     * @param babylonTexture The glTF texture info property\r\n     * @param mimeType The mime-type of the generated image\r\n     * @returns A promise that resolves with the exported glTF texture info when the export is complete, or null if not handled\r\n     */\r\n    preExportTextureAsync?(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Nullable<Promise<Texture>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when exporting texture info\r\n     * @param context The context when loading the asset\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param babylonSubMesh Babylon submesh\r\n     * @param binaryWriter glTF serializer binary writer instance\r\n     */\r\n    postExportMeshPrimitiveAsync?(context: string, meshPrimitive: IMeshPrimitive, babylonSubMesh: SubMesh, binaryWriter: _BinaryWriter): Nullable<Promise<IMeshPrimitive>>;\r\n}","import { TransformNode, Scene } from \"babylonjs\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _Exporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Holds a collection of exporter options and parameters\r\n */\r\nexport interface IExportOptions {\r\n    /**\r\n     * Function which indicates whether a babylon mesh should be exported or not\r\n     * @param transformNode source Babylon transform node. It is used to check whether it should be exported to glTF or not\r\n     * @returns boolean, which indicates whether the mesh should be exported (true) or not (false)\r\n     */\r\n    shouldExportTransformNode?(transformNode: TransformNode): boolean;\r\n    /**\r\n     * The sample rate to bake animation curves\r\n     */\r\n    animationSampleRate?: number;\r\n\r\n    /**\r\n     * Begin serialization without waiting for the scene to be ready\r\n     */\r\n    exportWithoutWaitingForScene?: boolean;\r\n}\r\n\r\n/**\r\n * Class for generating glTF data from a Babylon scene.\r\n */\r\nexport class GLTF2Export {\r\n    /**\r\n     * Exports the geometry of the scene to .gltf file format asynchronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating the glTF file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .gltf file and associates texture names\r\n     * as keys and their data and paths as values\r\n     */\r\n    public static GLTFAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return scene.whenReadyAsync().then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLTFAsync(glTFPrefix);\r\n        });\r\n    }\r\n\r\n    private static _PreExportAsync(scene: Scene, options?: IExportOptions): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return Promise.resolve();\r\n            }\r\n            else {\r\n                return scene.whenReadyAsync();\r\n            }\r\n        });\r\n    }\r\n\r\n    private static _PostExportAsync(scene: Scene, glTFData: GLTFData, options?: IExportOptions): Promise<GLTFData> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return glTFData;\r\n            }\r\n            else {\r\n                return glTFData;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Exports the geometry of the scene to .glb file format asychronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating glb file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .glb filename as key and data as value\r\n     */\r\n    public static GLBAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return this._PreExportAsync(scene, options).then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLBAsync(glTFPrefix).then((glTFData) => {\r\n                return this._PostExportAsync(scene, glTFData, options);\r\n            });\r\n        });\r\n    }\r\n}\r\n","export * from \"./KHR_texture_transform\";","import { Effect, Texture, Nullable, Vector2, Scene, BaseTexture, ProceduralTexture, Tools } from \"babylonjs\";\r\nimport { ImageMimeType } from \"babylonjs-gltf2interface\";\r\nimport { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\nEffect.ShadersStore[\"textureTransformPixelShader\"] = require(\"../shaders/textureTransform.fragment.fx\");\r\n\r\n/**\r\n * Interface for handling KHR texture transform\r\n * @hidden\r\n */\r\ninterface IKHRTextureTransform {\r\n    offset?: number[];\r\n    rotation?: number;\r\n    scale?: number[];\r\n    texCoord?: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class KHR_texture_transform implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _exporter: _Exporter;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {\r\n        delete this._exporter;\r\n    }\r\n\r\n    public preExportTextureAsync(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Nullable<Promise<Texture>> {\r\n        return new Promise((resolve, reject) => {\r\n            const texture_transform_extension: IKHRTextureTransform = {};\r\n\r\n            if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {\r\n                texture_transform_extension.offset = [babylonTexture.uOffset, babylonTexture.vOffset];\r\n            }\r\n\r\n            if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {\r\n                texture_transform_extension.scale = [babylonTexture.uScale, babylonTexture.vScale];\r\n            }\r\n\r\n            if (babylonTexture.wAng !== 0) {\r\n                texture_transform_extension.rotation = babylonTexture.wAng;\r\n            }\r\n\r\n            if (!Object.keys(texture_transform_extension).length) {\r\n                resolve(babylonTexture);\r\n            }\r\n\r\n            const scale = texture_transform_extension.scale ? new Vector2(texture_transform_extension.scale[0], texture_transform_extension.scale[1]) : Vector2.One();\r\n            const rotation = texture_transform_extension.rotation != null ? texture_transform_extension.rotation : 0;\r\n            const offset = texture_transform_extension.offset ? new Vector2(texture_transform_extension.offset[0], texture_transform_extension.offset[1]) : Vector2.Zero();\r\n            const scene = babylonTexture.getScene();\r\n            if (!scene) {\r\n                reject(`${context}: \"scene\" is not defined for Babylon texture ${babylonTexture.name}!`);\r\n            }\r\n            else {\r\n                this.textureTransformTextureAsync(babylonTexture, offset, rotation, scale, scene).then((texture) => {\r\n                    resolve(texture as Texture);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Transform the babylon texture by the offset, rotation and scale parameters using a procedural texture\r\n     * @param babylonTexture\r\n     * @param offset\r\n     * @param rotation\r\n     * @param scale\r\n     * @param scene\r\n     */\r\n    public textureTransformTextureAsync(babylonTexture: Texture, offset: Vector2, rotation: number, scale: Vector2, scene: Scene): Promise<BaseTexture> {\r\n        return new Promise((resolve, reject) => {\r\n            const proceduralTexture = new ProceduralTexture(`${babylonTexture.name}`, babylonTexture.getSize(), \"textureTransform\", scene);\r\n            if (!proceduralTexture) {\r\n                Tools.Log(`Cannot create procedural texture for ${babylonTexture.name}!`);\r\n                resolve(babylonTexture);\r\n            }\r\n\r\n            proceduralTexture.setTexture(\"textureSampler\", babylonTexture);\r\n            proceduralTexture.setMatrix(\"textureTransformMat\", babylonTexture.getTextureMatrix());\r\n\r\n            // isReady trigger creation of effect if it doesnt exist yet\r\n            if (proceduralTexture.isReady()) {\r\n                proceduralTexture.render();\r\n                resolve(proceduralTexture);\r\n            } else {\r\n                (proceduralTexture as any).getEffect().executeWhenCompiled(() => {\r\n                    proceduralTexture.render();\r\n                    resolve(proceduralTexture);\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_texture_transform(exporter));","module.exports = \"precision highp float;\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform mat4 textureTransformMat;\\nvoid main(void) {\\nvec2 uvTransformed=(textureTransformMat*vec4(vUV.xy,1,1)).xy;\\ngl_FragColor=texture2D(textureSampler,uvTransformed);\\n}\""],"sourceRoot":""}