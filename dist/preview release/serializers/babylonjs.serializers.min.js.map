{"version":3,"sources":["webpack://SERIALIZERS/webpack/universalModuleDefinition","webpack://SERIALIZERS/webpack/bootstrap","webpack://SERIALIZERS/external {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFUtilities.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFAnimation.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFData.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFExporter.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFMaterialExporter.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/legacy.ts","webpack://SERIALIZERS/../node_modules/webpack/buildin/global.js","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/OBJ/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/OBJ/objSerializer.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/glTFFileExporter.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/index.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFExporterExtension.ts","webpack://SERIALIZERS/../Tools/Gulp/../../serializers/src/glTF/2.0/glTFSerializer.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","babylonjs_1","_GLTFUtilities","_CreateBufferView","bufferIndex","byteOffset","byteLength","byteStride","bufferview","buffer","_CreateAccessor","bufferviewIndex","type","componentType","count","min","max","accessor","bufferView","_CalculateMinMaxPositions","positions","vertexStart","vertexCount","convertToRightHandedSystem","indexOffset","position","vector","Infinity","length_1","Vector3","FromArray","_GetRightHandedPositionVector3FromRef","asArray","j","num","_GetRightHandedPositionVector3","x","y","z","_GetRightHandedPositionArray3FromRef","_GetRightHandedNormalVector3","_GetRightHandedNormalVector3FromRef","_GetRightHandedNormalArray3FromRef","_GetRightHandedVector4FromRef","w","_GetRightHandedArray4FromRef","_GetRightHandedQuaternionFromRef","quaternion","_GetRightHandedQuaternionArrayFromRef","_NormalizeTangentFromRef","tangent","length","Math","sqrt","__export","_TangentType","glTFUtilities_1","_GLTFAnimation","_CreateNodeAnimation","babylonTransformNode","animation","animationChannelTargetPath","useQuaternion","animationSampleRate","inputs","outputs","keyFrames","getKeys","minMaxKeyFrames","calculateMinMaxKeyFrames","interpolationOrBake","_DeduceInterpolation","frameDelta","interpolation","interpolationType","shouldBakeAnimation","_CreateBakedAnimation","framePerSecond","_CreateLinearOrStepAnimation","_CreateCubicSplineAnimation","samplerInterpolation","inputsMin","Tools","FloatRound","inputsMax","_DeduceAnimationInfo","dataAccessorType","targetProperty","split","Error","_CreateNodeAnimationFromTransformNodeAnimations","runtimeGLTFAnimation","idleGLTFAnimations","nodeMap","nodes","binaryWriter","bufferViews","accessors","glTFAnimation","animations","_i","_a","animationInfo","samplers","channels","AddAnimation","hasRunningRuntimeAnimations","push","_CreateNodeAnimationFromAnimationGroups","babylonScene","glTFAnimations","animationGroups","animationGroups_1","animationGroup","_b","targetedAnimations","targetAnimation","target","Mesh","babylonMesh","keyframeAccessorIndex","dataAccessorIndex","outputLength","animationSampler","animationChannel","animationData","nodeIndex","uniqueId","getByteOffset","undefined","forEach","input","setFloat32","output","entry","sampler","node","path","minFrame","maxFrame","fps","sampleRate","minMaxFrames","time","quaternionCache","Quaternion","Identity","previousTime","maxUsedFrame","currKeyFrame","nextKeyFrame","prevKeyFrame","endFrame","equals","frame","f","_interpolate","loopMode","_SetInterpolatedValue","_ConvertFactorToVector3OrQuaternion","factor","animationType","componentName","basePositionRotationOrScale","_GetBasePositionRotationOrScale","Animation","ANIMATIONTYPE_FLOAT","BABYLON","normalize","cacheValue","dataType","this","RotationYawPitchRollToRef","parent","multiply","keyFrame","_AddKeyframeValue","AddSplineTangent","INTANGENT","OUTTANGENT","rotationQuaternion","rotation","scaling","newPositionRotationOrScale","ANIMATIONTYPE_VECTOR3","array","RotationYawPitchRoll","posRotScale","ANIMATIONTYPE_QUATERNION","length_2","inTangent","outTangent","AnimationKeyInterpolation","STEP","tangentType","tangentValue","scale","GLTFData","glTFFiles","downloadFiles","endsWith","str","suffix","indexOf","link","document","createElement","body","appendChild","setAttribute","download","blob","mimeType","href","URL","createObjectURL","Blob","click","glTFMaterialExporter_1","glTFData_1","glTFAnimation_1","_Exporter","options","_extensions","_asset","generator","version","_extensionsUsed","_extensionsRequired","_babylonScene","_bufferViews","_accessors","_meshes","_scenes","_nodes","_images","_materials","_materialMap","_textures","_samplers","_animations","_imageData","_convertToRightHandedSystem","useRightHandedSystem","_options","_shouldExportTransformNode","shouldExportTransformNode","_animationSampleRate","_glTFMaterialExporter","_GLTFMaterialExporter","_loadExtensions","_applyExtensions","actionAsync","_ExtensionNames","name_1","extension","enabled","exporterProperty","_activeLoaderExtensions","activeLoaderExtensions","result","_extensionsPreExportTextureAsync","context","babylonTexture","preExportTextureAsync","_extensionsPostExportMeshPrimitiveAsync","meshPrimitive","babylonSubMesh","postExportMeshPrimitiveAsync","name_2","_ExtensionFactories","RegisterExtension","UnregisterExtension","Warn","index","splice","_getLocalEngine","_localEngine","localCanvas","id","width","height","Engine","premultipliedAlpha","preserveDrawingBuffer","setViewport","Viewport","reorderIndicesBasedOnPrimitiveMode","submesh","primitiveMode","babylonIndices","Material","TriangleFillMode","indexStart","indexCount","secondIndex","getUInt32","thirdIndex","setUInt32","TriangleFanDrawMode","start","TriangleStripDrawMode","reorderVertexAttributeDataBasedOnPrimitiveMode","sideOrientation","vertexBufferKind","meshAttributeArray","ClockWiseSideOrientation","reorderTriangleFillMode","reorderTriangleStripDrawMode","reorderTriangleFanMode","vertexBuffer","getVertexBufferFromMesh","getMesh","stride","VertexBuffer","GetTypeByteLength","verticesCount","vertexData","PositionKind","NormalKind","verticesStart","TangentKind","Vector4","ColorKind","size","getSize","UVKind","UV2Kind","Vector2","writeVertexAttributeData","vertices","vertexAttributeKind","vertices_1","vertex","component","writeAttributeData","vertexAttributes","k","length_3","length_4","length_5","length_6","vertexAttributes_1","vertexAttribute_1","generateJSON","shouldUseGlb","glTFPrefix","prettyPrint","imageName","imageData","_this","_totalByteLength","glTF","asset","extensionsUsed","extensionsRequired","buffers","meshes","scenes","scene","materials","textures","images","image","uri","data","JSON","stringify","_generateGLTFAsync","_generateBinaryAsync","then","binaryBuffer","jsonText","bin","glTFFileName","glTFBinFile","container","_BinaryWriter","createSceneAsync","dispose","getArrayBuffer","_getPadding","remainder","_generateGLBAsync","glbFileName","jsonLength","imageByteLength","jsonPadding","binPadding","imagePadding","headerLength","headerBuffer","ArrayBuffer","headerBufferView","DataView","setUint32","jsonChunkBuffer","jsonChunkBufferView","jsonData","Uint8Array","charCodeAt","jsonPaddingView","binaryChunkBuffer","binaryChunkBufferView","binPaddingBuffer","binPaddingView","imagePaddingBuffer","imagePaddingView","glbData","glbFile","setNodeTransformation","getPivotPoint","equalsToFloats","translation","multiplyInPlace","attributeKind","bufferMesh","isVerticesDataPresent","getVertexBuffer","createBufferViewKind","kind","InstancedMesh","sourceMesh","getVerticesData","getMeshPrimitiveMode","LinesMesh","LineListDrawMode","material","fillMode","setPrimitiveMode","PointListDrawMode","PointFillMode","LineLoopDrawMode","LineStripDrawMode","setAttributeKind","attributes","POSITION","NORMAL","COLOR_0","TANGENT","TEXCOORD_0","TEXCOORD_1","setPrimitiveAttributesAsync","mesh","uvCoordsPresent","minMax","promises","attributeData","accessorType","indexBufferViewIndex","vertexAttributeBufferViews","attributeData_1","attribute","DeduceStride","bufferViewIndex","getTotalIndices","indices","getIndices","length_7","subMeshes","babylonMaterial","getMaterial","getScene","defaultMaterial","materialIndex","color","Color3","White","alpha","pbrMetallicRoughness","baseColorFactor","concat","MultiMaterial","subMaterial","subMaterials","glTFMaterial","_c","attributeData_2","_hasTexturesPresent","keys","_d","attributeData_3","byteOffset_1","newMat","_stripTexturesFromMaterial","primitives","Promise","all","glTFNodeIndex","glTFNode","directDescendents","transformNodes","_convertMaterialsToGLTFAsync","createNodeMapAndAnimationsAsync","_nodeMap","nodes_1","Log","getDescendants","children","directDescendents_1","descendent","promiseChain","resolve","createNodeAsync","TransformNode","nodes_2","idleGLTFAnimation","Array","_arrayBuffer","_dataView","_byteOffset","resizeBuffer","newBuffer","oldUint8Array","newUint8Array","length_8","setUInt8","setUint8","getUint32","getVector3Float32FromRef","vector3","getFloat32","setVector3Float32FromRef","getVector4Float32FromRef","vector4","setVector4Float32FromRef","isNaN","exporter","_textureMap","_exporter","FuzzyEquals","color1","color2","epsilon","Scalar","WithinEpsilon","g","b","babylonMaterials","hasTextureCoords","babylonMaterials_1","StandardMaterial","_convertStandardMaterialAsync","PBRMetallicRoughnessMaterial","_convertPBRMetallicRoughnessMaterialAsync","PBRMaterial","_convertPBRMaterialAsync","originalMaterial","newMaterial","doubleSided","alphaMode","alphaCutoff","emissiveFactor","originalPBRMetallicRoughness","metallicFactor","roughnessFactor","emissiveTexture","normalTexture","occlusionTexture","pbrMat","baseColorTexture","metallicRoughnessTexture","_convertToGLTFPBRMetallicRoughness","babylonStandardMaterial","P0","P1","P2","P3","diffuse","diffuseColor","toLinearSpace","opacity","roughness","specularPower","p0","p1","p2","p3","_cubicBezierCurve","pow","_solveForRoughness","Clamp","_MaxSpecularPower","_SolveMetallic","specular","oneMinusSpecularStrength","_DielectricSpecular","a","D","_getAlphaMode","needAlphaBlending","needAlphaTesting","materialMap","glTFPbrMetallicRoughness","backFaceCulling","twoSidedLighting","diffuseTexture","_exportTextureAsync","glTFTexture","bumpTexture","level","glTFEmissiveTexture","ambientTexture","strength","opacityTexture","ALPHA_COMBINE","toString","emissiveColor","Black","_Epsilon","alphaCutOff","babylonPBRMetalRoughMaterial","baseColor","metallic","transparencyMode","baseTexture","occlusionStrength","_createBase64FromCanvasAsync","reject","hostingScene","textureType","TEXTURETYPE_UNSIGNED_INT","engine","Scene","tempTexture","createRawTexture","TEXTUREFORMAT_RGBA","Texture","NEAREST_SAMPLINGMODE","postProcess","PostProcess","getEffect","executeWhenCompiled","onApply","effect","_bindTexture","setSize","postProcessManager","directRender","canvas","getRenderingCanvas","toBlob","ToBlob","fileReader","FileReader","onload","event","base64String","readAsDataURL","dataURL","toDataURL","_createWhiteTexture","RawTexture","CreateRGBATexture","_resizeTexturesToSameDimensions","texture1","texture2","resizedTexture1","resizedTexture2","texture1Size","texture2Size","TextureTools","CreateResizedCopy","_convertPixelArrayToFloat32","pixels","Float32Array","_convertSpecularGlossinessTexturesToMetallicRoughnessAsync","specularGlossinessTexture","factors","resizedTextures","diffuseSize","diffuseBuffer","specularGlossinessBuffer","diffusePixels","readPixels","specularPixels","metallicRoughnessBuffer","baseColorBuffer","maxBaseColor","maxMetallic","maxRoughness","h","offset","specularGlossiness","specularColor","glossiness","metallicRoughness","_convertSpecularGlossinessToMetallicRoughness","hasAlpha","metallicRoughnessFactors_1","writeOutMetallicRoughnessTexture","writeOutBaseColorTexture","destinationOffset","sRGBBaseColorPixel","FromInts","toGammaSpace","metallicRoughnessPixel","promise","metallicRoughnessBase64","metallicRoughnessTextureBase64","baseColorBase64","baseColorTextureBase64","diffusePerceivedBrightness","_getPerceivedBrightness","specularPerceivedBrightness","_getMaxComponent","baseColorFromDiffuse","baseColorFromSpecular","subtract","Lerp","clampToRef","_convertMetalRoughFactorsToMetallicRoughnessAsync","babylonPBRMaterial","albedoColor","albedoTexture","metallicTexture","_getGLTFTextureSampler","texture","_getGLTFTextureWrapModesSampler","samplingMode","LINEAR_LINEAR","magFilter","minFilter","LINEAR_NEAREST","NEAREST_LINEAR","NEAREST_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","NEAREST_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","LINEAR_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPNEAREST","_getGLTFTextureWrapMode","wrapMode","WRAP_ADDRESSMODE","CLAMP_ADDRESSMODE","MIRROR_ADDRESSMODE","wrapS","wrapU","wrapT","wrapV","_convertSpecGlossFactorsToMetallicRoughnessAsync","specGloss","reflectivityColor","microSurface","samplerIndex","reflectivityTexture","useMicroSurfaceFromReflectivityMapAlpha","metallicRoughnessFactors","glTFBaseColorTexture","_getTextureInfoFromBase64","coordinatesIndex","glTFMRColorTexture","isMetallicWorkflow","setMetallicRoughnessPbrMaterial","ambientTextureStrength","getPixelsFromTexture","extensionPromise","_exportTextureInfoAsync","textureUid","uid","samplerIndex_1","foundSamplerIndex","base64Data","textureInfo","replace","base64Texture","baseTextureName","texCoordIndex","source","binStr","atob","arrBuff","arr","imageValues","textureName","RandomId","glTFImage","foundIndex","texCoord","Serializers","globalObject","global","serializer","Function","eval","e","OBJExport","OBJ","matlibname","globalposition","v","lastMatrix","newMatrix","Matrix","Translation","bakeTransformIntoVertices","mat","geometry","trunkVerts","trunkNormals","trunkUV","trunkFaces","curV","String","blanks","facePositions","faceUVs","faceNormals","join","MTL","toFixed","ambientColor","specularTexture","__IGLTFExporterExtension","__IGLTFExporterExtensionV2","glTFExporter_1","GLTF2Export","GLTFAsync","filePrefix","whenReadyAsync","_PreExportAsync","exportWithoutWaitingForScene","_PostExportAsync","glTFData","GLBAsync"],"mappings":"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","file":"babylonjs.serializers.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-serializers\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-serializers\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"SERIALIZERS\"] = factory(root[\"BABYLON\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import { Nullable, FloatArray, Vector3, Vector4, Quaternion } from \"babylonjs\";\r\nimport { IBufferView, AccessorType, AccessorComponentType, IAccessor } from \"babylonjs-gltf2interface\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class _GLTFUtilities {\r\n    /**\r\n     * Creates a buffer view based on the supplied arguments\r\n     * @param bufferIndex index value of the specified buffer\r\n     * @param byteOffset byte offset value\r\n     * @param byteLength byte length of the bufferView\r\n     * @param byteStride byte distance between conequential elements\r\n     * @param name name of the buffer view\r\n     * @returns bufferView for glTF\r\n     */\r\n    public static _CreateBufferView(bufferIndex: number, byteOffset: number, byteLength: number, byteStride?: number, name?: string): IBufferView {\r\n        let bufferview: IBufferView = { buffer: bufferIndex, byteLength: byteLength };\r\n        if (byteOffset) {\r\n            bufferview.byteOffset = byteOffset;\r\n        }\r\n        if (name) {\r\n            bufferview.name = name;\r\n        }\r\n        if (byteStride) {\r\n            bufferview.byteStride = byteStride;\r\n        }\r\n\r\n        return bufferview;\r\n    }\r\n\r\n    /**\r\n     * Creates an accessor based on the supplied arguments\r\n     * @param bufferviewIndex The index of the bufferview referenced by this accessor\r\n     * @param name The name of the accessor\r\n     * @param type The type of the accessor\r\n     * @param componentType The datatype of components in the attribute\r\n     * @param count The number of attributes referenced by this accessor\r\n     * @param byteOffset The offset relative to the start of the bufferView in bytes\r\n     * @param min Minimum value of each component in this attribute\r\n     * @param max Maximum value of each component in this attribute\r\n     * @returns accessor for glTF\r\n     */\r\n    public static _CreateAccessor(bufferviewIndex: number, name: string, type: AccessorType, componentType: AccessorComponentType, count: number, byteOffset: Nullable<number>, min: Nullable<number[]>, max: Nullable<number[]>): IAccessor {\r\n        let accessor: IAccessor = { name: name, bufferView: bufferviewIndex, componentType: componentType, count: count, type: type };\r\n\r\n        if (min != null) {\r\n            accessor.min = min;\r\n        }\r\n        if (max != null) {\r\n            accessor.max = max;\r\n        }\r\n        if (byteOffset != null) {\r\n            accessor.byteOffset = byteOffset;\r\n        }\r\n\r\n        return accessor;\r\n    }\r\n\r\n    /**\r\n     * Calculates the minimum and maximum values of an array of position floats\r\n     * @param positions Positions array of a mesh\r\n     * @param vertexStart Starting vertex offset to calculate min and max values\r\n     * @param vertexCount Number of vertices to check for min and max values\r\n     * @returns min number array and max number array\r\n     */\r\n    public static _CalculateMinMaxPositions(positions: FloatArray, vertexStart: number, vertexCount: number, convertToRightHandedSystem: boolean): { min: number[], max: number[] } {\r\n        const min = [Infinity, Infinity, Infinity];\r\n        const max = [-Infinity, -Infinity, -Infinity];\r\n        const positionStrideSize = 3;\r\n        let indexOffset: number;\r\n        let position: Vector3;\r\n        let vector: number[];\r\n\r\n        if (vertexCount) {\r\n            for (let i = vertexStart, length = vertexStart + vertexCount; i < length; ++i) {\r\n                indexOffset = positionStrideSize * i;\r\n\r\n                position = Vector3.FromArray(positions, indexOffset);\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(position);\r\n                }\r\n                vector = position.asArray();\r\n\r\n                for (let j = 0; j < positionStrideSize; ++j) {\r\n                    let num = vector[j];\r\n                    if (num < min[j]) {\r\n                        min[j] = num;\r\n                    }\r\n                    if (num > max[j]) {\r\n                        max[j] = num;\r\n                    }\r\n                    ++indexOffset;\r\n                }\r\n            }\r\n        }\r\n        return { min, max };\r\n    }\r\n\r\n    /**\r\n     * Converts a new right-handed Vector3\r\n     * @param vector vector3 array\r\n     * @returns right-handed Vector3\r\n     */\r\n    public static _GetRightHandedPositionVector3(vector: Vector3): Vector3 {\r\n        return new Vector3(vector.x, vector.y, -vector.z);\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector3 to right-handed\r\n     * @param vector Vector3 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedPositionVector3FromRef(vector: Vector3) {\r\n        vector.z *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a three element number array to right-handed\r\n     * @param vector number array to convert to right-handed\r\n     */\r\n    public static _GetRightHandedPositionArray3FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a new right-handed Vector3\r\n     * @param vector vector3 array\r\n     * @returns right-handed Vector3\r\n     */\r\n    public static _GetRightHandedNormalVector3(vector: Vector3): Vector3 {\r\n        return new Vector3(vector.x, vector.y, -vector.z);\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector3 to right-handed\r\n     * @param vector Vector3 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedNormalVector3FromRef(vector: Vector3) {\r\n        vector.z *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a three element number array to right-handed\r\n     * @param vector number array to convert to right-handed\r\n     */\r\n    public static _GetRightHandedNormalArray3FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector4 to right-handed\r\n     * @param vector Vector4 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedVector4FromRef(vector: Vector4) {\r\n        vector.z *= -1;\r\n        vector.w *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector4 to right-handed\r\n     * @param vector Vector4 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedArray4FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n        vector[3] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Quaternion to right-handed\r\n     * @param quaternion Source quaternion to convert to right-handed\r\n     */\r\n    public static _GetRightHandedQuaternionFromRef(quaternion: Quaternion) {\r\n        quaternion.x *= -1;\r\n        quaternion.y *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Quaternion to right-handed\r\n     * @param quaternion Source quaternion to convert to right-handed\r\n     */\r\n    public static _GetRightHandedQuaternionArrayFromRef(quaternion: number[]) {\r\n        quaternion[0] *= -1;\r\n        quaternion[1] *= -1;\r\n    }\r\n\r\n    public static _NormalizeTangentFromRef(tangent: Vector4) {\r\n        const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);\r\n        if (length > 0) {\r\n            tangent.x /= length;\r\n            tangent.y /= length;\r\n            tangent.z /= length;\r\n        }\r\n    }\r\n}","export * from \"./OBJ\";\r\nexport * from \"./glTF\";","import { Animation, TransformNode, Nullable, Tools, Scene, Mesh, Vector3, Quaternion, IAnimationKey, AnimationKeyInterpolation } from \"babylonjs\";\r\nimport { AnimationSamplerInterpolation, AnimationChannelTargetPath, AccessorType, IAnimation, INode, IBufferView, IAccessor, IAnimationSampler, IAnimationChannel, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport { _BinaryWriter } from \"./glTFExporter\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\n\r\n/**\r\n * @hidden\r\n * Interface to store animation data.\r\n */\r\nexport interface _IAnimationData {\r\n    /**\r\n     * Keyframe data.\r\n     */\r\n    inputs: number[];\r\n    /**\r\n     * Value data.\r\n     */\r\n    outputs: number[][];\r\n    /**\r\n     * Animation interpolation data.\r\n     */\r\n    samplerInterpolation: AnimationSamplerInterpolation;\r\n    /**\r\n     * Minimum keyframe value.\r\n     */\r\n    inputsMin: number;\r\n    /**\r\n     * Maximum keyframe value.\r\n     */\r\n    inputsMax: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport interface _IAnimationInfo {\r\n    /**\r\n     * The target channel for the animation\r\n     */\r\n    animationChannelTargetPath: AnimationChannelTargetPath;\r\n    /**\r\n     * The glTF accessor type for the data.\r\n     */\r\n    dataAccessorType: AccessorType.VEC3 | AccessorType.VEC4;\r\n    /**\r\n     * Specifies if quaternions should be used.\r\n     */\r\n    useQuaternion: boolean;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * Enum for handling in tangent and out tangent.\r\n */\r\nenum _TangentType {\r\n    /**\r\n     * Specifies that input tangents are used.\r\n     */\r\n    INTANGENT,\r\n    /**\r\n     * Specifies that output tangents are used.\r\n     */\r\n    OUTTANGENT\r\n}\r\n/**\r\n * @hidden\r\n * Utility class for generating glTF animation data from BabylonJS.\r\n */\r\nexport class _GLTFAnimation {\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Creates glTF channel animation from BabylonJS animation.\r\n     * @param babylonTransformNode - BabylonJS mesh.\r\n     * @param animation - animation.\r\n     * @param animationChannelTargetPath - The target animation channel.\r\n     * @param convertToRightHandedSystem - Specifies if the values should be converted to right-handed.\r\n     * @param useQuaternion - Specifies if quaternions are used.\r\n     * @returns nullable IAnimationData\r\n     */\r\n    public static _CreateNodeAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean, animationSampleRate: number): Nullable<_IAnimationData> {\r\n        const inputs: number[] = [];\r\n        const outputs: number[][] = [];\r\n        const keyFrames = animation.getKeys();\r\n        const minMaxKeyFrames = _GLTFAnimation.calculateMinMaxKeyFrames(keyFrames);\r\n        const interpolationOrBake = _GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);\r\n        const frameDelta = minMaxKeyFrames.max - minMaxKeyFrames.min;\r\n\r\n        const interpolation = interpolationOrBake.interpolationType;\r\n        const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;\r\n\r\n        if (shouldBakeAnimation) {\r\n            _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n        else {\r\n            if (interpolation === AnimationSamplerInterpolation.LINEAR || interpolation === AnimationSamplerInterpolation.STEP) {\r\n                _GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n\r\n            }\r\n            else if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                _GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n            }\r\n            else {\r\n                _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);\r\n            }\r\n        }\r\n\r\n        if (inputs.length && outputs.length) {\r\n            const result: _IAnimationData = {\r\n                inputs: inputs,\r\n                outputs: outputs,\r\n                samplerInterpolation: interpolation,\r\n                inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),\r\n                inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond)\r\n            };\r\n\r\n            return result;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _DeduceAnimationInfo(animation: Animation): Nullable<_IAnimationInfo> {\r\n        let animationChannelTargetPath: Nullable<AnimationChannelTargetPath> = null;\r\n        let dataAccessorType = AccessorType.VEC3;\r\n        let useQuaternion: boolean = false;\r\n        let property = animation.targetProperty.split('.');\r\n        switch (property[0]) {\r\n            case 'scaling': {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.SCALE;\r\n                break;\r\n            }\r\n            case 'position': {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.TRANSLATION;\r\n                break;\r\n            }\r\n            case 'rotation': {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case 'rotationQuaternion': {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                useQuaternion = true;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported animatable property ${property[0]}`);\r\n            }\r\n        }\r\n        if (animationChannelTargetPath) {\r\n            return { animationChannelTargetPath: animationChannelTargetPath, dataAccessorType: dataAccessorType, useQuaternion: useQuaternion };\r\n        }\r\n        else {\r\n            Tools.Error('animation channel target path and data accessor type could be deduced');\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the transform node animations\r\n     * @param babylonTransformNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param convertToRightHandedSystem\r\n     */\r\n    public static _CreateNodeAnimationFromTransformNodeAnimations(babylonTransformNode: TransformNode, runtimeGLTFAnimation: IAnimation, idleGLTFAnimations: IAnimation[], nodeMap: { [key: number]: number }, nodes: INode[], binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, animationSampleRate: number) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonTransformNode.animations) {\r\n            for (let animation of babylonTransformNode.animations) {\r\n                let animationInfo = _GLTFAnimation._DeduceAnimationInfo(animation);\r\n                if (animationInfo) {\r\n                    glTFAnimation = {\r\n                        name: animation.name,\r\n                        samplers: [],\r\n                        channels: []\r\n                    };\r\n                    _GLTFAnimation.AddAnimation(`${animation.name}`,\r\n                        animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                        babylonTransformNode,\r\n                        animation,\r\n                        animationInfo.dataAccessorType,\r\n                        animationInfo.animationChannelTargetPath,\r\n                        nodeMap,\r\n                        binaryWriter,\r\n                        bufferViews,\r\n                        accessors,\r\n                        convertToRightHandedSystem,\r\n                        animationInfo.useQuaternion,\r\n                        animationSampleRate\r\n                    );\r\n                    if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                        idleGLTFAnimations.push(glTFAnimation);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the animation groups\r\n     * @param babylonScene\r\n     * @param glTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param convertToRightHandedSystem\r\n     */\r\n    public static _CreateNodeAnimationFromAnimationGroups(babylonScene: Scene, glTFAnimations: IAnimation[], nodeMap: { [key: number]: number }, nodes: INode[], binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, animationSampleRate: number) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonScene.animationGroups) {\r\n            let animationGroups = babylonScene.animationGroups;\r\n\r\n            for (let animationGroup of animationGroups) {\r\n                glTFAnimation = {\r\n                    name: animationGroup.name,\r\n                    channels: [],\r\n                    samplers: []\r\n                };\r\n                for (let targetAnimation of animationGroup.targetedAnimations) {\r\n                    let target = targetAnimation.target;\r\n                    let animation = targetAnimation.animation;\r\n                    if (target instanceof Mesh || target.length === 1 && target[0] instanceof Mesh) { // TODO: Update to support bones\r\n                        let animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            let babylonMesh = target instanceof Mesh ? target : target[0] as Mesh;\r\n                            _GLTFAnimation.AddAnimation(`${animation.name}`,\r\n                                glTFAnimation,\r\n                                babylonMesh,\r\n                                animation,\r\n                                animationInfo.dataAccessorType,\r\n                                animationInfo.animationChannelTargetPath,\r\n                                nodeMap,\r\n                                binaryWriter,\r\n                                bufferViews,\r\n                                accessors,\r\n                                convertToRightHandedSystem,\r\n                                animationInfo.useQuaternion,\r\n                                animationSampleRate\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n                if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {\r\n                    glTFAnimations.push(glTFAnimation);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static AddAnimation(name: string, glTFAnimation: IAnimation, babylonTransformNode: TransformNode, animation: Animation, dataAccessorType: AccessorType, animationChannelTargetPath: AnimationChannelTargetPath, nodeMap: { [key: number]: number }, binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, useQuaternion: boolean, animationSampleRate: number) {\r\n        let animationData = _GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion, animationSampleRate);\r\n        let bufferView: IBufferView;\r\n        let accessor: IAccessor;\r\n        let keyframeAccessorIndex: number;\r\n        let dataAccessorIndex: number;\r\n        let outputLength: number;\r\n        let animationSampler: IAnimationSampler;\r\n        let animationChannel: IAnimationChannel;\r\n\r\n        if (animationData) {\r\n            let nodeIndex = nodeMap[babylonTransformNode.uniqueId];\r\n\r\n            // Creates buffer view and accessor for key frames.\r\n            let byteLength = animationData.inputs.length * 4;\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  keyframe data view`);\r\n            bufferViews.push(bufferView);\r\n\r\n            animationData.inputs.forEach(function(input) {\r\n                binaryWriter.setFloat32(input);\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  keyframes`, AccessorType.SCALAR, AccessorComponentType.FLOAT, animationData.inputs.length, null, [animationData.inputsMin], [animationData.inputsMax]);\r\n            accessors.push(accessor);\r\n            keyframeAccessorIndex = accessors.length - 1;\r\n\r\n            // create bufferview and accessor for keyed values.\r\n            outputLength = animationData.outputs.length;\r\n            byteLength = dataAccessorType === AccessorType.VEC3 ? animationData.outputs.length * 12 : animationData.outputs.length * 16;\r\n\r\n            // check for in and out tangents\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  data view`);\r\n            bufferViews.push(bufferView);\r\n\r\n            animationData.outputs.forEach(function(output) {\r\n                output.forEach(function(entry) {\r\n                    binaryWriter.setFloat32(entry);\r\n                });\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  data`, dataAccessorType, AccessorComponentType.FLOAT, outputLength, null, null, null);\r\n            accessors.push(accessor);\r\n            dataAccessorIndex = accessors.length - 1;\r\n\r\n            // create sampler\r\n            animationSampler = {\r\n                interpolation: animationData.samplerInterpolation,\r\n                input: keyframeAccessorIndex,\r\n                output: dataAccessorIndex\r\n            };\r\n            glTFAnimation.samplers.push(animationSampler);\r\n\r\n            // create channel\r\n            animationChannel = {\r\n                sampler: glTFAnimation.samplers.length - 1,\r\n                target: {\r\n                    node: nodeIndex,\r\n                    path: animationChannelTargetPath\r\n                }\r\n            };\r\n            glTFAnimation.channels.push(animationChannel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a baked animation\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation corresponding to the BabylonJS mesh\r\n     * @param animationChannelTargetPath animation target channel\r\n     * @param minFrame minimum animation frame\r\n     * @param maxFrame maximum animation frame\r\n     * @param fps frames per second of the animation\r\n     * @param inputs input key frames of the animation\r\n     * @param outputs output key frame data of the animation\r\n     * @param convertToRightHandedSystem converts the values to right-handed\r\n     * @param useQuaternion specifies if quaternions should be used\r\n     */\r\n    private static _CreateBakedAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, minFrame: number, maxFrame: number, fps: number, sampleRate: number, inputs: number[], outputs: number[][], minMaxFrames: { min: number, max: number }, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let value: number | Vector3 | Quaternion;\r\n        let quaternionCache: Quaternion = Quaternion.Identity();\r\n        let previousTime: Nullable<number> = null;\r\n        let time: number;\r\n        let maxUsedFrame: Nullable<number> = null;\r\n        let currKeyFrame: Nullable<IAnimationKey> = null;\r\n        let nextKeyFrame: Nullable<IAnimationKey> = null;\r\n        let prevKeyFrame: Nullable<IAnimationKey> = null;\r\n        let endFrame: Nullable<number> = null;\r\n        minMaxFrames.min = Tools.FloatRound(minFrame / fps);\r\n\r\n        let keyFrames = animation.getKeys();\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            endFrame = null;\r\n            currKeyFrame = keyFrames[i];\r\n\r\n            if (i + 1 < length) {\r\n                nextKeyFrame = keyFrames[i + 1];\r\n                if (currKeyFrame.value.equals(nextKeyFrame.value)) {\r\n                    if (i === 0) { // set the first frame to itself\r\n                        endFrame = currKeyFrame.frame;\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    endFrame = nextKeyFrame.frame;\r\n                }\r\n            }\r\n            else {\r\n                // at the last key frame\r\n                prevKeyFrame = keyFrames[i - 1];\r\n                if (currKeyFrame.value.equals(prevKeyFrame.value)) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    endFrame = maxFrame;\r\n                }\r\n            }\r\n            if (endFrame) {\r\n                for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {\r\n                    time = Tools.FloatRound(f / fps);\r\n                    if (time === previousTime) {\r\n                        continue;\r\n                    }\r\n                    previousTime = time;\r\n                    maxUsedFrame = time;\r\n                    value = animation._interpolate(f, 0, undefined, animation.loopMode);\r\n\r\n                    _GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n                }\r\n            }\r\n        }\r\n        if (maxUsedFrame) {\r\n            minMaxFrames.max = maxUsedFrame;\r\n        }\r\n    }\r\n\r\n    private static _ConvertFactorToVector3OrQuaternion(factor: number, babylonTransformNode: TransformNode, animation: Animation, animationType: number, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean): Nullable<Vector3 | Quaternion> {\r\n        let property: string[];\r\n        let componentName: string;\r\n        let value: Nullable<Quaternion | Vector3> = null;\r\n        const basePositionRotationOrScale = _GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n        if (animationType === Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n            property = animation.targetProperty.split('.');\r\n            componentName = property ? property[1] : ''; // x, y, or z component\r\n            value = useQuaternion ? BABYLON.Quaternion.FromArray(basePositionRotationOrScale).normalize() : BABYLON.Vector3.FromArray(basePositionRotationOrScale);\r\n\r\n            switch (componentName) {\r\n                case 'x': {\r\n                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'y': {\r\n                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'z': {\r\n                    value[componentName] = (convertToRightHandedSystem && !useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'w': {\r\n                    (value as Quaternion).w = factor;\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`glTFAnimation: Unsupported component type \"${componentName}\" for scale animation!`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    private static _SetInterpolatedValue(babylonTransformNode: TransformNode, value: Nullable<number | Vector3 | Quaternion>, time: number, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, quaternionCache: Quaternion, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        const animationType = animation.dataType;\r\n        let cacheValue: Vector3 | Quaternion;\r\n        inputs.push(time);\r\n        if (typeof value === \"number\") {\r\n            value = this._ConvertFactorToVector3OrQuaternion(value as number, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n        if (value) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (useQuaternion) {\r\n                    quaternionCache = value as Quaternion;\r\n                }\r\n                else {\r\n                    cacheValue = value as Vector3;\r\n                    Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);\r\n                }\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedQuaternionFromRef(quaternionCache);\r\n\r\n                    if (!babylonTransformNode.parent) {\r\n                        quaternionCache = Quaternion.FromArray([0, 1, 0, 0]).multiply(quaternionCache);\r\n                    }\r\n                }\r\n                outputs.push(quaternionCache.asArray());\r\n            }\r\n            else {\r\n                cacheValue = value as Vector3;\r\n                if (convertToRightHandedSystem && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) {\r\n                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(cacheValue);\r\n                    if (!babylonTransformNode.parent) {\r\n                        cacheValue.x *= -1;\r\n                        cacheValue.z *= -1;\r\n                    }\r\n                }\r\n\r\n                outputs.push(cacheValue.asArray());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates linear animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateLinearOrStepAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, frameDelta: number, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        for (let keyFrame of animation.getKeys()) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates cubic spline animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateCubicSplineAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, frameDelta: number, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        animation.getKeys().forEach(function(keyFrame) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation.AddSplineTangent(\r\n                babylonTransformNode,\r\n                _TangentType.INTANGENT,\r\n                outputs,\r\n                animationChannelTargetPath,\r\n                AnimationSamplerInterpolation.CUBICSPLINE,\r\n                keyFrame,\r\n                frameDelta,\r\n                useQuaternion,\r\n                convertToRightHandedSystem\r\n            );\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);\r\n\r\n            _GLTFAnimation.AddSplineTangent(\r\n                babylonTransformNode,\r\n                _TangentType.OUTTANGENT,\r\n                outputs,\r\n                animationChannelTargetPath,\r\n                AnimationSamplerInterpolation.CUBICSPLINE,\r\n                keyFrame,\r\n                frameDelta,\r\n                useQuaternion,\r\n                convertToRightHandedSystem\r\n            );\r\n        });\r\n    }\r\n\r\n    private static _GetBasePositionRotationOrScale(babylonTransformNode: TransformNode, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let basePositionRotationOrScale: number[];\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                if (babylonTransformNode.rotationQuaternion) {\r\n                    basePositionRotationOrScale = babylonTransformNode.rotationQuaternion.asArray();\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(basePositionRotationOrScale);\r\n                        if (!babylonTransformNode.parent) {\r\n                            basePositionRotationOrScale = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(basePositionRotationOrScale)).asArray();\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    basePositionRotationOrScale = BABYLON.Quaternion.Identity().asArray();\r\n                }\r\n            }\r\n            else {\r\n                basePositionRotationOrScale = babylonTransformNode.rotation.asArray();\r\n                _GLTFUtilities._GetRightHandedNormalArray3FromRef(basePositionRotationOrScale);\r\n            }\r\n        }\r\n        else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n            basePositionRotationOrScale = babylonTransformNode.position.asArray();\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedPositionArray3FromRef(basePositionRotationOrScale);\r\n            }\r\n        }\r\n        else { // scale\r\n            basePositionRotationOrScale = babylonTransformNode.scaling.asArray();\r\n        }\r\n        return basePositionRotationOrScale;\r\n    }\r\n\r\n    /**\r\n     * Adds a key frame value\r\n     * @param keyFrame\r\n     * @param animation\r\n     * @param outputs\r\n     * @param animationChannelTargetPath\r\n     * @param basePositionRotationOrScale\r\n     * @param convertToRightHandedSystem\r\n     * @param useQuaternion\r\n     */\r\n    private static _AddKeyframeValue(keyFrame: IAnimationKey, animation: Animation, outputs: number[][], animationChannelTargetPath: AnimationChannelTargetPath, babylonTransformNode: TransformNode, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let value: number[];\r\n        let newPositionRotationOrScale: Nullable<Vector3 | Quaternion>;\r\n        const animationType = animation.dataType;\r\n        if (animationType === Animation.ANIMATIONTYPE_VECTOR3) {\r\n            value = keyFrame.value.asArray();\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                const array = Vector3.FromArray(value);\r\n                let rotationQuaternion = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n\r\n                    if (!babylonTransformNode.parent) {\r\n                        rotationQuaternion = Quaternion.FromArray([0, 1, 0, 0]).multiply(rotationQuaternion);\r\n                    }\r\n                }\r\n                value = rotationQuaternion.asArray();\r\n            }\r\n            else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedNormalArray3FromRef(value);\r\n                    if (!babylonTransformNode.parent) {\r\n                        value[0] *= -1;\r\n                        value[2] *= -1;\r\n                    }\r\n                }\r\n            }\r\n            outputs.push(value); // scale  vector.\r\n\r\n        }\r\n        else if (animationType === Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n            newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(keyFrame.value as number, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n            if (newPositionRotationOrScale) {\r\n                if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                    let posRotScale = useQuaternion ? newPositionRotationOrScale as Quaternion : Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionFromRef(posRotScale);\r\n\r\n                        if (!babylonTransformNode.parent) {\r\n                            posRotScale = Quaternion.FromArray([0, 1, 0, 0]).multiply(posRotScale);\r\n                        }\r\n                    }\r\n                    outputs.push(posRotScale.asArray());\r\n                }\r\n                else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(newPositionRotationOrScale as Vector3);\r\n\r\n                        if (!babylonTransformNode.parent) {\r\n                            newPositionRotationOrScale.x *= -1;\r\n                            newPositionRotationOrScale.z *= -1;\r\n                        }\r\n                    }\r\n                }\r\n                outputs.push(newPositionRotationOrScale.asArray());\r\n            }\r\n        }\r\n        else if (animationType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            value = (keyFrame.value as Quaternion).normalize().asArray();\r\n\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(value);\r\n\r\n                if (!babylonTransformNode.parent) {\r\n                    value = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(value)).asArray();\r\n                }\r\n            }\r\n\r\n            outputs.push(value);\r\n        }\r\n        else {\r\n            Tools.Error('glTFAnimation: Unsupported key frame values for animation!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine the interpolation based on the key frames\r\n     * @param keyFrames\r\n     * @param animationChannelTargetPath\r\n     * @param useQuaternion\r\n     */\r\n    private static _DeduceInterpolation(keyFrames: IAnimationKey[], animationChannelTargetPath: AnimationChannelTargetPath, useQuaternion: boolean): { interpolationType: AnimationSamplerInterpolation, shouldBakeAnimation: boolean } {\r\n        let interpolationType: AnimationSamplerInterpolation | undefined;\r\n        let shouldBakeAnimation = false;\r\n        let key: IAnimationKey;\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION && !useQuaternion) {\r\n            return { interpolationType: AnimationSamplerInterpolation.LINEAR, shouldBakeAnimation: true };\r\n        }\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            key = keyFrames[i];\r\n            if (key.inTangent || key.outTangent) {\r\n                if (interpolationType) {\r\n                    if (interpolationType !== AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    interpolationType = AnimationSamplerInterpolation.CUBICSPLINE;\r\n                }\r\n            }\r\n            else {\r\n                if (interpolationType) {\r\n                    if (interpolationType === AnimationSamplerInterpolation.CUBICSPLINE ||\r\n                        (key.interpolation && (key.interpolation === AnimationKeyInterpolation.STEP) && interpolationType !== AnimationSamplerInterpolation.STEP)) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (key.interpolation && (key.interpolation === AnimationKeyInterpolation.STEP)) {\r\n                        interpolationType = AnimationSamplerInterpolation.STEP;\r\n                    }\r\n                    else {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!interpolationType) {\r\n            interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n        }\r\n\r\n        return { interpolationType: interpolationType, shouldBakeAnimation: shouldBakeAnimation };\r\n    }\r\n\r\n    /**\r\n     * Adds an input tangent or output tangent to the output data\r\n     * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion\r\n     * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)\r\n     * @param outputs The animation data by keyframe\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param interpolation The interpolation type\r\n     * @param keyFrame The key frame with the animation data\r\n     * @param frameDelta Time difference between two frames used to scale the tangent by the frame delta\r\n     * @param useQuaternion Specifies if quaternions are used\r\n     * @param convertToRightHandedSystem Specifies if the values should be converted to right-handed\r\n     */\r\n    private static AddSplineTangent(babylonTransformNode: TransformNode, tangentType: _TangentType, outputs: number[][], animationChannelTargetPath: AnimationChannelTargetPath, interpolation: AnimationSamplerInterpolation, keyFrame: IAnimationKey, frameDelta: number, useQuaternion: boolean, convertToRightHandedSystem: boolean) {\r\n        let tangent: number[];\r\n        let tangentValue: Vector3 | Quaternion = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;\r\n        if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (tangentValue) {\r\n                    if (useQuaternion) {\r\n                        tangent = (tangentValue as Quaternion).scale(frameDelta).asArray();\r\n                    }\r\n                    else {\r\n                        const array = (tangentValue as Vector3).scale(frameDelta);\r\n                        tangent = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();\r\n                    }\r\n\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(tangent);\r\n                        if (!babylonTransformNode.parent) {\r\n                            tangent = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(tangent)).asArray();\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    tangent = [0, 0, 0, 0];\r\n                }\r\n            }\r\n            else {\r\n                if (tangentValue) {\r\n                    tangent = (tangentValue as Vector3).scale(frameDelta).asArray();\r\n                    if (convertToRightHandedSystem) {\r\n                        if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                            _GLTFUtilities._GetRightHandedPositionArray3FromRef(tangent);\r\n                            if (!babylonTransformNode.parent) {\r\n                                tangent[0] *= -1; // x\r\n                                tangent[2] *= -1; // z\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    tangent = [0, 0, 0];\r\n                }\r\n            }\r\n\r\n            outputs.push(tangent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the minimum and maximum key frames' frame values\r\n     * @param keyFrames animation key frames\r\n     * @returns the minimum and maximum key frame value\r\n     */\r\n    private static calculateMinMaxKeyFrames(keyFrames: IAnimationKey[]): { min: number, max: number } {\r\n        let min: number = Infinity;\r\n        let max: number = -Infinity;\r\n        keyFrames.forEach(function(keyFrame) {\r\n            min = Math.min(min, keyFrame.frame);\r\n            max = Math.max(max, keyFrame.frame);\r\n        });\r\n\r\n        return { min: min, max: max };\r\n\r\n    }\r\n}","import { ImageMimeType } from \"babylonjs-gltf2interface\";\r\n\r\n/**\r\n * Class for holding and downloading glTF file data\r\n */\r\nexport class GLTFData {\r\n    /**\r\n     * Object which contains the file name as the key and its data as the value\r\n     */\r\n    glTFFiles: { [fileName: string]: string | Blob };\r\n\r\n    /**\r\n     * Initializes the glTF file object\r\n     */\r\n    public constructor() {\r\n        this.glTFFiles = {};\r\n    }\r\n\r\n    /**\r\n     * Downloads the glTF data as files based on their names and data\r\n     */\r\n    public downloadFiles(): void {\r\n        /**\r\n        * Checks for a matching suffix at the end of a string (for ES5 and lower)\r\n        * @param str Source string\r\n        * @param suffix Suffix to search for in the source string\r\n        * @returns Boolean indicating whether the suffix was found (true) or not (false)\r\n        */\r\n        function endsWith(str: string, suffix: string): boolean {\r\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n        }\r\n\r\n        for (let key in this.glTFFiles) {\r\n            let link = document.createElement('a');\r\n            document.body.appendChild(link);\r\n            link.setAttribute(\"type\", \"hidden\");\r\n            link.download = key;\r\n            let blob = this.glTFFiles[key];\r\n            let mimeType;\r\n\r\n            if (endsWith(key, \".glb\")) {\r\n                mimeType = { type: \"model/gltf-binary\" };\r\n            }\r\n            else if (endsWith(key, \".bin\")) {\r\n                mimeType = { type: \"application/octet-stream\" };\r\n            }\r\n            else if (endsWith(key, \".gltf\")) {\r\n                mimeType = { type: \"model/gltf+json\" };\r\n            }\r\n            else if (endsWith(key, \".jpeg\" || \".jpg\")) {\r\n                mimeType = {type: ImageMimeType.JPEG};\r\n            }\r\n            else if (endsWith(key, \".png\")) {\r\n                mimeType = {type: ImageMimeType.PNG};\r\n            }\r\n\r\n            link.href = window.URL.createObjectURL(new Blob([blob], mimeType));\r\n            link.click();\r\n        }\r\n    }\r\n}\r\n","import { Scene, TransformNode, Node, Engine, Nullable, Texture, BaseTexture, SubMesh, Tools, Viewport, IndicesArray, Material, FloatArray, Mesh, VertexBuffer, Vector2, Vector3, Vector4, Quaternion, InstancedMesh, AbstractMesh, LinesMesh, Color3, MultiMaterial } from \"babylonjs\";\r\nimport { AccessorType, IBufferView, IAccessor, INode, IAsset, IScene, IMesh, IMaterial, ITexture, IImage, ISampler, IAnimation, ImageMimeType, IMeshPrimitive, IBuffer, IGLTF, MeshPrimitiveMode, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\n\r\nimport { IGLTFExporterExtensionV2 } from \"./glTFExporterExtension\";\r\nimport { _GLTFMaterialExporter } from \"./glTFMaterialExporter\";\r\nimport { IExportOptions } from \"./glTFSerializer\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _GLTFAnimation } from \"./glTFAnimation\";\r\n\r\n/**\r\n * Utility interface for storing vertex attribute data\r\n * @hidden\r\n */\r\ninterface _IVertexAttributeData {\r\n    /**\r\n     * Specifies the Babylon Vertex Buffer Type (Position, Normal, Color, etc.)\r\n    */\r\n    kind: string;\r\n\r\n    /**\r\n     * Specifies the glTF Accessor Type (VEC2, VEC3, etc.)\r\n    */\r\n    accessorType: AccessorType;\r\n\r\n    /**\r\n     * Specifies the BufferView index for the vertex attribute data\r\n    */\r\n    bufferViewIndex?: number;\r\n\r\n    byteStride?: number;\r\n}\r\n/**\r\n * Converts Babylon Scene into glTF 2.0.\r\n * @hidden\r\n */\r\nexport class _Exporter {\r\n    /**\r\n     * Stores all generated buffer views, which represents views into the main glTF buffer data\r\n     */\r\n    public _bufferViews: IBufferView[];\r\n    /**\r\n     * Stores all the generated accessors, which is used for accessing the data within the buffer views in glTF\r\n     */\r\n    public _accessors: IAccessor[];\r\n    /**\r\n     * Stores all the generated nodes, which contains transform and/or mesh information per node\r\n     */\r\n    private _nodes: INode[];\r\n    /**\r\n     * Stores the glTF asset information, which represents the glTF version and this file generator\r\n     */\r\n    private _asset: IAsset;\r\n    /**\r\n     * Stores all the generated glTF scenes, which stores multiple node hierarchies\r\n     */\r\n    private _scenes: IScene[];\r\n    /**\r\n     * Stores all the generated mesh information, each containing a set of primitives to render in glTF\r\n     */\r\n    private _meshes: IMesh[];\r\n    /**\r\n     * Stores all the generated material information, which represents the appearance of each primitive\r\n     */\r\n    public _materials: IMaterial[];\r\n\r\n    public _materialMap: { [materialID: number]: number };\r\n    /**\r\n     * Stores all the generated texture information, which is referenced by glTF materials\r\n     */\r\n    public _textures: ITexture[];\r\n    /**\r\n     * Stores all the generated image information, which is referenced by glTF textures\r\n     */\r\n    public _images: IImage[];\r\n\r\n    /**\r\n     * Stores all the texture samplers\r\n     */\r\n    public _samplers: ISampler[];\r\n    /**\r\n     * Stores all the generated animation samplers, which is referenced by glTF animations\r\n     */\r\n    /**\r\n     * Stores the animations for glTF models\r\n     */\r\n    private _animations: IAnimation[];\r\n    /**\r\n     * Stores the total amount of bytes stored in the glTF buffer\r\n     */\r\n    private _totalByteLength: number;\r\n    /**\r\n     * Stores a reference to the Babylon scene containing the source geometry and material information\r\n     */\r\n    private _babylonScene: Scene;\r\n    /**\r\n     * Stores a map of the image data, where the key is the file name and the value\r\n     * is the image data\r\n     */\r\n    public _imageData: { [fileName: string]: { data: Uint8Array, mimeType: ImageMimeType } };\r\n\r\n    /**\r\n     * Stores a map of the unique id of a node to its index in the node array\r\n     */\r\n    private _nodeMap: { [key: number]: number };\r\n\r\n    /**\r\n     * Specifies if the Babylon scene should be converted to right-handed on export\r\n     */\r\n    private _convertToRightHandedSystem: boolean;\r\n\r\n    /**\r\n     * Baked animation sample rate\r\n     */\r\n    private _animationSampleRate: number;\r\n\r\n    /**\r\n     * Callback which specifies if a transform node should be exported or not\r\n     */\r\n    private _shouldExportTransformNode: ((babylonTransformNode: TransformNode) => boolean);\r\n\r\n    private _localEngine: Engine;\r\n\r\n    public _glTFMaterialExporter: _GLTFMaterialExporter;\r\n\r\n    private _extensions: { [name: string]: IGLTFExporterExtensionV2 } = {};\r\n\r\n    private _extensionsUsed: string[];\r\n    private _extensionsRequired: string[];\r\n\r\n    private static _ExtensionNames = new Array<string>();\r\n    private static _ExtensionFactories: { [name: string]: (exporter: _Exporter) => IGLTFExporterExtensionV2 } = {};\r\n\r\n    private _applyExtensions<T>(property: any, actionAsync: (extension: IGLTFExporterExtensionV2) => Nullable<T> | undefined): Nullable<T> {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                const exporterProperty = property as any;\r\n                exporterProperty._activeLoaderExtensions = exporterProperty._activeLoaderExtensions || {};\r\n                const activeLoaderExtensions = exporterProperty._activeLoaderExtensions;\r\n                if (!activeLoaderExtensions[name]) {\r\n                    activeLoaderExtensions[name] = true;\r\n\r\n                    try {\r\n                        const result = actionAsync(extension);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    }\r\n                    finally {\r\n                        delete activeLoaderExtensions[name];\r\n                        delete exporterProperty._activeLoaderExtensions;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    public _extensionsPreExportTextureAsync(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(babylonTexture, (extension) => extension.preExportTextureAsync && extension.preExportTextureAsync(context, babylonTexture, mimeType));\r\n    }\r\n\r\n    public _extensionsPostExportMeshPrimitiveAsync(context: string, meshPrimitive: IMeshPrimitive, babylonSubMesh: SubMesh, binaryWriter: _BinaryWriter): Nullable<Promise<IMeshPrimitive>> {\r\n        return this._applyExtensions(meshPrimitive, (extension) => extension.postExportMeshPrimitiveAsync && extension.postExportMeshPrimitiveAsync(context, meshPrimitive, babylonSubMesh, binaryWriter));\r\n    }\r\n\r\n    /**\r\n     * Load glTF serializer extensions\r\n     */\r\n    private _loadExtensions(): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = _Exporter._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF Exporter instance, which can accept optional exporter options\r\n     * @param babylonScene Babylon scene object\r\n     * @param options Options to modify the behavior of the exporter\r\n     */\r\n    public constructor(babylonScene: Scene, options?: IExportOptions) {\r\n        this._asset = { generator: \"BabylonJS\", version: \"2.0\" };\r\n        this._extensionsUsed = [];\r\n        this._extensionsRequired = [];\r\n        this._babylonScene = babylonScene;\r\n        this._bufferViews = [];\r\n        this._accessors = [];\r\n        this._meshes = [];\r\n        this._scenes = [];\r\n        this._nodes = [];\r\n        this._images = [];\r\n        this._materials = [];\r\n        this._materialMap = [];\r\n        this._textures = [];\r\n        this._samplers = [];\r\n        this._animations = [];\r\n        this._imageData = {};\r\n        this._convertToRightHandedSystem = this._babylonScene.useRightHandedSystem ? false : true;\r\n        const _options = options || {};\r\n        this._shouldExportTransformNode = _options.shouldExportTransformNode ? _options.shouldExportTransformNode : (babylonTransformNode: TransformNode) => true;\r\n        this._animationSampleRate = _options.animationSampleRate ? _options.animationSampleRate : 1 / 60;\r\n\r\n        this._glTFMaterialExporter = new _GLTFMaterialExporter(this);\r\n        this._loadExtensions();\r\n    }\r\n\r\n    /**\r\n     * Registers a glTF exporter extension\r\n     * @param name Name of the extension to export\r\n     * @param factory The factory function that creates the exporter extension\r\n     */\r\n    public static RegisterExtension(name: string, factory: (exporter: _Exporter) => IGLTFExporterExtensionV2): void {\r\n        if (_Exporter.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name ${name} already exists`);\r\n        }\r\n\r\n        _Exporter._ExtensionFactories[name] = factory;\r\n        _Exporter._ExtensionNames.push(name);\r\n    }\r\n\r\n    /**\r\n     * Un-registers an exporter extension\r\n     * @param name The name fo the exporter extension\r\n     * @returns A boolean indicating whether the extension has been un-registered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!_Exporter._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n        delete _Exporter._ExtensionFactories[name];\r\n\r\n        const index = _Exporter._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            _Exporter._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Lazy load a local engine with premultiplied alpha set to false\r\n     */\r\n    public _getLocalEngine(): Engine {\r\n        if (!this._localEngine) {\r\n            const localCanvas = document.createElement('canvas');\r\n            localCanvas.id = \"WriteCanvas\";\r\n            localCanvas.width = 2048;\r\n            localCanvas.height = 2048;\r\n            this._localEngine = new Engine(localCanvas, true, { premultipliedAlpha: false, preserveDrawingBuffer: true });\r\n            this._localEngine.setViewport(new Viewport(0, 0, 1, 1));\r\n        }\r\n\r\n        return this._localEngine;\r\n    }\r\n\r\n    private reorderIndicesBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, babylonIndices: IndicesArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                if (!byteOffset) { byteOffset = 0; }\r\n                for (let i = submesh.indexStart, length = submesh.indexStart + submesh.indexCount; i < length; i = i + 3) {\r\n                    const index = byteOffset + i * 4;\r\n                    // swap the second and third indices\r\n                    const secondIndex = binaryWriter.getUInt32(index + 4);\r\n                    const thirdIndex = binaryWriter.getUInt32(index + 8);\r\n                    binaryWriter.setUInt32(thirdIndex, index + 4);\r\n                    binaryWriter.setUInt32(secondIndex, index + 8);\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                for (let i = submesh.indexStart + submesh.indexCount - 1, start = submesh.indexStart; i >= start; --i) {\r\n                    binaryWriter.setUInt32(babylonIndices[i], byteOffset);\r\n                    byteOffset += 4;\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                if (submesh.indexCount >= 3) {\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 2], byteOffset + 4);\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 1], byteOffset + 8);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attribute data based on the primitive mode.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderVertexAttributeDataBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter): void {\r\n        if (this._convertToRightHandedSystem && sideOrientation === Material.ClockWiseSideOrientation) {\r\n            switch (primitiveMode) {\r\n                case Material.TriangleFillMode: {\r\n                    this.reorderTriangleFillMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                    break;\r\n                }\r\n                case Material.TriangleStripDrawMode: {\r\n                    this.reorderTriangleStripDrawMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                    break;\r\n                }\r\n                case Material.TriangleFanDrawMode: {\r\n                    this.reorderTriangleFanMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle mode order .  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderTriangleFillMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            let stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n            if (submesh.verticesCount % 3 !== 0) {\r\n                Tools.Error('The submesh vertices for the triangle fill mode is not divisible by 3!');\r\n            }\r\n            else {\r\n                let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n                let index = 0;\r\n                switch (vertexBufferKind) {\r\n                    case VertexBuffer.PositionKind:\r\n                    case VertexBuffer.NormalKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.TangentKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.ColorKind: {\r\n                        const size = vertexBuffer.getSize();\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + size) {\r\n                            index = x * stride;\r\n                            if (size === 4) {\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                            else {\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.UVKind:\r\n                    case VertexBuffer.UV2Kind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                    }\r\n                }\r\n                this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter);\r\n            }\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleFillMode: Vertex Buffer Kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle strip order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderTriangleStripDrawMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            const stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    index = submesh.verticesStart;\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        vertexBuffer.getSize() === 4 ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index)) : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this.writeVertexAttributeData(vertexData, byteOffset + 12, vertexBufferKind, meshAttributeArray, binaryWriter);\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleStripDrawMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle fan order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderTriangleFanMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            let stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                        vertexBuffer.getSize() === 4 ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index)) : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter);\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleFanMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes the vertex attribute data to binary\r\n     * @param vertices The vertices to write to the binary writer\r\n     * @param byteOffset The offset into the binary writer to overwrite binary data\r\n     * @param vertexAttributeKind The vertex attribute type\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param binaryWriter The writer containing the binary data\r\n     */\r\n    private writeVertexAttributeData(vertices: Vector2[] | Vector3[] | Vector4[], byteOffset: number, vertexAttributeKind: string, meshAttributeArray: FloatArray, binaryWriter: _BinaryWriter) {\r\n        for (let vertex of vertices) {\r\n            if (this._convertToRightHandedSystem && !(vertexAttributeKind === VertexBuffer.ColorKind) && !(vertex instanceof Vector2)) {\r\n                if (vertex instanceof Vector3) {\r\n                    if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertex);\r\n                    }\r\n                    else if (vertexAttributeKind === VertexBuffer.PositionKind) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertex);\r\n                    }\r\n                    else {\r\n                        Tools.Error('Unsupported vertex attribute kind!');\r\n                    }\r\n                }\r\n                else {\r\n                    _GLTFUtilities._GetRightHandedVector4FromRef(vertex);\r\n                }\r\n            }\r\n            if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                vertex.normalize();\r\n            }\r\n            else if (vertexAttributeKind === VertexBuffer.TangentKind && vertex instanceof Vector4) {\r\n                _GLTFUtilities._NormalizeTangentFromRef(vertex);\r\n            }\r\n\r\n            for (let component of vertex.asArray()) {\r\n                binaryWriter.setFloat32(component, byteOffset);\r\n                byteOffset += 4;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes mesh attribute data to a data buffer\r\n     * Returns the bytelength of the data\r\n     * @param vertexBufferKind Indicates what kind of vertex data is being passed in\r\n     * @param meshAttributeArray Array containing the attribute data\r\n     * @param binaryWriter The buffer to write the binary data to\r\n     * @param indices Used to specify the order of the vertex data\r\n     */\r\n    public writeAttributeData(vertexBufferKind: string, meshAttributeArray: FloatArray, byteStride: number, binaryWriter: _BinaryWriter) {\r\n        const stride = byteStride / 4;\r\n        let vertexAttributes: number[][] = [];\r\n        let index: number;\r\n\r\n        switch (vertexBufferKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (this._convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertexData);\r\n                    }\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (this._convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertexData);\r\n                    }\r\n                    vertexData.normalize();\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    if (this._convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedVector4FromRef(vertexData);\r\n                    }\r\n                    _GLTFUtilities._NormalizeTangentFromRef(vertexData);\r\n\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = stride === 3 ? Vector3.FromArray(meshAttributeArray, index) : Vector4.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    vertexAttributes.push(this._convertToRightHandedSystem ? [meshAttributeArray[index], meshAttributeArray[index + 1]] : [meshAttributeArray[index], meshAttributeArray[index + 1]]);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + vertexBufferKind);\r\n                vertexAttributes = [];\r\n            }\r\n        }\r\n        for (let vertexAttribute of vertexAttributes) {\r\n            for (let component of vertexAttribute) {\r\n                binaryWriter.setFloat32(component);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates glTF json data\r\n     * @param shouldUseGlb Indicates whether the json should be written for a glb file\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @param prettyPrint Indicates whether the json file should be pretty printed (true) or not (false)\r\n     * @returns json data as string\r\n     */\r\n    private generateJSON(shouldUseGlb: boolean, glTFPrefix?: string, prettyPrint?: boolean): string {\r\n        let buffer: IBuffer = { byteLength: this._totalByteLength };\r\n        let imageName: string;\r\n        let imageData: { data: Uint8Array, mimeType: ImageMimeType };\r\n        let bufferView: IBufferView;\r\n        let byteOffset: number = this._totalByteLength;\r\n\r\n        let glTF: IGLTF = {\r\n            asset: this._asset\r\n        };\r\n        if (this._extensionsUsed && this._extensionsUsed.length) {\r\n            glTF.extensionsUsed = this._extensionsUsed;\r\n        }\r\n        if (this._extensionsRequired && this._extensionsRequired.length) {\r\n            glTF.extensionsRequired = this._extensionsRequired;\r\n        }\r\n        if (buffer.byteLength) {\r\n            glTF.buffers = [buffer];\r\n        }\r\n        if (this._nodes && this._nodes.length) {\r\n            glTF.nodes = this._nodes;\r\n        }\r\n        if (this._meshes && this._meshes.length) {\r\n            glTF.meshes = this._meshes;\r\n        }\r\n        if (this._scenes && this._scenes.length) {\r\n            glTF.scenes = this._scenes;\r\n            glTF.scene = 0;\r\n        }\r\n        if (this._bufferViews && this._bufferViews.length) {\r\n            glTF.bufferViews = this._bufferViews;\r\n        }\r\n        if (this._accessors && this._accessors.length) {\r\n            glTF.accessors = this._accessors;\r\n        }\r\n        if (this._animations && this._animations.length) {\r\n            glTF.animations = this._animations;\r\n        }\r\n        if (this._materials && this._materials.length) {\r\n            glTF.materials = this._materials;\r\n        }\r\n        if (this._textures && this._textures.length) {\r\n            glTF.textures = this._textures;\r\n        }\r\n        if (this._samplers && this._samplers.length) {\r\n            glTF.samplers = this._samplers;\r\n        }\r\n        if (this._images && this._images.length) {\r\n            if (!shouldUseGlb) {\r\n                glTF.images = this._images;\r\n            }\r\n            else {\r\n                glTF.images = [];\r\n\r\n                this._images.forEach((image) => {\r\n                    if (image.uri) {\r\n                        imageData = this._imageData[image.uri];\r\n                        imageName = image.uri.split('.')[0] + \" image\";\r\n                        bufferView = _GLTFUtilities._CreateBufferView(0, byteOffset, imageData.data.length, undefined, imageName);\r\n                        byteOffset += imageData.data.buffer.byteLength;\r\n                        this._bufferViews.push(bufferView);\r\n                        image.bufferView = this._bufferViews.length - 1;\r\n                        image.name = imageName;\r\n                        image.mimeType = imageData.mimeType;\r\n                        image.uri = undefined;\r\n                        if (!glTF.images) {\r\n                            glTF.images = [];\r\n                        }\r\n                        glTF.images.push(image);\r\n                    }\r\n                });\r\n                // Replace uri with bufferview and mime type for glb\r\n                buffer.byteLength = byteOffset;\r\n            }\r\n        }\r\n\r\n        if (!shouldUseGlb) {\r\n            buffer.uri = glTFPrefix + \".bin\";\r\n        }\r\n\r\n        const jsonText = prettyPrint ? JSON.stringify(glTF, null, 2) : JSON.stringify(glTF);\r\n\r\n        return jsonText;\r\n    }\r\n\r\n    /**\r\n     * Generates data for .gltf and .bin files based on the glTF prefix string\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @returns GLTFData with glTF file data\r\n     */\r\n    public _generateGLTFAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            const jsonText = this.generateJSON(false, glTFPrefix, true);\r\n            const bin = new Blob([binaryBuffer], { type: 'application/octet-stream' });\r\n\r\n            const glTFFileName = glTFPrefix + '.gltf';\r\n            const glTFBinFile = glTFPrefix + '.bin';\r\n\r\n            const container = new GLTFData();\r\n\r\n            container.glTFFiles[glTFFileName] = jsonText;\r\n            container.glTFFiles[glTFBinFile] = bin;\r\n\r\n            if (this._imageData) {\r\n                for (let image in this._imageData) {\r\n                    container.glTFFiles[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });\r\n                }\r\n            }\r\n\r\n            return container;\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Creates a binary buffer for glTF\r\n     * @returns array buffer for binary data\r\n     */\r\n    private _generateBinaryAsync(): Promise<ArrayBuffer> {\r\n        let binaryWriter = new _BinaryWriter(4);\r\n        return this.createSceneAsync(this._babylonScene, binaryWriter).then(() => {\r\n            if (this._localEngine) {\r\n                this._localEngine.dispose();\r\n            }\r\n            return binaryWriter.getArrayBuffer();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Pads the number to a multiple of 4\r\n     * @param num number to pad\r\n     * @returns padded number\r\n     */\r\n    private _getPadding(num: number): number {\r\n        let remainder = num % 4;\r\n        let padding = remainder === 0 ? remainder : 4 - remainder;\r\n\r\n        return padding;\r\n    }\r\n\r\n    /**\r\n     * Generates a glb file from the json and binary data\r\n     * Returns an object with the glb file name as the key and data as the value\r\n     * @param glTFPrefix\r\n     * @returns object with glb filename as key and data as value\r\n     */\r\n    public _generateGLBAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            const jsonText = this.generateJSON(true);\r\n            const glbFileName = glTFPrefix + '.glb';\r\n            const headerLength = 12;\r\n            const chunkLengthPrefix = 8;\r\n            const jsonLength = jsonText.length;\r\n            let imageByteLength = 0;\r\n\r\n            for (let key in this._imageData) {\r\n                imageByteLength += this._imageData[key].data.byteLength;\r\n            }\r\n            const jsonPadding = this._getPadding(jsonLength);\r\n            const binPadding = this._getPadding(binaryBuffer.byteLength);\r\n            const imagePadding = this._getPadding(imageByteLength);\r\n\r\n            const byteLength = headerLength + (2 * chunkLengthPrefix) + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding + imageByteLength + imagePadding;\r\n\r\n            //header\r\n            const headerBuffer = new ArrayBuffer(headerLength);\r\n            const headerBufferView = new DataView(headerBuffer);\r\n            headerBufferView.setUint32(0, 0x46546C67, true); //glTF\r\n            headerBufferView.setUint32(4, 2, true); // version\r\n            headerBufferView.setUint32(8, byteLength, true); // total bytes in file\r\n\r\n            //json chunk\r\n            const jsonChunkBuffer = new ArrayBuffer(chunkLengthPrefix + jsonLength + jsonPadding);\r\n            const jsonChunkBufferView = new DataView(jsonChunkBuffer);\r\n            jsonChunkBufferView.setUint32(0, jsonLength + jsonPadding, true);\r\n            jsonChunkBufferView.setUint32(4, 0x4E4F534A, true);\r\n\r\n            //json chunk bytes\r\n            const jsonData = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix);\r\n            for (let i = 0; i < jsonLength; ++i) {\r\n                jsonData[i] = jsonText.charCodeAt(i);\r\n            }\r\n\r\n            //json padding\r\n            const jsonPaddingView = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix + jsonLength);\r\n            for (let i = 0; i < jsonPadding; ++i) {\r\n                jsonPaddingView[i] = 0x20;\r\n            }\r\n\r\n            //binary chunk\r\n            const binaryChunkBuffer = new ArrayBuffer(chunkLengthPrefix);\r\n            const binaryChunkBufferView = new DataView(binaryChunkBuffer);\r\n            binaryChunkBufferView.setUint32(0, binaryBuffer.byteLength + imageByteLength + imagePadding, true);\r\n            binaryChunkBufferView.setUint32(4, 0x004E4942, true);\r\n\r\n            // binary padding\r\n            const binPaddingBuffer = new ArrayBuffer(binPadding);\r\n            const binPaddingView = new Uint8Array(binPaddingBuffer);\r\n            for (let i = 0; i < binPadding; ++i) {\r\n                binPaddingView[i] = 0;\r\n            }\r\n\r\n            const imagePaddingBuffer = new ArrayBuffer(imagePadding);\r\n            const imagePaddingView = new Uint8Array(imagePaddingBuffer);\r\n            for (let i = 0; i < imagePadding; ++i) {\r\n                imagePaddingView[i] = 0;\r\n            }\r\n\r\n            const glbData = [headerBuffer, jsonChunkBuffer, binaryChunkBuffer, binaryBuffer];\r\n\r\n            // binary data\r\n            for (let key in this._imageData) {\r\n                glbData.push(this._imageData[key].data.buffer);\r\n            }\r\n            glbData.push(binPaddingBuffer);\r\n\r\n            glbData.push(imagePaddingBuffer);\r\n\r\n            const glbFile = new Blob(glbData, { type: 'application/octet-stream' });\r\n\r\n            const container = new GLTFData();\r\n            container.glTFFiles[glbFileName] = glbFile;\r\n\r\n            if (this._localEngine != null) {\r\n                this._localEngine.dispose();\r\n            }\r\n\r\n            return container;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the TRS for each node\r\n     * @param node glTF Node for storing the transformation data\r\n     * @param babylonTransformNode Babylon mesh used as the source for the transformation data\r\n     */\r\n    private setNodeTransformation(node: INode, babylonTransformNode: TransformNode): void {\r\n        if (!babylonTransformNode.getPivotPoint().equalsToFloats(0, 0, 0)) {\r\n            BABYLON.Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\r\n        }\r\n        if (!babylonTransformNode.position.equalsToFloats(0, 0, 0)) {\r\n            node.translation = this._convertToRightHandedSystem ? _GLTFUtilities._GetRightHandedPositionVector3(babylonTransformNode.position).asArray() : babylonTransformNode.position.asArray();\r\n        }\r\n\r\n        if (!babylonTransformNode.scaling.equalsToFloats(1, 1, 1)) {\r\n            node.scale = babylonTransformNode.scaling.asArray();\r\n        }\r\n\r\n        let rotationQuaternion = Quaternion.RotationYawPitchRoll(babylonTransformNode.rotation.y, babylonTransformNode.rotation.x, babylonTransformNode.rotation.z);\r\n        if (babylonTransformNode.rotationQuaternion) {\r\n            rotationQuaternion.multiplyInPlace(babylonTransformNode.rotationQuaternion);\r\n        }\r\n        if (!(rotationQuaternion.x === 0 && rotationQuaternion.y === 0 && rotationQuaternion.z === 0 && rotationQuaternion.w === 1)) {\r\n            if (this._convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n\r\n            }\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private getVertexBufferFromMesh(attributeKind: string, bufferMesh: Mesh): Nullable<VertexBuffer> {\r\n        if (bufferMesh.isVerticesDataPresent(attributeKind)) {\r\n            const vertexBuffer = bufferMesh.getVertexBuffer(attributeKind);\r\n            if (vertexBuffer) {\r\n                return vertexBuffer;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a bufferview based on the vertices type for the Babylon mesh\r\n     * @param kind Indicates the type of vertices data\r\n     * @param babylonTransformNode The Babylon mesh to get the vertices data from\r\n     * @param binaryWriter The buffer to write the bufferview data to\r\n     */\r\n    private createBufferViewKind(kind: string, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter, byteStride: number) {\r\n        const bufferMesh = babylonTransformNode instanceof Mesh ?\r\n            babylonTransformNode as Mesh : babylonTransformNode instanceof InstancedMesh ?\r\n                (babylonTransformNode as InstancedMesh).sourceMesh : null;\r\n\r\n        if (bufferMesh) {\r\n            const vertexData = bufferMesh.getVerticesData(kind);\r\n\r\n            if (vertexData) {\r\n                const byteLength = vertexData.length * 4;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, kind + \" - \" + bufferMesh.name);\r\n                this._bufferViews.push(bufferView);\r\n\r\n                this.writeAttributeData(\r\n                    kind,\r\n                    vertexData,\r\n                    byteStride,\r\n                    binaryWriter\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The primitive mode of the Babylon mesh\r\n     * @param babylonMesh The BabylonJS mesh\r\n     */\r\n    private getMeshPrimitiveMode(babylonMesh: AbstractMesh): number {\r\n        if (babylonMesh instanceof LinesMesh) {\r\n            return Material.LineListDrawMode;\r\n        }\r\n        return babylonMesh.material ? babylonMesh.material.fillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the primitive mode of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param primitiveMode The primitive mode\r\n     */\r\n    private setPrimitiveMode(meshPrimitive: IMeshPrimitive, primitiveMode: number) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                // glTF defaults to using Triangle Mode\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_STRIP;\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_FAN;\r\n                break;\r\n            }\r\n            case Material.PointListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n            }\r\n            case Material.PointFillMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n                break;\r\n            }\r\n            case Material.LineLoopDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_LOOP;\r\n                break;\r\n            }\r\n            case Material.LineListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINES;\r\n                break;\r\n            }\r\n            case Material.LineStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_STRIP;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex attribute accessor based of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param attributeKind vertex attribute\r\n     * @returns boolean specifying if uv coordinates are present\r\n     */\r\n    private setAttributeKind(meshPrimitive: IMeshPrimitive, attributeKind: string): void {\r\n        switch (attributeKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                meshPrimitive.attributes.POSITION = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                meshPrimitive.attributes.NORMAL = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                meshPrimitive.attributes.COLOR_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                meshPrimitive.attributes.TANGENT = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind: {\r\n                meshPrimitive.attributes.TEXCOORD_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UV2Kind: {\r\n                meshPrimitive.attributes.TEXCOORD_1 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + attributeKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets data for the primitive attributes of each submesh\r\n     * @param mesh glTF Mesh object to store the primitive attribute information\r\n     * @param babylonTransformNode Babylon mesh to get the primitive attribute data from\r\n     * @param binaryWriter Buffer to write the attribute data to\r\n     */\r\n    private setPrimitiveAttributesAsync(mesh: IMesh, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter): Promise<void> {\r\n        let promises: Promise<IMeshPrimitive>[] = [];\r\n        let bufferMesh: Nullable<Mesh> = null;\r\n        let bufferView: IBufferView;\r\n        let uvCoordsPresent: boolean;\r\n        let minMax: { min: Nullable<number[]>, max: Nullable<number[]> };\r\n\r\n        if (babylonTransformNode instanceof Mesh) {\r\n            bufferMesh = (babylonTransformNode as Mesh);\r\n        }\r\n        else if (babylonTransformNode instanceof InstancedMesh) {\r\n            bufferMesh = (babylonTransformNode as InstancedMesh).sourceMesh;\r\n        }\r\n        const attributeData: _IVertexAttributeData[] = [\r\n            { kind: VertexBuffer.PositionKind, accessorType: AccessorType.VEC3, byteStride: 12 },\r\n            { kind: VertexBuffer.NormalKind, accessorType: AccessorType.VEC3, byteStride: 12 },\r\n            { kind: VertexBuffer.ColorKind, accessorType: AccessorType.VEC4, byteStride: 16 },\r\n            { kind: VertexBuffer.TangentKind, accessorType: AccessorType.VEC4, byteStride: 16 },\r\n            { kind: VertexBuffer.UVKind, accessorType: AccessorType.VEC2, byteStride: 8 },\r\n            { kind: VertexBuffer.UV2Kind, accessorType: AccessorType.VEC2, byteStride: 8 },\r\n        ];\r\n\r\n        if (bufferMesh) {\r\n            let indexBufferViewIndex: Nullable<number> = null;\r\n            const primitiveMode = this.getMeshPrimitiveMode(bufferMesh);\r\n            let vertexAttributeBufferViews: { [attributeKind: string]: number } = {};\r\n\r\n            // For each BabylonMesh, create bufferviews for each 'kind'\r\n            for (const attribute of attributeData) {\r\n                const attributeKind = attribute.kind;\r\n                if (bufferMesh.isVerticesDataPresent(attributeKind)) {\r\n                    const vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                    attribute.byteStride = vertexBuffer ? vertexBuffer.getSize() * 4 : VertexBuffer.DeduceStride(attributeKind) * 4;\r\n                    if (attribute.byteStride === 12) {\r\n                        attribute.accessorType = AccessorType.VEC3;\r\n                    }\r\n\r\n                    this.createBufferViewKind(attributeKind, babylonTransformNode, binaryWriter, attribute.byteStride);\r\n                    attribute.bufferViewIndex = this._bufferViews.length - 1;\r\n                    vertexAttributeBufferViews[attributeKind] = attribute.bufferViewIndex;\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.getTotalIndices()) {\r\n                const indices = bufferMesh.getIndices();\r\n                if (indices) {\r\n                    const byteLength = indices.length * 4;\r\n                    bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, \"Indices - \" + bufferMesh.name);\r\n                    this._bufferViews.push(bufferView);\r\n                    indexBufferViewIndex = this._bufferViews.length - 1;\r\n\r\n                    for (let k = 0, length = indices.length; k < length; ++k) {\r\n                        binaryWriter.setUInt32(indices[k]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.subMeshes) {\r\n                // go through all mesh primitives (submeshes)\r\n                for (const submesh of bufferMesh.subMeshes) {\r\n                    uvCoordsPresent = false;\r\n                    let babylonMaterial = submesh.getMaterial() || bufferMesh.getScene().defaultMaterial;\r\n\r\n                    let materialIndex: Nullable<number> = null;\r\n                    if (babylonMaterial) {\r\n                        if (bufferMesh instanceof LinesMesh) {\r\n                            // get the color from the lines mesh and set it in the material\r\n                            const material: IMaterial = {\r\n                                name: bufferMesh.name + ' material'\r\n                            };\r\n                            if (!bufferMesh.color.equals(Color3.White()) || bufferMesh.alpha < 1) {\r\n                                material.pbrMetallicRoughness = {\r\n                                    baseColorFactor: bufferMesh.color.asArray().concat([bufferMesh.alpha])\r\n                                };\r\n                            }\r\n                            this._materials.push(material);\r\n                            materialIndex = this._materials.length - 1;\r\n                        }\r\n                        else if (babylonMaterial instanceof MultiMaterial) {\r\n                            const subMaterial = babylonMaterial.subMaterials[submesh.materialIndex];\r\n                            if (subMaterial) {\r\n                                babylonMaterial = subMaterial;\r\n                                materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                            }\r\n                        }\r\n                        else {\r\n                            materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                        }\r\n                    }\r\n\r\n                    let glTFMaterial: Nullable<IMaterial> = materialIndex != null ? this._materials[materialIndex] : null;\r\n\r\n                    const meshPrimitive: IMeshPrimitive = { attributes: {} };\r\n                    this.setPrimitiveMode(meshPrimitive, primitiveMode);\r\n\r\n                    for (const attribute of attributeData) {\r\n                        const attributeKind = attribute.kind;\r\n                        if (attributeKind === VertexBuffer.UVKind || attributeKind === VertexBuffer.UV2Kind) {\r\n                            if (glTFMaterial && !this._glTFMaterialExporter._hasTexturesPresent(glTFMaterial)) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        let vertexData = bufferMesh.getVerticesData(attributeKind);\r\n                        if (vertexData) {\r\n                            const vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                            if (vertexBuffer) {\r\n                                const stride = vertexBuffer.getSize();\r\n                                const bufferViewIndex = attribute.bufferViewIndex;\r\n                                if (bufferViewIndex != undefined) { // check to see if bufferviewindex has a numeric value assigned.\r\n                                    minMax = { min: null, max: null };\r\n                                    if (attributeKind == VertexBuffer.PositionKind) {\r\n                                        minMax = _GLTFUtilities._CalculateMinMaxPositions(vertexData, 0, vertexData.length / stride, this._convertToRightHandedSystem);\r\n                                    }\r\n                                    const accessor = _GLTFUtilities._CreateAccessor(bufferViewIndex, attributeKind + \" - \" + babylonTransformNode.name, attribute.accessorType, AccessorComponentType.FLOAT, vertexData.length / stride, 0, minMax.min, minMax.max);\r\n                                    this._accessors.push(accessor);\r\n                                    this.setAttributeKind(meshPrimitive, attributeKind);\r\n                                    if (meshPrimitive.attributes.TEXCOORD_0 != null || meshPrimitive.attributes.TEXCOORD_1 != null) {\r\n                                        uvCoordsPresent = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (indexBufferViewIndex) {\r\n                        // Create accessor\r\n                        const accessor = _GLTFUtilities._CreateAccessor(indexBufferViewIndex, \"indices - \" + babylonTransformNode.name, AccessorType.SCALAR, AccessorComponentType.UNSIGNED_INT, submesh.indexCount, submesh.indexStart * 4, null, null);\r\n                        this._accessors.push(accessor);\r\n                        meshPrimitive.indices = this._accessors.length - 1;\r\n                    }\r\n                    if (materialIndex != null && Object.keys(meshPrimitive.attributes).length > 0) {\r\n                        let sideOrientation = babylonMaterial.sideOrientation;\r\n\r\n                        if (this._convertToRightHandedSystem && sideOrientation === Material.ClockWiseSideOrientation) {\r\n                            //Overwrite the indices to be counter-clockwise\r\n                            let byteOffset = indexBufferViewIndex != null ? this._bufferViews[indexBufferViewIndex].byteOffset : null;\r\n                            if (byteOffset == null) { byteOffset = 0; }\r\n                            let babylonIndices: Nullable<IndicesArray> = null;\r\n                            if (indexBufferViewIndex != null) {\r\n                                babylonIndices = bufferMesh.getIndices();\r\n                            }\r\n                            if (babylonIndices) {\r\n                                this.reorderIndicesBasedOnPrimitiveMode(submesh, primitiveMode, babylonIndices, byteOffset, binaryWriter);\r\n                            }\r\n                            else {\r\n                                for (let attribute of attributeData) {\r\n                                    let vertexData = bufferMesh.getVerticesData(attribute.kind);\r\n                                    if (vertexData) {\r\n                                        let byteOffset = this._bufferViews[vertexAttributeBufferViews[attribute.kind]].byteOffset;\r\n                                        if (!byteOffset) {\r\n                                            byteOffset = 0;\r\n                                        }\r\n                                        this.reorderVertexAttributeDataBasedOnPrimitiveMode(submesh, primitiveMode, sideOrientation, attribute.kind, vertexData, byteOffset, binaryWriter);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (!uvCoordsPresent && this._glTFMaterialExporter._hasTexturesPresent(this._materials[materialIndex])) {\r\n                            const newMat = this._glTFMaterialExporter._stripTexturesFromMaterial(this._materials[materialIndex]);\r\n                            this._materials.push(newMat);\r\n                            materialIndex = this._materials.length - 1;\r\n                        }\r\n\r\n                        meshPrimitive.material = materialIndex;\r\n\r\n                    }\r\n                    mesh.primitives.push(meshPrimitive);\r\n\r\n                    const promise = this._extensionsPostExportMeshPrimitiveAsync(\"postExport\", meshPrimitive, submesh, binaryWriter);\r\n                    if (promise) {\r\n                        promises.push();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            /* do nothing */\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF scene based on the array of meshes\r\n     * Returns the the total byte offset\r\n     * @param babylonScene Babylon scene to get the mesh data from\r\n     * @param binaryWriter Buffer to write binary data to\r\n     */\r\n    private createSceneAsync(babylonScene: Scene, binaryWriter: _BinaryWriter): Promise<void> {\r\n        const scene: IScene = { nodes: [] };\r\n        let glTFNodeIndex: number;\r\n        let glTFNode: INode;\r\n        let directDescendents: Node[];\r\n        const nodes = [...babylonScene.transformNodes, ...babylonScene.meshes];\r\n\r\n        return this._glTFMaterialExporter._convertMaterialsToGLTFAsync(babylonScene.materials, ImageMimeType.PNG, true).then(() => {\r\n            return this.createNodeMapAndAnimationsAsync(babylonScene, nodes, this._shouldExportTransformNode, binaryWriter).then((nodeMap) => {\r\n                this._nodeMap = nodeMap;\r\n\r\n                this._totalByteLength = binaryWriter.getByteOffset();\r\n                if (this._totalByteLength == undefined) {\r\n                    throw new Error(\"undefined byte length!\");\r\n                }\r\n\r\n                // Build Hierarchy with the node map.\r\n                for (let babylonTransformNode of nodes) {\r\n                    glTFNodeIndex = this._nodeMap[babylonTransformNode.uniqueId];\r\n                    if (glTFNodeIndex != null) {\r\n                        glTFNode = this._nodes[glTFNodeIndex];\r\n                        if (!babylonTransformNode.parent) {\r\n                            if (!this._shouldExportTransformNode(babylonTransformNode)) {\r\n                                Tools.Log(\"Omitting \" + babylonTransformNode.name + \" from scene.\");\r\n                            }\r\n                            else {\r\n                                if (this._convertToRightHandedSystem) {\r\n                                    if (glTFNode.translation) {\r\n                                        glTFNode.translation[2] *= -1;\r\n                                        glTFNode.translation[0] *= -1;\r\n                                    }\r\n                                    glTFNode.rotation = glTFNode.rotation ? Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(glTFNode.rotation)).asArray() : (Quaternion.FromArray([0, 1, 0, 0])).asArray();\r\n                                }\r\n\r\n                                scene.nodes.push(glTFNodeIndex);\r\n                            }\r\n                        }\r\n\r\n                        directDescendents = babylonTransformNode.getDescendants(true);\r\n                        if (!glTFNode.children && directDescendents && directDescendents.length) {\r\n                            const children: number[] = [];\r\n                            for (let descendent of directDescendents) {\r\n                                if (this._nodeMap[descendent.uniqueId] != null) {\r\n                                    children.push(this._nodeMap[descendent.uniqueId]);\r\n                                }\r\n                            }\r\n                            if (children.length) {\r\n                                glTFNode.children = children;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (scene.nodes.length) {\r\n                    this._scenes.push(scene);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a mapping of Node unique id to node index and handles animations\r\n     * @param babylonScene Babylon Scene\r\n     * @param nodes Babylon transform nodes\r\n     * @param shouldExportTransformNode Callback specifying if a transform node should be exported\r\n     * @param binaryWriter Buffer to write binary data to\r\n     * @returns Node mapping of unique id to index\r\n     */\r\n    private createNodeMapAndAnimationsAsync(babylonScene: Scene, nodes: TransformNode[], shouldExportTransformNode: (babylonTransformNode: TransformNode) => boolean, binaryWriter: _BinaryWriter): Promise<{ [key: number]: number }> {\r\n        let promiseChain = Promise.resolve();\r\n        const nodeMap: { [key: number]: number } = {};\r\n        let nodeIndex: number;\r\n        let runtimeGLTFAnimation: IAnimation = {\r\n            name: 'runtime animations',\r\n            channels: [],\r\n            samplers: []\r\n        };\r\n        let idleGLTFAnimations: IAnimation[] = [];\r\n\r\n        for (let babylonTransformNode of nodes) {\r\n            if (shouldExportTransformNode(babylonTransformNode)) {\r\n                promiseChain = promiseChain.then(() => {\r\n                    return this.createNodeAsync(babylonTransformNode, binaryWriter).then((node) => {\r\n                        const directDescendents = babylonTransformNode.getDescendants(true, (node: Node) => { return (node instanceof TransformNode); });\r\n                        if (directDescendents.length || node.mesh != null) {\r\n                            this._nodes.push(node);\r\n                            nodeIndex = this._nodes.length - 1;\r\n                            nodeMap[babylonTransformNode.uniqueId] = nodeIndex;\r\n                        }\r\n\r\n                        if (!babylonScene.animationGroups.length && babylonTransformNode.animations.length) {\r\n                            _GLTFAnimation._CreateNodeAnimationFromTransformNodeAnimations(babylonTransformNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, this._nodes, binaryWriter, this._bufferViews, this._accessors, this._convertToRightHandedSystem, this._animationSampleRate);\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                `Excluding mesh ${babylonTransformNode.name}`;\r\n            }\r\n        }\r\n\r\n        return promiseChain.then(() => {\r\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\r\n                this._animations.push(runtimeGLTFAnimation);\r\n            }\r\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\r\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\r\n                    this._animations.push(idleGLTFAnimation);\r\n                }\r\n            });\r\n\r\n            if (babylonScene.animationGroups.length) {\r\n                _GLTFAnimation._CreateNodeAnimationFromAnimationGroups(babylonScene, this._animations, nodeMap, this._nodes, binaryWriter, this._bufferViews, this._accessors, this._convertToRightHandedSystem, this._animationSampleRate);\r\n            }\r\n\r\n            return nodeMap;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF node from a Babylon mesh\r\n     * @param babylonMesh Source Babylon mesh\r\n     * @param binaryWriter Buffer for storing geometry data\r\n     * @returns glTF node\r\n     */\r\n    private createNodeAsync(babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter): Promise<INode> {\r\n        return Promise.resolve().then(() => {\r\n            // create node to hold translation/rotation/scale and the mesh\r\n            const node: INode = {};\r\n            // create mesh\r\n            const mesh: IMesh = { primitives: [] };\r\n\r\n            if (babylonTransformNode.name) {\r\n                node.name = babylonTransformNode.name;\r\n            }\r\n\r\n            // Set transformation\r\n            this.setNodeTransformation(node, babylonTransformNode);\r\n\r\n            return this.setPrimitiveAttributesAsync(mesh, babylonTransformNode, binaryWriter).then(() => {\r\n                if (mesh.primitives.length) {\r\n                    this._meshes.push(mesh);\r\n                    node.mesh = this._meshes.length - 1;\r\n                }\r\n\r\n                return node;\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * @hidden\r\n *\r\n * Stores glTF binary data.  If the array buffer byte length is exceeded, it doubles in size dynamically\r\n */\r\nexport class _BinaryWriter {\r\n    /**\r\n     * Array buffer which stores all binary data\r\n     */\r\n    private _arrayBuffer: ArrayBuffer;\r\n    /**\r\n     * View of the array buffer\r\n     */\r\n    private _dataView: DataView;\r\n    /**\r\n     * byte offset of data in array buffer\r\n     */\r\n    private _byteOffset: number;\r\n    /**\r\n     * Initialize binary writer with an initial byte length\r\n     * @param byteLength Initial byte length of the array buffer\r\n     */\r\n    constructor(byteLength: number) {\r\n        this._arrayBuffer = new ArrayBuffer(byteLength);\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n        this._byteOffset = 0;\r\n    }\r\n    /**\r\n     * Resize the array buffer to the specified byte length\r\n     * @param byteLength\r\n     */\r\n    private resizeBuffer(byteLength: number): ArrayBuffer {\r\n        let newBuffer = new ArrayBuffer(byteLength);\r\n        let oldUint8Array = new Uint8Array(this._arrayBuffer);\r\n        let newUint8Array = new Uint8Array(newBuffer);\r\n        for (let i = 0, length = newUint8Array.byteLength; i < length; ++i) {\r\n            newUint8Array[i] = oldUint8Array[i];\r\n        }\r\n        this._arrayBuffer = newBuffer;\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n\r\n        return newBuffer;\r\n    }\r\n    /**\r\n     * Get an array buffer with the length of the byte offset\r\n     * @returns ArrayBuffer resized to the byte offset\r\n     */\r\n    public getArrayBuffer(): ArrayBuffer {\r\n        return this.resizeBuffer(this.getByteOffset());\r\n    }\r\n    /**\r\n     * Get the byte offset of the array buffer\r\n     * @returns byte offset\r\n     */\r\n    public getByteOffset(): number {\r\n        if (this._byteOffset == undefined) {\r\n            throw new Error(\"Byte offset is undefined!\");\r\n        }\r\n        return this._byteOffset;\r\n    }\r\n    /**\r\n     * Stores an UInt8 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt8(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint8(byteOffset, entry);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            }\r\n        }\r\n        else {\r\n            if (this._byteOffset + 1 > this._arrayBuffer.byteLength) {\r\n                this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint8(this._byteOffset++, entry);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public getUInt32(byteOffset: number): number {\r\n        if (byteOffset < this._byteOffset) {\r\n            return this._dataView.getUint32(byteOffset, true);\r\n        }\r\n        else {\r\n            Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            throw new Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n        }\r\n    }\r\n\r\n    public getVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            vector3.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector3.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector3.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n        }\r\n    }\r\n\r\n    public setVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            this._dataView.setFloat32(byteOffset, vector3.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector3.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector3.z, true);\r\n        }\r\n    }\r\n\r\n    public getVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            vector4.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector4.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector4.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n            vector4.w = this._dataView.getFloat32(byteOffset + 12, true);\r\n        }\r\n    }\r\n\r\n    public setVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            this._dataView.setFloat32(byteOffset, vector4.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector4.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector4.z, true);\r\n            this._dataView.setFloat32(byteOffset + 12, vector4.w, true);\r\n        }\r\n    }\r\n    /**\r\n     * Stores a Float32 in the array buffer\r\n     * @param entry\r\n     */\r\n    public setFloat32(entry: number, byteOffset?: number) {\r\n        if (isNaN(entry)) {\r\n            Tools.Error('Invalid data being written!');\r\n        }\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setFloat32(byteOffset, entry, true);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary length!');\r\n            }\r\n        }\r\n        if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n            this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n        }\r\n        this._dataView.setFloat32(this._byteOffset, entry, true);\r\n        this._byteOffset += 4;\r\n    }\r\n    /**\r\n     * Stores an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt32(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint32(byteOffset, entry, true);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            }\r\n        }\r\n        else {\r\n            if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n                this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint32(this._byteOffset, entry, true);\r\n            this._byteOffset += 4;\r\n        }\r\n    }\r\n}","import { Nullable, Color3, Scalar, Material, StandardMaterial, PBRMetallicRoughnessMaterial, PBRMaterial, Tools, Engine, Scene, Texture, PostProcess, RawTexture, BaseTexture, TextureTools } from \"babylonjs\";\r\nimport { ITextureInfo, ImageMimeType, IMaterial, IMaterialPbrMetallicRoughness, MaterialAlphaMode, IMaterialOcclusionTextureInfo, ISampler, TextureMagFilter, TextureMinFilter, TextureWrapMode, ITexture, IImage } from \"babylonjs-gltf2interface\";\r\nimport { _Exporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @hidden\r\n */\r\ninterface _IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n    */\r\n    diffuseColor: BABYLON.Color3;\r\n    /**\r\n     * Represents the linear specular factors of the material\r\n    */\r\n    specularColor: BABYLON.Color3;\r\n    /**\r\n     * Represents the smoothness of the material\r\n    */\r\n    glossiness: number;\r\n}\r\n\r\n/**\r\n * Interface for storing metallic roughness factors\r\n * @hidden\r\n */\r\ninterface _IPBRMetallicRoughness {\r\n    /**\r\n     * Represents the albedo color of the material\r\n    */\r\n    baseColor: BABYLON.Color3;\r\n    /**\r\n     * Represents the metallness of the material\r\n    */\r\n    metallic: Nullable<number>;\r\n    /**\r\n     * Represents the roughness of the material\r\n    */\r\n    roughness: Nullable<number>;\r\n    /**\r\n     * The metallic roughness texture as a base64 string\r\n    */\r\n    metallicRoughnessTextureBase64?: Nullable<string>;\r\n    /**\r\n     * The base color texture as a base64 string\r\n    */\r\n    baseColorTextureBase64?: Nullable<string>;\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.  This class should only be used internally\r\n * @hidden\r\n */\r\nexport class _GLTFMaterialExporter {\r\n    /**\r\n     * Represents the dielectric specular values for R, G and B\r\n     */\r\n    private static readonly _DielectricSpecular: Color3 = new Color3(0.04, 0.04, 0.04);\r\n\r\n    /**\r\n     * Allows the maximum specular power to be defined for material calculations\r\n     */\r\n    private static readonly _MaxSpecularPower = 1024;\r\n\r\n    /**\r\n     * Mapping to store textures\r\n     */\r\n    private _textureMap: { [textureId: string]: ITextureInfo } = {};\r\n\r\n    /**\r\n     * Numeric tolerance value\r\n     */\r\n    private static readonly _Epsilon = 1e-6;\r\n\r\n    /**\r\n     * Reference to the glTF Exporter\r\n     */\r\n    private _exporter: _Exporter;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._textureMap = {};\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /**\r\n     * Specifies if two colors are approximately equal in value\r\n     * @param color1 first color to compare to\r\n     * @param color2 second color to compare to\r\n     * @param epsilon threshold value\r\n     */\r\n    private static FuzzyEquals(color1: Color3, color2: Color3, epsilon: number): boolean {\r\n        return Scalar.WithinEpsilon(color1.r, color2.r, epsilon) &&\r\n            Scalar.WithinEpsilon(color1.g, color2.g, epsilon) &&\r\n            Scalar.WithinEpsilon(color1.b, color2.b, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Gets the materials from a Babylon scene and converts them to glTF materials\r\n     * @param scene babylonjs scene\r\n     * @param mimeType texture mime type\r\n     * @param images array of images\r\n     * @param textures array of textures\r\n     * @param materials array of materials\r\n     * @param imageData mapping of texture names to base64 textures\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the material\r\n     */\r\n    public _convertMaterialsToGLTFAsync(babylonMaterials: Material[], mimeType: ImageMimeType, hasTextureCoords: boolean) {\r\n        let promises: Promise<void>[] = [];\r\n        for (let babylonMaterial of babylonMaterials) {\r\n            if (babylonMaterial instanceof StandardMaterial) {\r\n                promises.push(this._convertStandardMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else if (babylonMaterial instanceof PBRMetallicRoughnessMaterial) {\r\n                promises.push(this._convertPBRMetallicRoughnessMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else if (babylonMaterial instanceof PBRMaterial) {\r\n                promises.push(this._convertPBRMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else {\r\n                Tools.Warn(`Unsupported material type: ${babylonMaterial.name}`);\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { /* do nothing */ });\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the glTF material without the texture parameters\r\n     * @param originalMaterial original glTF material\r\n     * @returns glTF material without texture parameters\r\n     */\r\n    public _stripTexturesFromMaterial(originalMaterial: IMaterial): IMaterial {\r\n        let newMaterial: IMaterial = {};\r\n        if (originalMaterial) {\r\n            newMaterial.name = originalMaterial.name;\r\n            newMaterial.doubleSided = originalMaterial.doubleSided;\r\n            newMaterial.alphaMode = originalMaterial.alphaMode;\r\n            newMaterial.alphaCutoff = originalMaterial.alphaCutoff;\r\n            newMaterial.emissiveFactor = originalMaterial.emissiveFactor;\r\n            const originalPBRMetallicRoughness = originalMaterial.pbrMetallicRoughness;\r\n            if (originalPBRMetallicRoughness) {\r\n                newMaterial.pbrMetallicRoughness = {};\r\n                newMaterial.pbrMetallicRoughness.baseColorFactor = originalPBRMetallicRoughness.baseColorFactor;\r\n                newMaterial.pbrMetallicRoughness.metallicFactor = originalPBRMetallicRoughness.metallicFactor;\r\n                newMaterial.pbrMetallicRoughness.roughnessFactor = originalPBRMetallicRoughness.roughnessFactor;\r\n            }\r\n        }\r\n        return newMaterial;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material has any texture parameters present\r\n     * @param material glTF Material\r\n     * @returns boolean specifying if texture parameters are present\r\n     */\r\n    public _hasTexturesPresent(material: IMaterial): boolean {\r\n        if (material.emissiveTexture || material.normalTexture || material.occlusionTexture) {\r\n            return true;\r\n        }\r\n        const pbrMat = material.pbrMetallicRoughness;\r\n        if (pbrMat) {\r\n            if (pbrMat.baseColorTexture || pbrMat.metallicRoughnessTexture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon StandardMaterial to a glTF Metallic Roughness Material\r\n     * @param babylonStandardMaterial\r\n     * @returns glTF Metallic Roughness Material representation\r\n     */\r\n    public _convertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n        const P0 = new BABYLON.Vector2(0, 1);\r\n        const P1 = new BABYLON.Vector2(0, 0.1);\r\n        const P2 = new BABYLON.Vector2(0, 0.1);\r\n        const P3 = new BABYLON.Vector2(1300, 0.1);\r\n\r\n        /**\r\n         * Given the control points, solve for x based on a given t for a cubic bezier curve\r\n         * @param t a value between 0 and 1\r\n         * @param p0 first control point\r\n         * @param p1 second control point\r\n         * @param p2 third control point\r\n         * @param p3 fourth control point\r\n         * @returns number result of cubic bezier curve at the specified t\r\n         */\r\n        function _cubicBezierCurve(t: number, p0: number, p1: number, p2: number, p3: number): number {\r\n            return (\r\n                (1 - t) * (1 - t) * (1 - t) * p0 +\r\n                3 * (1 - t) * (1 - t) * t * p1 +\r\n                3 * (1 - t) * t * t * p2 +\r\n                t * t * t * p3\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Evaluates a specified specular power value to determine the appropriate roughness value,\r\n         * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)\r\n         * and roughness on the ordinant axis (y-axis)\r\n         * @param specularPower specular power of standard material\r\n         * @returns Number representing the roughness value\r\n         */\r\n        function _solveForRoughness(specularPower: number): number {\r\n            var t = Math.pow(specularPower / P3.x, 0.333333);\r\n            return _cubicBezierCurve(t, P0.y, P1.y, P2.y, P3.y);\r\n        }\r\n\r\n        let diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace().scale(0.5);\r\n        let opacity = babylonStandardMaterial.alpha;\r\n        let specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, _GLTFMaterialExporter._MaxSpecularPower);\r\n\r\n        const roughness = _solveForRoughness(specularPower);\r\n\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n            baseColorFactor: [\r\n                diffuse.r,\r\n                diffuse.g,\r\n                diffuse.b,\r\n                opacity\r\n            ],\r\n            metallicFactor: 0,\r\n            roughnessFactor: roughness,\r\n        };\r\n\r\n        return glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Computes the metallic factor\r\n     * @param diffuse diffused value\r\n     * @param specular specular value\r\n     * @param oneMinusSpecularStrength one minus the specular strength\r\n     * @returns metallic value\r\n     */\r\n    public static _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n        if (specular < this._DielectricSpecular.r) {\r\n            this._DielectricSpecular;\r\n            return 0;\r\n        }\r\n\r\n        const a = this._DielectricSpecular.r;\r\n        const b = diffuse * oneMinusSpecularStrength / (1.0 - this._DielectricSpecular.r) + specular - 2.0 * this._DielectricSpecular.r;\r\n        const c = this._DielectricSpecular.r - specular;\r\n        const D = b * b - 4.0 * a * c;\r\n        return BABYLON.Scalar.Clamp((-b + Math.sqrt(D)) / (2.0 * a), 0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the glTF alpha mode from the Babylon Material\r\n     * @param babylonMaterial Babylon Material\r\n     * @returns The Babylon alpha mode value\r\n     */\r\n    public _getAlphaMode(babylonMaterial: Material): MaterialAlphaMode {\r\n        if (babylonMaterial.needAlphaBlending()) {\r\n            return MaterialAlphaMode.BLEND;\r\n        }\r\n        else if (babylonMaterial.needAlphaTesting()) {\r\n            return MaterialAlphaMode.MASK;\r\n        }\r\n        else {\r\n            return MaterialAlphaMode.OPAQUE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon Standard Material to a glTF Material\r\n     * @param babylonStandardMaterial BJS Standard Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<void> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        const alphaMode = this._getAlphaMode(babylonStandardMaterial);\r\n        let promises = [];\r\n        const glTFPbrMetallicRoughness = this._convertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const glTFMaterial: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            glTFMaterial.doubleSided = true;\r\n        }\r\n        if (hasTextureCoords) {\r\n            if (babylonStandardMaterial.diffuseTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.diffuseTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.bumpTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.normalTexture = glTFTexture;\r\n                        if (babylonStandardMaterial.bumpTexture != null && babylonStandardMaterial.bumpTexture.level !== 1) {\r\n                            glTFMaterial.normalTexture.scale = babylonStandardMaterial.bumpTexture.level;\r\n                        }\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.emissiveTexture) {\r\n                glTFMaterial.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.emissiveTexture, mimeType).then((glTFEmissiveTexture) => {\r\n                    if (glTFEmissiveTexture) {\r\n                        glTFMaterial.emissiveTexture = glTFEmissiveTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.ambientTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                            index: glTFTexture.index\r\n                        };\r\n                        glTFMaterial.occlusionTexture = occlusionTexture;\r\n                        occlusionTexture.strength = 1.0;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Engine.ALPHA_COMBINE) {\r\n                glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n            }\r\n            else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n        if (babylonStandardMaterial.emissiveColor && !_GLTFMaterialExporter.FuzzyEquals(babylonStandardMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n        if (alphaMode !== MaterialAlphaMode.OPAQUE) {\r\n            switch (alphaMode) {\r\n                case MaterialAlphaMode.BLEND: {\r\n                    glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n                    break;\r\n                }\r\n                case MaterialAlphaMode.MASK: {\r\n                    glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n                    glTFMaterial.alphaCutoff = babylonStandardMaterial.alphaCutOff;\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Warn(`Unsupported alpha mode ${alphaMode}`);\r\n                }\r\n            }\r\n        }\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonStandardMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return Promise.all(promises).then(() => { /* do nothing */ });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material\r\n     * @param babylonPBRMetalRoughMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMetallicRoughnessMaterialAsync(babylonPBRMetalRoughMaterial: PBRMetallicRoughnessMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<void> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        let promises: Promise<void>[] = [];\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n\r\n        if (babylonPBRMetalRoughMaterial.baseColor) {\r\n            glTFPbrMetallicRoughness.baseColorFactor = [\r\n                babylonPBRMetalRoughMaterial.baseColor.r,\r\n                babylonPBRMetalRoughMaterial.baseColor.g,\r\n                babylonPBRMetalRoughMaterial.baseColor.b,\r\n                babylonPBRMetalRoughMaterial.alpha\r\n            ];\r\n        }\r\n\r\n        if (babylonPBRMetalRoughMaterial.metallic != null && babylonPBRMetalRoughMaterial.metallic !== 1) {\r\n            glTFPbrMetallicRoughness.metallicFactor = babylonPBRMetalRoughMaterial.metallic;\r\n        }\r\n        if (babylonPBRMetalRoughMaterial.roughness != null && babylonPBRMetalRoughMaterial.roughness !== 1) {\r\n            glTFPbrMetallicRoughness.roughnessFactor = babylonPBRMetalRoughMaterial.roughness;\r\n        }\r\n\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMetalRoughMaterial.name\r\n        };\r\n        if (babylonPBRMetalRoughMaterial.doubleSided) {\r\n            glTFMaterial.doubleSided = babylonPBRMetalRoughMaterial.doubleSided;\r\n        }\r\n        let alphaMode: Nullable<MaterialAlphaMode> = null;\r\n        if (babylonPBRMetalRoughMaterial.transparencyMode != null) {\r\n            alphaMode = this._getAlphaMode(babylonPBRMetalRoughMaterial);\r\n            if (alphaMode) {\r\n                if (alphaMode !== MaterialAlphaMode.OPAQUE) { //glTF defaults to opaque\r\n                    glTFMaterial.alphaMode = alphaMode;\r\n                    if (alphaMode === MaterialAlphaMode.MASK) {\r\n                        glTFMaterial.alphaCutoff = babylonPBRMetalRoughMaterial.alphaCutOff;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (hasTextureCoords) {\r\n            if (babylonPBRMetalRoughMaterial.baseTexture != null) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.baseTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.normalTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.normalTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.normalTexture = glTFTexture;\r\n                        if (babylonPBRMetalRoughMaterial.normalTexture.level !== 1) {\r\n                            glTFMaterial.normalTexture.scale = babylonPBRMetalRoughMaterial.normalTexture.level;\r\n                        }\r\n                    }\r\n                }));\r\n\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.occlusionTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.occlusionTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.occlusionTexture = glTFTexture;\r\n                        if (babylonPBRMetalRoughMaterial.occlusionStrength != null) {\r\n                            glTFMaterial.occlusionTexture.strength = babylonPBRMetalRoughMaterial.occlusionStrength;\r\n                        }\r\n                    }\r\n                }));\r\n\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.emissiveTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.emissiveTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.emissiveTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n\r\n        }\r\n\r\n        if (_GLTFMaterialExporter.FuzzyEquals(babylonPBRMetalRoughMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonPBRMetalRoughMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonPBRMetalRoughMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return Promise.all(promises).then(() => { /* do nothing */ });\r\n    }\r\n\r\n    /**\r\n     * Converts an image typed array buffer to a base64 image\r\n     * @param buffer typed array buffer\r\n     * @param width width of the image\r\n     * @param height height of the image\r\n     * @param mimeType mimetype of the image\r\n     * @returns base64 image string\r\n     */\r\n    private _createBase64FromCanvasAsync(buffer: Uint8Array | Float32Array, width: number, height: number, mimeType: ImageMimeType): Promise<string> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            let hostingScene: Scene;\r\n\r\n            const textureType = Engine.TEXTURETYPE_UNSIGNED_INT;\r\n            const engine = this._exporter._getLocalEngine();\r\n\r\n            hostingScene = new Scene(engine);\r\n\r\n            // Create a temporary texture with the texture buffer data\r\n            const tempTexture = engine.createRawTexture(buffer, width, height, Engine.TEXTUREFORMAT_RGBA, false, true, Texture.NEAREST_SAMPLINGMODE, null, textureType);\r\n            const postProcess = new PostProcess(\"pass\", \"pass\", null, null, 1, null, Texture.NEAREST_SAMPLINGMODE, engine, false, undefined, Engine.TEXTURETYPE_UNSIGNED_INT, undefined, null, false);\r\n            postProcess.getEffect().executeWhenCompiled(() => {\r\n                postProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", tempTexture);\r\n                };\r\n\r\n                // Set the size of the texture\r\n                engine.setSize(width, height);\r\n                hostingScene.postProcessManager.directRender([postProcess], null);\r\n                postProcess.dispose();\r\n                tempTexture.dispose();\r\n\r\n                // Read data from WebGL\r\n                const canvas = engine.getRenderingCanvas();\r\n\r\n                if (canvas) {\r\n                    if (!canvas.toBlob) { // fallback for browsers without \"canvas.toBlob\"\r\n                        const dataURL = canvas.toDataURL();\r\n                        resolve(dataURL);\r\n                    }\r\n                    else {\r\n                        BABYLON.Tools.ToBlob(canvas, (blob) => {\r\n                            if (blob) {\r\n                                let fileReader = new FileReader();\r\n                                fileReader.onload = (event: any) => {\r\n                                    let base64String = event.target.result as string;\r\n                                    hostingScene.dispose();\r\n                                    resolve(base64String);\r\n                                };\r\n                                fileReader.readAsDataURL(blob);\r\n                            }\r\n                            else {\r\n                                reject(\"gltfMaterialExporter: Failed to get blob from image canvas!\");\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    reject(\"Engine is missing a canvas!\");\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a white texture based on the specified width and height\r\n     * @param width width of the texture in pixels\r\n     * @param height height of the texture in pixels\r\n     * @param scene babylonjs scene\r\n     * @returns white texture\r\n     */\r\n    private _createWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n        const data = new Uint8Array(width * height * 4);\r\n\r\n        for (let i = 0; i < data.length; i = i + 4) {\r\n            data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xFF;\r\n        }\r\n\r\n        const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n        return rawTexture;\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: BaseTexture, texture2: BaseTexture, scene: Scene): { \"texture1\": BaseTexture, \"texture2\": BaseTexture } {\r\n        let texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        let texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1;\r\n        let resizedTexture2;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            }\r\n            else {\r\n                resizedTexture1 = this._createWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2;\r\n        }\r\n        else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            }\r\n            else {\r\n                resizedTexture2 = this._createWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1;\r\n        }\r\n        else {\r\n            resizedTexture1 = texture1;\r\n            resizedTexture2 = texture2;\r\n        }\r\n\r\n        return {\r\n            \"texture1\": resizedTexture1,\r\n            \"texture2\": resizedTexture2\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts an array of pixels to a Float32Array\r\n     * Throws an error if the pixel format is not supported\r\n     * @param pixels - array buffer containing pixel values\r\n     * @returns Float32 of pixels\r\n     */\r\n    private _convertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n        if (pixels instanceof Uint8Array) {\r\n            const length = pixels.length;\r\n            const buffer = new Float32Array(pixels.length);\r\n            for (let i = 0; i < length; ++i) {\r\n                buffer[i] = pixels[i] / 255;\r\n            }\r\n            return buffer;\r\n        }\r\n        else if (pixels instanceof Float32Array) {\r\n            return pixels;\r\n        }\r\n        else {\r\n            throw new Error('Unsupported pixel format!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(diffuseTexture: BaseTexture, specularGlossinessTexture: BaseTexture, factors: _IPBRSpecularGlossiness, mimeType: ImageMimeType): Promise<_IPBRMetallicRoughness> {\r\n        let promises = [];\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return Promise.reject('_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!');\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            let diffuseSize = resizedTextures.texture1.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            let diffusePixels = resizedTextures.texture1.readPixels();\r\n            let specularPixels = resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = this._convertPixelArrayToFloat32(diffusePixels);\r\n            }\r\n            else {\r\n                return Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = this._convertPixelArrayToFloat32(specularPixels);\r\n            }\r\n            else {\r\n                return Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = Color3.Black();\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2]).toLinearSpace().multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2]).toLinearSpace().multiply(factors.specularColor);\r\n                    const glossiness = (specularGlossinessBuffer[offset + 3]) * factors.glossiness;\r\n\r\n                    const specularGlossiness: _IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: _IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(baseColorBuffer[destinationOffset], baseColorBuffer[destinationOffset + 1], baseColorBuffer[destinationOffset + 2]);\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace();\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!_GLTFMaterialExporter.FuzzyEquals(sRGBBaseColorPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!_GLTFMaterialExporter.FuzzyEquals(metallicRoughnessPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                let promise = this._createBase64FromCanvasAsync(metallicRoughnessBuffer, width, height, mimeType).then((metallicRoughnessBase64) => {\r\n                    metallicRoughnessFactors.metallicRoughnessTextureBase64 = metallicRoughnessBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                let promise = this._createBase64FromCanvasAsync(baseColorBuffer, width, height, mimeType).then((baseColorBase64) => {\r\n                    metallicRoughnessFactors.baseColorTextureBase64 = baseColorBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        }\r\n        else {\r\n            return Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: _IPBRSpecularGlossiness): _IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _GLTFMaterialExporter._SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1.0 - _GLTFMaterialExporter._DielectricSpecular.r) / Math.max(1 - metallic, _GLTFMaterialExporter._Epsilon));\r\n        const baseColorFromSpecular = specularGlossiness.specularColor.subtract(_GLTFMaterialExporter._DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic, _GLTFMaterialExporter._Epsilon));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        if (color) {\r\n            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        if (color) {\r\n            return Math.max(color.r, Math.max(color.g, color.b));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, hasTextureCoords: boolean): Promise<_IPBRMetallicRoughness> {\r\n        const promises = [];\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: babylonPBRMaterial.albedoColor,\r\n            metallic: babylonPBRMaterial.metallic,\r\n            roughness: babylonPBRMaterial.roughness\r\n        };\r\n\r\n        if (hasTextureCoords) {\r\n            if (babylonPBRMaterial.albedoTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMaterial.albedoTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonPBRMaterial.metallicTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMaterial.metallicTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            return metallicRoughness;\r\n        });\r\n    }\r\n\r\n    private _getGLTFTextureSampler(texture: BaseTexture): ISampler {\r\n        const sampler = this._getGLTFTextureWrapModesSampler(texture);\r\n\r\n        let samplingMode = texture instanceof Texture ? texture.samplingMode : null;\r\n        if (samplingMode != null) {\r\n            switch (samplingMode) {\r\n                case Texture.LINEAR_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGLTFTextureWrapModesSampler(texture: BaseTexture): ISampler {\r\n        let wrapS = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapU : Texture.WRAP_ADDRESSMODE);\r\n        let wrapT = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapV : Texture.WRAP_ADDRESSMODE);\r\n\r\n        if (wrapS === TextureWrapMode.REPEAT && wrapT === TextureWrapMode.REPEAT) { // default wrapping mode in glTF, so omitting\r\n            return {};\r\n        }\r\n\r\n        return { wrapS: wrapS, wrapT: wrapT };\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, hasTextureCoords: boolean): Promise<_IPBRMetallicRoughness> {\r\n        return Promise.resolve().then(() => {\r\n            const samplers = this._exporter._samplers;\r\n            const textures = this._exporter._textures;\r\n            const specGloss: _IPBRSpecularGlossiness = {\r\n                diffuseColor: babylonPBRMaterial.albedoColor || Color3.White(),\r\n                specularColor: babylonPBRMaterial.reflectivityColor || Color3.White(),\r\n                glossiness: babylonPBRMaterial.microSurface || 1,\r\n            };\r\n            let samplerIndex: Nullable<number> = null;\r\n            const sampler = this._getGLTFTextureSampler(babylonPBRMaterial.albedoTexture);\r\n            if (sampler.magFilter != null && sampler.minFilter != null && sampler.wrapS != null && sampler.wrapT != null) {\r\n                samplers.push(sampler);\r\n                samplerIndex = samplers.length - 1;\r\n            }\r\n            if (babylonPBRMaterial.reflectivityTexture && !babylonPBRMaterial.useMicroSurfaceFromReflectivityMapAlpha) {\r\n                return Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n            }\r\n            if ((babylonPBRMaterial.albedoTexture || babylonPBRMaterial.reflectivityTexture) && hasTextureCoords) {\r\n                return this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(babylonPBRMaterial.albedoTexture, babylonPBRMaterial.reflectivityTexture, specGloss, mimeType).then((metallicRoughnessFactors) => {\r\n                    if (metallicRoughnessFactors.baseColorTextureBase64) {\r\n                        const glTFBaseColorTexture = this._getTextureInfoFromBase64(metallicRoughnessFactors.baseColorTextureBase64, \"bjsBaseColorTexture_\" + (textures.length) + \".png\", mimeType, babylonPBRMaterial.albedoTexture ? babylonPBRMaterial.albedoTexture.coordinatesIndex : null, samplerIndex);\r\n                        if (glTFBaseColorTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFBaseColorTexture;\r\n                        }\r\n                    }\r\n                    if (metallicRoughnessFactors.metallicRoughnessTextureBase64) {\r\n                        const glTFMRColorTexture = this._getTextureInfoFromBase64(metallicRoughnessFactors.metallicRoughnessTextureBase64, \"bjsMetallicRoughnessTexture_\" + (textures.length) + \".png\", mimeType, babylonPBRMaterial.reflectivityTexture ? babylonPBRMaterial.reflectivityTexture.coordinatesIndex : null, samplerIndex);\r\n                        if (glTFMRColorTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFMRColorTexture;\r\n                        }\r\n                    }\r\n\r\n                    return metallicRoughnessFactors;\r\n                });\r\n            }\r\n            else {\r\n                return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMaterialAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<void> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name\r\n        };\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            if (babylonPBRMaterial.albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [\r\n                    babylonPBRMaterial.albedoColor.r,\r\n                    babylonPBRMaterial.albedoColor.g,\r\n                    babylonPBRMaterial.albedoColor.b,\r\n                    babylonPBRMaterial.alpha\r\n                ];\r\n            }\r\n            return this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n        else {\r\n            return this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n    }\r\n\r\n    private setMetallicRoughnessPbrMaterial(metallicRoughness: Nullable<_IPBRMetallicRoughness>, babylonPBRMaterial: PBRMaterial, glTFMaterial: IMaterial, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<void> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        let promises = [];\r\n        if (metallicRoughness) {\r\n            let alphaMode: Nullable<MaterialAlphaMode> = null;\r\n            if (babylonPBRMaterial.transparencyMode != null) {\r\n                alphaMode = this._getAlphaMode(babylonPBRMaterial);\r\n                if (alphaMode) {\r\n                    if (alphaMode !== MaterialAlphaMode.OPAQUE) { //glTF defaults to opaque\r\n                        glTFMaterial.alphaMode = alphaMode;\r\n                        if (alphaMode === MaterialAlphaMode.MASK) {\r\n                            glTFMaterial.alphaCutoff = babylonPBRMaterial.alphaCutOff;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!(_GLTFMaterialExporter.FuzzyEquals(metallicRoughness.baseColor, Color3.White(), _GLTFMaterialExporter._Epsilon) && babylonPBRMaterial.alpha >= _GLTFMaterialExporter._Epsilon)) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [\r\n                    metallicRoughness.baseColor.r,\r\n                    metallicRoughness.baseColor.g,\r\n                    metallicRoughness.baseColor.b,\r\n                    babylonPBRMaterial.alpha\r\n                ];\r\n            }\r\n\r\n            if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n                glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n            }\r\n            if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n                glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n            }\r\n\r\n            if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n                if (!babylonPBRMaterial.twoSidedLighting) {\r\n                    Tools.Warn(babylonPBRMaterial.name + \": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.\");\r\n                }\r\n                glTFMaterial.doubleSided = true;\r\n            }\r\n\r\n            if (hasTextureCoords) {\r\n                if (babylonPBRMaterial.bumpTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (babylonPBRMaterial.bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = babylonPBRMaterial.bumpTexture.level;\r\n                            }\r\n                        }\r\n                    }\r\n                    );\r\n                    promises.push(promise);\r\n\r\n                }\r\n                if (babylonPBRMaterial.ambientTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            let occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n\r\n                            if (babylonPBRMaterial.ambientTextureStrength) {\r\n                                occlusionTexture.strength = babylonPBRMaterial.ambientTextureStrength;\r\n                            }\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n\r\n                }\r\n                if (babylonPBRMaterial.emissiveTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.emissiveTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n            }\r\n            if (!_GLTFMaterialExporter.FuzzyEquals(babylonPBRMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n                glTFMaterial.emissiveFactor = babylonPBRMaterial.emissiveColor.asArray();\r\n            }\r\n\r\n            glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n            materials.push(glTFMaterial);\r\n            materialMap[babylonPBRMaterial.uniqueId] = materials.length - 1;\r\n        }\r\n        return Promise.all(promises).then((result) => { /* do nothing */ });\r\n    }\r\n\r\n    private getPixelsFromTexture(babylonTexture: BaseTexture): Uint8Array | Float32Array {\r\n        const pixels = babylonTexture.textureType === Engine.TEXTURETYPE_UNSIGNED_INT ? babylonTexture.readPixels() as Uint8Array : babylonTexture.readPixels() as Float32Array;\r\n        return pixels;\r\n    }\r\n\r\n    /**\r\n     * Extracts a texture from a Babylon texture into file data and glTF data\r\n     * @param babylonTexture Babylon texture to extract\r\n     * @param mimeType Mime Type of the babylonTexture\r\n     * @return glTF texture info, or null if the texture format is not supported\r\n     */\r\n    public _exportTextureAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const extensionPromise = this._exporter._extensionsPreExportTextureAsync(\"exporter\", babylonTexture as Texture, mimeType);\r\n        if (!extensionPromise) {\r\n            return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n        }\r\n\r\n        return extensionPromise.then((texture) => {\r\n            if (!texture) {\r\n                return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n            }\r\n            return this._exportTextureInfoAsync(texture, mimeType);\r\n        });\r\n    }\r\n\r\n    public _exportTextureInfoAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        return Promise.resolve().then(() => {\r\n            const textureUid = babylonTexture.uid;\r\n            if (textureUid in this._textureMap) {\r\n                return this._textureMap[textureUid];\r\n            }\r\n            else {\r\n                const samplers = this._exporter._samplers;\r\n                const sampler = this._getGLTFTextureSampler(babylonTexture);\r\n                let samplerIndex: Nullable<number> = null;\r\n\r\n                //  if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n                let foundSamplerIndex: Nullable<number> = null;\r\n                for (let i = 0; i < samplers.length; ++i) {\r\n                    let s = samplers[i];\r\n                    if (s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter &&\r\n                        s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT) {\r\n                        foundSamplerIndex = i;\r\n                        break;\r\n                    }\r\n                }\r\n                if (foundSamplerIndex == null) {\r\n                    samplers.push(sampler);\r\n                    samplerIndex = samplers.length - 1;\r\n                }\r\n                else {\r\n                    samplerIndex = foundSamplerIndex;\r\n                }\r\n                const pixels = this.getPixelsFromTexture(babylonTexture);\r\n                const size = babylonTexture.getSize();\r\n\r\n                return this._createBase64FromCanvasAsync(pixels, size.width, size.height, mimeType).then((base64Data) => {\r\n                    const textureInfo = this._getTextureInfoFromBase64(base64Data, babylonTexture.name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\"), mimeType, babylonTexture.coordinatesIndex, samplerIndex);\r\n                    if (textureInfo) {\r\n                        this._textureMap[textureUid] = textureInfo;\r\n                    }\r\n                    return textureInfo;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Builds a texture from base64 string\r\n     * @param base64Texture base64 texture string\r\n     * @param baseTextureName Name to use for the texture\r\n     * @param mimeType image mime type for the texture\r\n     * @param images array of images\r\n     * @param textures array of textures\r\n     * @param imageData map of image data\r\n     * @returns glTF texture info, or null if the texture format is not supported\r\n     */\r\n    private _getTextureInfoFromBase64(base64Texture: string, baseTextureName: string, mimeType: ImageMimeType, texCoordIndex: Nullable<number>, samplerIndex: Nullable<number>): Nullable<ITextureInfo> {\r\n        const textures = this._exporter._textures;\r\n        const images = this._exporter._images;\r\n        const imageData = this._exporter._imageData;\r\n        let textureInfo: Nullable<ITextureInfo> = null;\r\n\r\n        const glTFTexture: ITexture = {\r\n            source: images.length,\r\n            name: baseTextureName\r\n        };\r\n        if (samplerIndex != null) {\r\n            glTFTexture.sampler = samplerIndex;\r\n        }\r\n\r\n        const binStr = atob(base64Texture.split(',')[1]);\r\n        let arrBuff = new ArrayBuffer(binStr.length);\r\n        const arr = new Uint8Array(arrBuff);\r\n        for (let i = 0, length = binStr.length; i < length; ++i) {\r\n            arr[i] = binStr.charCodeAt(i);\r\n        }\r\n        const imageValues = { data: arr, mimeType: mimeType };\r\n\r\n        let extension = mimeType === ImageMimeType.JPEG ? '.jpeg' : '.png';\r\n        let textureName = baseTextureName + extension;\r\n        if (textureName in imageData) {\r\n            textureName = `${baseTextureName}_${Tools.RandomId()}${extension}`;\r\n        }\r\n\r\n        imageData[textureName] = imageValues;\r\n        if (mimeType === ImageMimeType.JPEG || mimeType === ImageMimeType.PNG) {\r\n            const glTFImage: IImage = {\r\n                name: baseTextureName,\r\n                uri: textureName\r\n            };\r\n            let foundIndex: Nullable<number> = null;\r\n            for (let i = 0; i < images.length; ++i) {\r\n                if (images[i].uri === textureName) {\r\n                    foundIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n            if (foundIndex == null) {\r\n                images.push(glTFImage);\r\n                glTFTexture.source = images.length - 1;\r\n            }\r\n            else {\r\n                glTFTexture.source = foundIndex;\r\n\r\n            }\r\n            textures.push(glTFTexture);\r\n            textureInfo = {\r\n                index: textures.length - 1\r\n            };\r\n            if (texCoordIndex != null) {\r\n                textureInfo.texCoord = texCoordIndex;\r\n            }\r\n        }\r\n        else {\r\n            Tools.Error(`Unsupported texture mime type ${mimeType}`);\r\n        }\r\n\r\n        return textureInfo;\r\n    }\r\n}","import * as Serializers from \"./index\";\r\n\r\n/**\r\n * Legacy support, defining window.BABYLON.OBJSerializer... (global variable).\r\n *\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    (<any>globalObject).BABYLON = (<any>globalObject).BABYLON || {};\r\n    for (var serializer in Serializers) {\r\n        if (Serializers.hasOwnProperty(serializer)) {\r\n            (<any>globalObject).BABYLON[serializer] = (<any>Serializers)[serializer];\r\n        }\r\n    }\r\n}\r\n\r\nexport * from \"./index\";","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","export * from \"./objSerializer\";","import { Mesh, Nullable, Matrix, Geometry, Tools, StandardMaterial } from \"babylonjs\";\n\nexport class OBJExport {\n    //Exports the geometry of a Mesh array in .OBJ file format (text)\n    public static OBJ(mesh: Mesh[], materials?: boolean, matlibname?: string, globalposition?: boolean): string {\n        const output: string[] = [];\n        let v = 1;\n        if (materials) {\n            if (!matlibname) {\n                matlibname = 'mat';\n            }\n            output.push(\"mtllib \" + matlibname + \".mtl\");\n        }\n        for (let j = 0; j < mesh.length; j++) {\n            output.push(\"g object\" + j);\n            output.push(\"o object_\" + j);\n\n            //Uses the position of the item in the scene, to the file (this back to normal in the end)\n            let lastMatrix: Nullable<Matrix> = null;\n            if (globalposition) {\n                var newMatrix = BABYLON.Matrix.Translation(mesh[j].position.x, mesh[j].position.y, mesh[j].position.z);\n                lastMatrix = BABYLON.Matrix.Translation(-(mesh[j].position.x), -(mesh[j].position.y), -(mesh[j].position.z));\n                mesh[j].bakeTransformIntoVertices(newMatrix);\n            }\n\n            //TODO: submeshes (groups)\n            //TODO: smoothing groups (s 1, s off);\n            if (materials) {\n                let mat = mesh[j].material;\n\n                if (mat) {\n                    output.push(\"usemtl \" + mat.id);\n                }\n            }\n            const g: Nullable<Geometry> = mesh[j].geometry;\n\n            if (!g) {\n                Tools.Warn(\"No geometry is present on the mesh\");\n                continue;\n            }\n\n            const trunkVerts = g.getVerticesData('position');\n            const trunkNormals = g.getVerticesData('normal');\n            const trunkUV = g.getVerticesData('uv');\n            const trunkFaces = g.getIndices();\n            var curV = 0;\n\n            if (!trunkVerts || !trunkFaces) {\n                Tools.Warn(\"There are no position vertices or indices on the mesh!\");\n                continue;\n            }\n\n            for (var i = 0; i < trunkVerts.length; i += 3) {\n                output.push(\"v \" + trunkVerts[i] + \" \" + trunkVerts[i + 1] + \" \" + trunkVerts[i + 2]);\n                curV++;\n            }\n\n            if (trunkNormals != null) {\n                for (i = 0; i < trunkNormals.length; i += 3) {\n                    output.push(\"vn \" + trunkNormals[i] + \" \" + trunkNormals[i + 1] + \" \" + trunkNormals[i + 2]);\n                }\n            }\n            if (trunkUV != null) {\n\n                for (i = 0; i < trunkUV.length; i += 2) {\n                    output.push(\"vt \" + trunkUV[i] + \" \" + trunkUV[i + 1]);\n                }\n            }\n\n            for (i = 0; i < trunkFaces.length; i += 3) {\n                const indices = [String(trunkFaces[i + 2] + v), String(trunkFaces[i + 1] + v), String(trunkFaces[i] + v)];\n                const blanks: string[] = [\"\", \"\", \"\"];\n\n                const facePositions = indices;\n                const faceUVs = trunkUV != null ? indices : blanks;\n                const faceNormals = trunkNormals != null ? indices : blanks;\n\n                output.push(\n                    \"f \" + facePositions[0] + \"/\" + faceUVs[0] + \"/\" + faceNormals[0] +\n                    \" \" + facePositions[1] + \"/\" + faceUVs[1] + \"/\" + faceNormals[1] +\n                    \" \" + facePositions[2] + \"/\" + faceUVs[2] + \"/\" + faceNormals[2]\n                );\n            }\n            //back de previous matrix, to not change the original mesh in the scene\n            if (globalposition && lastMatrix) {\n                mesh[j].bakeTransformIntoVertices(lastMatrix);\n            }\n            v += curV;\n        }\n        const text: string = output.join(\"\\n\");\n        return (text);\n    }\n    //Exports the material(s) of a mesh in .MTL file format (text)\n    //TODO: Export the materials of mesh array\n    public static MTL(mesh: Mesh): string {\n        var output = [];\n        var m = <StandardMaterial>mesh.material;\n        output.push(\"newmtl mat1\");\n        output.push(\"  Ns \" + m.specularPower.toFixed(4));\n        output.push(\"  Ni 1.5000\");\n        output.push(\"  d \" + m.alpha.toFixed(4));\n        output.push(\"  Tr 0.0000\");\n        output.push(\"  Tf 1.0000 1.0000 1.0000\");\n        output.push(\"  illum 2\");\n        output.push(\"  Ka \" + m.ambientColor.r.toFixed(4) + \" \" + m.ambientColor.g.toFixed(4) + \" \" + m.ambientColor.b.toFixed(4));\n        output.push(\"  Kd \" + m.diffuseColor.r.toFixed(4) + \" \" + m.diffuseColor.g.toFixed(4) + \" \" + m.diffuseColor.b.toFixed(4));\n        output.push(\"  Ks \" + m.specularColor.r.toFixed(4) + \" \" + m.specularColor.g.toFixed(4) + \" \" + m.specularColor.b.toFixed(4));\n        output.push(\"  Ke \" + m.emissiveColor.r.toFixed(4) + \" \" + m.emissiveColor.g.toFixed(4) + \" \" + m.emissiveColor.b.toFixed(4));\n\n        //TODO: uv scale, offset, wrap\n        //TODO: UV mirrored in Blender? second UV channel? lightMap? reflection textures?\n        var uvscale = \"\";\n\n        if (m.ambientTexture) {\n            output.push(\"  map_Ka \" + uvscale + m.ambientTexture.name);\n        }\n\n        if (m.diffuseTexture) {\n            output.push(\"  map_Kd \" + uvscale + m.diffuseTexture.name);\n            //TODO: alpha testing, opacity in diffuse texture alpha channel (diffuseTexture.hasAlpha -> map_d)\n        }\n\n        if (m.specularTexture) {\n            output.push(\"  map_Ks \" + uvscale + m.specularTexture.name);\n            /* TODO: glossiness = specular highlight component is in alpha channel of specularTexture. (???)\n            if (m.useGlossinessFromSpecularMapAlpha)  {\n                output.push(\"  map_Ns \"+uvscale + m.specularTexture.name);\n            }\n            */\n        }\n\n        /* TODO: emissive texture not in .MAT format (???)\n        if (m.emissiveTexture) {\n            output.push(\"  map_d \"+uvscale+m.emissiveTexture.name);\n        }\n        */\n\n        if (m.bumpTexture) {\n            output.push(\"  map_bump -imfchan z \" + uvscale + m.bumpTexture.name);\n        }\n\n        if (m.opacityTexture) {\n            output.push(\"  map_d \" + uvscale + m.opacityTexture.name);\n        }\n\n        var text = output.join(\"\\n\");\n        return (text);\n    }\n}\n","export * from \"./glTFFileExporter\";\r\nexport * from \"./2.0\";","/** @hidden */\r\nexport var __IGLTFExporterExtension = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for extending the exporter\r\n * @hidden\r\n */\r\nexport interface IGLTFExporterExtension {\r\n    /**\r\n     * The name of this extension\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * Defines whether this extension is enabled\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines whether this extension is required\r\n     */\r\n    required: boolean;\r\n}","export * from \"./glTFAnimation\";\r\nexport * from \"./glTFData\";\r\nexport * from \"./glTFExporter\";\r\nexport * from \"./glTFExporterExtension\";\r\nexport * from \"./glTFMaterialExporter\";\r\nexport * from \"./glTFSerializer\";\r\nexport * from \"./glTFUtilities\";","import { IDisposable, Texture, Nullable, SubMesh } from \"babylonjs\";\r\n\r\nimport { ImageMimeType, IMeshPrimitive } from \"babylonjs-gltf2interface\";\r\n\r\nimport { _BinaryWriter } from \"./glTFExporter\";\r\nimport { IGLTFExporterExtension } from \"../glTFFileExporter\";\r\n\r\n/** @hidden */\r\nexport var __IGLTFExporterExtensionV2 = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for a glTF exporter extension\r\n * @hidden\r\n */\r\nexport interface IGLTFExporterExtensionV2 extends IGLTFExporterExtension, IDisposable {\r\n    /**\r\n     * Define this method to modify the default behavior before exporting a texture\r\n     * @param context The context when loading the asset\r\n     * @param babylonTexture The glTF texture info property\r\n     * @param mimeType The mime-type of the generated image\r\n     * @returns A promise that resolves with the exported glTF texture info when the export is complete, or null if not handled\r\n     */\r\n    preExportTextureAsync?(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Nullable<Promise<Texture>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when exporting texture info\r\n     * @param context The context when loading the asset\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param babylonSubMesh Babylon submesh\r\n     * @param binaryWriter glTF serializer binary writer instance\r\n     */\r\n    postExportMeshPrimitiveAsync?(context: string, meshPrimitive: IMeshPrimitive, babylonSubMesh: SubMesh, binaryWriter: _BinaryWriter): Nullable<Promise<IMeshPrimitive>>;\r\n}","import { TransformNode, Scene } from \"babylonjs\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _Exporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Holds a collection of exporter options and parameters\r\n */\r\nexport interface IExportOptions {\r\n    /**\r\n     * Function which indicates whether a babylon mesh should be exported or not\r\n     * @param transformNode source Babylon transform node. It is used to check whether it should be exported to glTF or not\r\n     * @returns boolean, which indicates whether the mesh should be exported (true) or not (false)\r\n     */\r\n    shouldExportTransformNode?(transformNode: TransformNode): boolean;\r\n    /**\r\n     * The sample rate to bake animation curves\r\n     */\r\n    animationSampleRate?: number;\r\n\r\n    /**\r\n     * Begin serialization without waiting for the scene to be ready\r\n     */\r\n    exportWithoutWaitingForScene?: boolean;\r\n}\r\n\r\n/**\r\n * Class for generating glTF data from a Babylon scene.\r\n */\r\nexport class GLTF2Export {\r\n    /**\r\n     * Exports the geometry of the scene to .gltf file format asynchronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating the glTF file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .gltf file and associates texture names\r\n     * as keys and their data and paths as values\r\n     */\r\n    public static GLTFAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return scene.whenReadyAsync().then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLTFAsync(glTFPrefix);\r\n        });\r\n    }\r\n\r\n    private static _PreExportAsync(scene: Scene, options?: IExportOptions): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return Promise.resolve();\r\n            }\r\n            else {\r\n                return scene.whenReadyAsync();\r\n            }\r\n        });\r\n    }\r\n\r\n    private static _PostExportAsync(scene: Scene, glTFData: GLTFData, options?: IExportOptions): Promise<GLTFData> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return glTFData;\r\n            }\r\n            else {\r\n                return glTFData;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Exports the geometry of the scene to .glb file format asychronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating glb file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .glb filename as key and data as value\r\n     */\r\n    public static GLBAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return this._PreExportAsync(scene, options).then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLBAsync(glTFPrefix).then((glTFData) => {\r\n                return this._PostExportAsync(scene, glTFData, options);\r\n            });\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":""}