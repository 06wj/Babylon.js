<<<<<<< HEAD
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("babylonjs"));
	else if(typeof define === 'function' && define.amd)
		define("babylonjs-serializers", ["babylonjs"], factory);
	else if(typeof exports === 'object')
		exports["babylonjs-serializers"] = factory(require("babylonjs"));
	else
		root["SERIALIZERS"] = factory(root["BABYLON"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_babylonjs__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./legacy/legacy-glTF2Serializer.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./legacy/legacy-glTF2Serializer.ts":
/*!******************************************!*\
  !*** ./legacy/legacy-glTF2Serializer.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var Exporters = __webpack_require__(/*! ../src/glTF/glTFFileExporter */ "./src/glTF/glTFFileExporter.ts");
var Serializers = __webpack_require__(/*! ../src/glTF/2.0 */ "./src/glTF/2.0/index.ts");
/**
 * This is the entry point for the UMD module.
 * The entry point for a future ESM package should be index.ts
 */
var globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);
if (typeof globalObject !== "undefined") {
    for (var exporter in Exporters) {
        globalObject.BABYLON[exporter] = Exporters[exporter];
    }
    for (var serializer in Serializers) {
        globalObject.BABYLON[serializer] = Serializers[serializer];
    }
}
__export(__webpack_require__(/*! ../src/glTF/glTFFileExporter */ "./src/glTF/glTFFileExporter.ts"));
__export(__webpack_require__(/*! ../src/glTF/2.0 */ "./src/glTF/2.0/index.ts"));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/glTF/2.0/Extensions/KHR_texture_transform.ts":
/*!**********************************************************!*\
  !*** ./src/glTF/2.0/Extensions/KHR_texture_transform.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var babylonjs_1 = __webpack_require__(/*! babylonjs */ "babylonjs");
var glTFExporter_1 = __webpack_require__(/*! ../glTFExporter */ "./src/glTF/2.0/glTFExporter.ts");
var NAME = "KHR_texture_transform";
babylonjs_1.Effect.ShadersStore["textureTransformPixelShader"] = __webpack_require__(/*! ../shaders/textureTransform.fragment.fx */ "./src/glTF/2.0/shaders/textureTransform.fragment.fx");
/**
 * @hidden
 */
var KHR_texture_transform = /** @class */ (function () {
    function KHR_texture_transform(exporter) {
        /** Name of this extension */
        this.name = NAME;
        /** Defines whether this extension is enabled */
        this.enabled = true;
        /** Defines whether this extension is required */
        this.required = false;
        this._exporter = exporter;
    }
    KHR_texture_transform.prototype.dispose = function () {
        delete this._exporter;
    };
    KHR_texture_transform.prototype.preExportTextureAsync = function (context, babylonTexture, mimeType) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var texture_transform_extension = {};
            if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {
                texture_transform_extension.offset = [babylonTexture.uOffset, babylonTexture.vOffset];
            }
            if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {
                texture_transform_extension.scale = [babylonTexture.uScale, babylonTexture.vScale];
            }
            if (babylonTexture.wAng !== 0) {
                texture_transform_extension.rotation = babylonTexture.wAng;
            }
            if (!Object.keys(texture_transform_extension).length) {
                resolve(babylonTexture);
            }
            var scale = texture_transform_extension.scale ? new babylonjs_1.Vector2(texture_transform_extension.scale[0], texture_transform_extension.scale[1]) : babylonjs_1.Vector2.One();
            var rotation = texture_transform_extension.rotation != null ? texture_transform_extension.rotation : 0;
            var offset = texture_transform_extension.offset ? new babylonjs_1.Vector2(texture_transform_extension.offset[0], texture_transform_extension.offset[1]) : babylonjs_1.Vector2.Zero();
            var scene = babylonTexture.getScene();
            if (!scene) {
                reject(context + ": \"scene\" is not defined for Babylon texture " + babylonTexture.name + "!");
            }
            else {
                _this.textureTransformTextureAsync(babylonTexture, offset, rotation, scale, scene).then(function (texture) {
                    resolve(texture);
                });
            }
        });
    };
    /**
     * Transform the babylon texture by the offset, rotation and scale parameters using a procedural texture
     * @param babylonTexture
     * @param offset
     * @param rotation
     * @param scale
     * @param scene
     */
    KHR_texture_transform.prototype.textureTransformTextureAsync = function (babylonTexture, offset, rotation, scale, scene) {
        return new Promise(function (resolve, reject) {
            var proceduralTexture = new babylonjs_1.ProceduralTexture("" + babylonTexture.name, babylonTexture.getSize(), "textureTransform", scene);
            if (!proceduralTexture) {
                babylonjs_1.Tools.Log("Cannot create procedural texture for " + babylonTexture.name + "!");
                resolve(babylonTexture);
            }
            proceduralTexture.setTexture("textureSampler", babylonTexture);
            proceduralTexture.setMatrix("textureTransformMat", babylonTexture.getTextureMatrix());
            // isReady trigger creation of effect if it doesnt exist yet
            if (proceduralTexture.isReady()) {
                proceduralTexture.render();
                resolve(proceduralTexture);
            }
            else {
                proceduralTexture.getEffect().executeWhenCompiled(function () {
                    proceduralTexture.render();
                    resolve(proceduralTexture);
                });
            }
        });
    };
    return KHR_texture_transform;
}());
exports.KHR_texture_transform = KHR_texture_transform;
glTFExporter_1._Exporter.RegisterExtension(NAME, function (exporter) { return new KHR_texture_transform(exporter); });


/***/ }),

/***/ "./src/glTF/2.0/Extensions/index.ts":
/*!******************************************!*\
  !*** ./src/glTF/2.0/Extensions/index.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./KHR_texture_transform */ "./src/glTF/2.0/Extensions/KHR_texture_transform.ts"));


/***/ }),

/***/ "./src/glTF/2.0/glTFAnimation.ts":
/*!***************************************!*\
  !*** ./src/glTF/2.0/glTFAnimation.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var babylonjs_1 = __webpack_require__(/*! babylonjs */ "babylonjs");
var glTFUtilities_1 = __webpack_require__(/*! ./glTFUtilities */ "./src/glTF/2.0/glTFUtilities.ts");
/**
 * @hidden
 * Enum for handling in tangent and out tangent.
 */
var _TangentType;
(function (_TangentType) {
    /**
     * Specifies that input tangents are used.
     */
    _TangentType[_TangentType["INTANGENT"] = 0] = "INTANGENT";
    /**
     * Specifies that output tangents are used.
     */
    _TangentType[_TangentType["OUTTANGENT"] = 1] = "OUTTANGENT";
})(_TangentType || (_TangentType = {}));
/**
 * @hidden
 * Utility class for generating glTF animation data from BabylonJS.
 */
var _GLTFAnimation = /** @class */ (function () {
    function _GLTFAnimation() {
    }
    /**
     * @ignore
     *
     * Creates glTF channel animation from BabylonJS animation.
     * @param babylonTransformNode - BabylonJS mesh.
     * @param animation - animation.
     * @param animationChannelTargetPath - The target animation channel.
     * @param convertToRightHandedSystem - Specifies if the values should be converted to right-handed.
     * @param useQuaternion - Specifies if quaternions are used.
     * @returns nullable IAnimationData
     */
    _GLTFAnimation._CreateNodeAnimation = function (babylonTransformNode, animation, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion, animationSampleRate) {
        var inputs = [];
        var outputs = [];
        var keyFrames = animation.getKeys();
        var minMaxKeyFrames = _GLTFAnimation.calculateMinMaxKeyFrames(keyFrames);
        var interpolationOrBake = _GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);
        var frameDelta = minMaxKeyFrames.max - minMaxKeyFrames.min;
        var interpolation = interpolationOrBake.interpolationType;
        var shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;
        if (shouldBakeAnimation) {
            _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);
        }
        else {
            if (interpolation === "LINEAR" /* LINEAR */ || interpolation === "STEP" /* STEP */) {
                _GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);
            }
            else if (interpolation === "CUBICSPLINE" /* CUBICSPLINE */) {
                _GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);
            }
            else {
                _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);
            }
        }
        if (inputs.length && outputs.length) {
            var result = {
                inputs: inputs,
                outputs: outputs,
                samplerInterpolation: interpolation,
                inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : babylonjs_1.Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),
                inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : babylonjs_1.Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond)
            };
            return result;
        }
        return null;
    };
    _GLTFAnimation._DeduceAnimationInfo = function (animation) {
        var animationChannelTargetPath = null;
        var dataAccessorType = "VEC3" /* VEC3 */;
        var useQuaternion = false;
        var property = animation.targetProperty.split('.');
        switch (property[0]) {
            case 'scaling': {
                animationChannelTargetPath = "scale" /* SCALE */;
                break;
            }
            case 'position': {
                animationChannelTargetPath = "translation" /* TRANSLATION */;
                break;
            }
            case 'rotation': {
                dataAccessorType = "VEC4" /* VEC4 */;
                animationChannelTargetPath = "rotation" /* ROTATION */;
                break;
            }
            case 'rotationQuaternion': {
                dataAccessorType = "VEC4" /* VEC4 */;
                useQuaternion = true;
                animationChannelTargetPath = "rotation" /* ROTATION */;
                break;
            }
            default: {
                babylonjs_1.Tools.Error("Unsupported animatable property " + property[0]);
            }
        }
        if (animationChannelTargetPath) {
            return { animationChannelTargetPath: animationChannelTargetPath, dataAccessorType: dataAccessorType, useQuaternion: useQuaternion };
        }
        else {
            babylonjs_1.Tools.Error('animation channel target path and data accessor type could be deduced');
        }
        return null;
    };
    /**
     * @ignore
     * Create node animations from the transform node animations
     * @param babylonTransformNode
     * @param runtimeGLTFAnimation
     * @param idleGLTFAnimations
     * @param nodeMap
     * @param nodes
     * @param binaryWriter
     * @param bufferViews
     * @param accessors
     * @param convertToRightHandedSystem
     */
    _GLTFAnimation._CreateNodeAnimationFromTransformNodeAnimations = function (babylonTransformNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, nodes, binaryWriter, bufferViews, accessors, convertToRightHandedSystem, animationSampleRate) {
        var glTFAnimation;
        if (babylonTransformNode.animations) {
            for (var _i = 0, _a = babylonTransformNode.animations; _i < _a.length; _i++) {
                var animation = _a[_i];
                var animationInfo = _GLTFAnimation._DeduceAnimationInfo(animation);
                if (animationInfo) {
                    glTFAnimation = {
                        name: animation.name,
                        samplers: [],
                        channels: []
                    };
                    _GLTFAnimation.AddAnimation("" + animation.name, animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation, babylonTransformNode, animation, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, binaryWriter, bufferViews, accessors, convertToRightHandedSystem, animationInfo.useQuaternion, animationSampleRate);
                    if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {
                        idleGLTFAnimations.push(glTFAnimation);
                    }
                }
            }
        }
    };
    /**
     * @ignore
     * Create node animations from the animation groups
     * @param babylonScene
     * @param glTFAnimations
     * @param nodeMap
     * @param nodes
     * @param binaryWriter
     * @param bufferViews
     * @param accessors
     * @param convertToRightHandedSystem
     */
    _GLTFAnimation._CreateNodeAnimationFromAnimationGroups = function (babylonScene, glTFAnimations, nodeMap, nodes, binaryWriter, bufferViews, accessors, convertToRightHandedSystem, animationSampleRate) {
        var glTFAnimation;
        if (babylonScene.animationGroups) {
            var animationGroups = babylonScene.animationGroups;
            for (var _i = 0, animationGroups_1 = animationGroups; _i < animationGroups_1.length; _i++) {
                var animationGroup = animationGroups_1[_i];
                glTFAnimation = {
                    name: animationGroup.name,
                    channels: [],
                    samplers: []
                };
                for (var _a = 0, _b = animationGroup.targetedAnimations; _a < _b.length; _a++) {
                    var targetAnimation = _b[_a];
                    var target = targetAnimation.target;
                    var animation = targetAnimation.animation;
                    if (target instanceof babylonjs_1.Mesh || target.length === 1 && target[0] instanceof babylonjs_1.Mesh) { // TODO: Update to support bones
                        var animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);
                        if (animationInfo) {
                            var babylonMesh = target instanceof babylonjs_1.Mesh ? target : target[0];
                            _GLTFAnimation.AddAnimation("" + animation.name, glTFAnimation, babylonMesh, animation, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, binaryWriter, bufferViews, accessors, convertToRightHandedSystem, animationInfo.useQuaternion, animationSampleRate);
                        }
                    }
                }
                if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {
                    glTFAnimations.push(glTFAnimation);
                }
            }
        }
    };
    _GLTFAnimation.AddAnimation = function (name, glTFAnimation, babylonTransformNode, animation, dataAccessorType, animationChannelTargetPath, nodeMap, binaryWriter, bufferViews, accessors, convertToRightHandedSystem, useQuaternion, animationSampleRate) {
        var animationData = _GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion, animationSampleRate);
        var bufferView;
        var accessor;
        var keyframeAccessorIndex;
        var dataAccessorIndex;
        var outputLength;
        var animationSampler;
        var animationChannel;
        if (animationData) {
            var nodeIndex = nodeMap[babylonTransformNode.uniqueId];
            // Creates buffer view and accessor for key frames.
            var byteLength = animationData.inputs.length * 4;
            bufferView = glTFUtilities_1._GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, name + "  keyframe data view");
            bufferViews.push(bufferView);
            animationData.inputs.forEach(function (input) {
                binaryWriter.setFloat32(input);
            });
            accessor = glTFUtilities_1._GLTFUtilities._CreateAccessor(bufferViews.length - 1, name + "  keyframes", "SCALAR" /* SCALAR */, 5126 /* FLOAT */, animationData.inputs.length, null, [animationData.inputsMin], [animationData.inputsMax]);
            accessors.push(accessor);
            keyframeAccessorIndex = accessors.length - 1;
            // create bufferview and accessor for keyed values.
            outputLength = animationData.outputs.length;
            byteLength = dataAccessorType === "VEC3" /* VEC3 */ ? animationData.outputs.length * 12 : animationData.outputs.length * 16;
            // check for in and out tangents
            bufferView = glTFUtilities_1._GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, name + "  data view");
            bufferViews.push(bufferView);
            animationData.outputs.forEach(function (output) {
                output.forEach(function (entry) {
                    binaryWriter.setFloat32(entry);
                });
            });
            accessor = glTFUtilities_1._GLTFUtilities._CreateAccessor(bufferViews.length - 1, name + "  data", dataAccessorType, 5126 /* FLOAT */, outputLength, null, null, null);
            accessors.push(accessor);
            dataAccessorIndex = accessors.length - 1;
            // create sampler
            animationSampler = {
                interpolation: animationData.samplerInterpolation,
                input: keyframeAccessorIndex,
                output: dataAccessorIndex
            };
            glTFAnimation.samplers.push(animationSampler);
            // create channel
            animationChannel = {
                sampler: glTFAnimation.samplers.length - 1,
                target: {
                    node: nodeIndex,
                    path: animationChannelTargetPath
                }
            };
            glTFAnimation.channels.push(animationChannel);
        }
    };
    /**
     * Create a baked animation
     * @param babylonTransformNode BabylonJS mesh
     * @param animation BabylonJS animation corresponding to the BabylonJS mesh
     * @param animationChannelTargetPath animation target channel
     * @param minFrame minimum animation frame
     * @param maxFrame maximum animation frame
     * @param fps frames per second of the animation
     * @param inputs input key frames of the animation
     * @param outputs output key frame data of the animation
     * @param convertToRightHandedSystem converts the values to right-handed
     * @param useQuaternion specifies if quaternions should be used
     */
    _GLTFAnimation._CreateBakedAnimation = function (babylonTransformNode, animation, animationChannelTargetPath, minFrame, maxFrame, fps, sampleRate, inputs, outputs, minMaxFrames, convertToRightHandedSystem, useQuaternion) {
        var value;
        var quaternionCache = babylonjs_1.Quaternion.Identity();
        var previousTime = null;
        var time;
        var maxUsedFrame = null;
        var currKeyFrame = null;
        var nextKeyFrame = null;
        var prevKeyFrame = null;
        var endFrame = null;
        minMaxFrames.min = babylonjs_1.Tools.FloatRound(minFrame / fps);
        var keyFrames = animation.getKeys();
        for (var i = 0, length_1 = keyFrames.length; i < length_1; ++i) {
            endFrame = null;
            currKeyFrame = keyFrames[i];
            if (i + 1 < length_1) {
                nextKeyFrame = keyFrames[i + 1];
                if (currKeyFrame.value.equals(nextKeyFrame.value)) {
                    if (i === 0) { // set the first frame to itself
                        endFrame = currKeyFrame.frame;
                    }
                    else {
                        continue;
                    }
                }
                else {
                    endFrame = nextKeyFrame.frame;
                }
            }
            else {
                // at the last key frame
                prevKeyFrame = keyFrames[i - 1];
                if (currKeyFrame.value.equals(prevKeyFrame.value)) {
                    continue;
                }
                else {
                    endFrame = maxFrame;
                }
            }
            if (endFrame) {
                for (var f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {
                    time = babylonjs_1.Tools.FloatRound(f / fps);
                    if (time === previousTime) {
                        continue;
                    }
                    previousTime = time;
                    maxUsedFrame = time;
                    value = animation._interpolate(f, 0, undefined, animation.loopMode);
                    _GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, convertToRightHandedSystem, useQuaternion);
                }
            }
        }
        if (maxUsedFrame) {
            minMaxFrames.max = maxUsedFrame;
        }
    };
    _GLTFAnimation._ConvertFactorToVector3OrQuaternion = function (factor, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion) {
        var property;
        var componentName;
        var value = null;
        var basePositionRotationOrScale = _GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);
        if (animationType === babylonjs_1.Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.
            property = animation.targetProperty.split('.');
            componentName = property ? property[1] : ''; // x, y, or z component
            value = useQuaternion ? BABYLON.Quaternion.FromArray(basePositionRotationOrScale).normalize() : BABYLON.Vector3.FromArray(basePositionRotationOrScale);
            switch (componentName) {
                case 'x': {
                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== "scale" /* SCALE */)) ? -factor : factor;
                    break;
                }
                case 'y': {
                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== "scale" /* SCALE */)) ? -factor : factor;
                    break;
                }
                case 'z': {
                    value[componentName] = (convertToRightHandedSystem && !useQuaternion && (animationChannelTargetPath !== "scale" /* SCALE */)) ? -factor : factor;
                    break;
                }
                case 'w': {
                    value.w = factor;
                    break;
                }
                default: {
                    babylonjs_1.Tools.Error("glTFAnimation: Unsupported component type \"" + componentName + "\" for scale animation!");
                }
            }
        }
        return value;
    };
    _GLTFAnimation._SetInterpolatedValue = function (babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, convertToRightHandedSystem, useQuaternion) {
        var animationType = animation.dataType;
        var cacheValue;
        inputs.push(time);
        if (typeof value === "number") {
            value = this._ConvertFactorToVector3OrQuaternion(value, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);
        }
        if (value) {
            if (animationChannelTargetPath === "rotation" /* ROTATION */) {
                if (useQuaternion) {
                    quaternionCache = value;
                }
                else {
                    cacheValue = value;
                    babylonjs_1.Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);
                }
                if (convertToRightHandedSystem) {
                    glTFUtilities_1._GLTFUtilities._GetRightHandedQuaternionFromRef(quaternionCache);
                    if (!babylonTransformNode.parent) {
                        quaternionCache = babylonjs_1.Quaternion.FromArray([0, 1, 0, 0]).multiply(quaternionCache);
                    }
                }
                outputs.push(quaternionCache.asArray());
            }
            else {
                cacheValue = value;
                if (convertToRightHandedSystem && (animationChannelTargetPath !== "scale" /* SCALE */)) {
                    glTFUtilities_1._GLTFUtilities._GetRightHandedPositionVector3FromRef(cacheValue);
                    if (!babylonTransformNode.parent) {
                        cacheValue.x *= -1;
                        cacheValue.z *= -1;
                    }
                }
                outputs.push(cacheValue.asArray());
            }
        }
    };
    /**
     * Creates linear animation from the animation key frames
     * @param babylonTransformNode BabylonJS mesh
     * @param animation BabylonJS animation
     * @param animationChannelTargetPath The target animation channel
     * @param frameDelta The difference between the last and first frame of the animation
     * @param inputs Array to store the key frame times
     * @param outputs Array to store the key frame data
     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed
     * @param useQuaternion Specifies if quaternions are used in the animation
     */
    _GLTFAnimation._CreateLinearOrStepAnimation = function (babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion) {
        for (var _i = 0, _a = animation.getKeys(); _i < _a.length; _i++) {
            var keyFrame = _a[_i];
            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.
            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);
        }
    };
    /**
     * Creates cubic spline animation from the animation key frames
     * @param babylonTransformNode BabylonJS mesh
     * @param animation BabylonJS animation
     * @param animationChannelTargetPath The target animation channel
     * @param frameDelta The difference between the last and first frame of the animation
     * @param inputs Array to store the key frame times
     * @param outputs Array to store the key frame data
     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed
     * @param useQuaternion Specifies if quaternions are used in the animation
     */
    _GLTFAnimation._CreateCubicSplineAnimation = function (babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion) {
        animation.getKeys().forEach(function (keyFrame) {
            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.
            _GLTFAnimation.AddSplineTangent(babylonTransformNode, _TangentType.INTANGENT, outputs, animationChannelTargetPath, "CUBICSPLINE" /* CUBICSPLINE */, keyFrame, frameDelta, useQuaternion, convertToRightHandedSystem);
            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);
            _GLTFAnimation.AddSplineTangent(babylonTransformNode, _TangentType.OUTTANGENT, outputs, animationChannelTargetPath, "CUBICSPLINE" /* CUBICSPLINE */, keyFrame, frameDelta, useQuaternion, convertToRightHandedSystem);
        });
    };
    _GLTFAnimation._GetBasePositionRotationOrScale = function (babylonTransformNode, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion) {
        var basePositionRotationOrScale;
        if (animationChannelTargetPath === "rotation" /* ROTATION */) {
            if (useQuaternion) {
                if (babylonTransformNode.rotationQuaternion) {
                    basePositionRotationOrScale = babylonTransformNode.rotationQuaternion.asArray();
                    if (convertToRightHandedSystem) {
                        glTFUtilities_1._GLTFUtilities._GetRightHandedQuaternionArrayFromRef(basePositionRotationOrScale);
                        if (!babylonTransformNode.parent) {
                            basePositionRotationOrScale = babylonjs_1.Quaternion.FromArray([0, 1, 0, 0]).multiply(babylonjs_1.Quaternion.FromArray(basePositionRotationOrScale)).asArray();
                        }
                    }
                }
                else {
                    basePositionRotationOrScale = BABYLON.Quaternion.Identity().asArray();
                }
            }
            else {
                basePositionRotationOrScale = babylonTransformNode.rotation.asArray();
                glTFUtilities_1._GLTFUtilities._GetRightHandedNormalArray3FromRef(basePositionRotationOrScale);
            }
        }
        else if (animationChannelTargetPath === "translation" /* TRANSLATION */) {
            basePositionRotationOrScale = babylonTransformNode.position.asArray();
            if (convertToRightHandedSystem) {
                glTFUtilities_1._GLTFUtilities._GetRightHandedPositionArray3FromRef(basePositionRotationOrScale);
            }
        }
        else { // scale
            basePositionRotationOrScale = babylonTransformNode.scaling.asArray();
        }
        return basePositionRotationOrScale;
    };
    /**
     * Adds a key frame value
     * @param keyFrame
     * @param animation
     * @param outputs
     * @param animationChannelTargetPath
     * @param basePositionRotationOrScale
     * @param convertToRightHandedSystem
     * @param useQuaternion
     */
    _GLTFAnimation._AddKeyframeValue = function (keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion) {
        var value;
        var newPositionRotationOrScale;
        var animationType = animation.dataType;
        if (animationType === babylonjs_1.Animation.ANIMATIONTYPE_VECTOR3) {
            value = keyFrame.value.asArray();
            if (animationChannelTargetPath === "rotation" /* ROTATION */) {
                var array = babylonjs_1.Vector3.FromArray(value);
                var rotationQuaternion = babylonjs_1.Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);
                if (convertToRightHandedSystem) {
                    glTFUtilities_1._GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);
                    if (!babylonTransformNode.parent) {
                        rotationQuaternion = babylonjs_1.Quaternion.FromArray([0, 1, 0, 0]).multiply(rotationQuaternion);
                    }
                }
                value = rotationQuaternion.asArray();
            }
            else if (animationChannelTargetPath === "translation" /* TRANSLATION */) {
                if (convertToRightHandedSystem) {
                    glTFUtilities_1._GLTFUtilities._GetRightHandedNormalArray3FromRef(value);
                    if (!babylonTransformNode.parent) {
                        value[0] *= -1;
                        value[2] *= -1;
                    }
                }
            }
            outputs.push(value); // scale  vector.
        }
        else if (animationType === babylonjs_1.Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.
            newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(keyFrame.value, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);
            if (newPositionRotationOrScale) {
                if (animationChannelTargetPath === "rotation" /* ROTATION */) {
                    var posRotScale = useQuaternion ? newPositionRotationOrScale : babylonjs_1.Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();
                    if (convertToRightHandedSystem) {
                        glTFUtilities_1._GLTFUtilities._GetRightHandedQuaternionFromRef(posRotScale);
                        if (!babylonTransformNode.parent) {
                            posRotScale = babylonjs_1.Quaternion.FromArray([0, 1, 0, 0]).multiply(posRotScale);
                        }
                    }
                    outputs.push(posRotScale.asArray());
                }
                else if (animationChannelTargetPath === "translation" /* TRANSLATION */) {
                    if (convertToRightHandedSystem) {
                        glTFUtilities_1._GLTFUtilities._GetRightHandedNormalVector3FromRef(newPositionRotationOrScale);
                        if (!babylonTransformNode.parent) {
                            newPositionRotationOrScale.x *= -1;
                            newPositionRotationOrScale.z *= -1;
                        }
                    }
                }
                outputs.push(newPositionRotationOrScale.asArray());
            }
        }
        else if (animationType === babylonjs_1.Animation.ANIMATIONTYPE_QUATERNION) {
            value = keyFrame.value.normalize().asArray();
            if (convertToRightHandedSystem) {
                glTFUtilities_1._GLTFUtilities._GetRightHandedQuaternionArrayFromRef(value);
                if (!babylonTransformNode.parent) {
                    value = babylonjs_1.Quaternion.FromArray([0, 1, 0, 0]).multiply(babylonjs_1.Quaternion.FromArray(value)).asArray();
                }
            }
            outputs.push(value);
        }
        else {
            babylonjs_1.Tools.Error('glTFAnimation: Unsupported key frame values for animation!');
        }
    };
    /**
     * Determine the interpolation based on the key frames
     * @param keyFrames
     * @param animationChannelTargetPath
     * @param useQuaternion
     */
    _GLTFAnimation._DeduceInterpolation = function (keyFrames, animationChannelTargetPath, useQuaternion) {
        var interpolationType;
        var shouldBakeAnimation = false;
        var key;
        if (animationChannelTargetPath === "rotation" /* ROTATION */ && !useQuaternion) {
            return { interpolationType: "LINEAR" /* LINEAR */, shouldBakeAnimation: true };
        }
        for (var i = 0, length_2 = keyFrames.length; i < length_2; ++i) {
            key = keyFrames[i];
            if (key.inTangent || key.outTangent) {
                if (interpolationType) {
                    if (interpolationType !== "CUBICSPLINE" /* CUBICSPLINE */) {
                        interpolationType = "LINEAR" /* LINEAR */;
                        shouldBakeAnimation = true;
                        break;
                    }
                }
                else {
                    interpolationType = "CUBICSPLINE" /* CUBICSPLINE */;
                }
            }
            else {
                if (interpolationType) {
                    if (interpolationType === "CUBICSPLINE" /* CUBICSPLINE */ ||
                        (key.interpolation && (key.interpolation === babylonjs_1.AnimationKeyInterpolation.STEP) && interpolationType !== "STEP" /* STEP */)) {
                        interpolationType = "LINEAR" /* LINEAR */;
                        shouldBakeAnimation = true;
                        break;
                    }
                }
                else {
                    if (key.interpolation && (key.interpolation === babylonjs_1.AnimationKeyInterpolation.STEP)) {
                        interpolationType = "STEP" /* STEP */;
                    }
                    else {
                        interpolationType = "LINEAR" /* LINEAR */;
                    }
                }
            }
        }
        if (!interpolationType) {
            interpolationType = "LINEAR" /* LINEAR */;
        }
        return { interpolationType: interpolationType, shouldBakeAnimation: shouldBakeAnimation };
    };
    /**
     * Adds an input tangent or output tangent to the output data
     * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion
     * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)
     * @param outputs The animation data by keyframe
     * @param animationChannelTargetPath The target animation channel
     * @param interpolation The interpolation type
     * @param keyFrame The key frame with the animation data
     * @param frameDelta Time difference between two frames used to scale the tangent by the frame delta
     * @param useQuaternion Specifies if quaternions are used
     * @param convertToRightHandedSystem Specifies if the values should be converted to right-handed
     */
    _GLTFAnimation.AddSplineTangent = function (babylonTransformNode, tangentType, outputs, animationChannelTargetPath, interpolation, keyFrame, frameDelta, useQuaternion, convertToRightHandedSystem) {
        var tangent;
        var tangentValue = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;
        if (interpolation === "CUBICSPLINE" /* CUBICSPLINE */) {
            if (animationChannelTargetPath === "rotation" /* ROTATION */) {
                if (tangentValue) {
                    if (useQuaternion) {
                        tangent = tangentValue.scale(frameDelta).asArray();
                    }
                    else {
                        var array = tangentValue.scale(frameDelta);
                        tangent = babylonjs_1.Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();
                    }
                    if (convertToRightHandedSystem) {
                        glTFUtilities_1._GLTFUtilities._GetRightHandedQuaternionArrayFromRef(tangent);
                        if (!babylonTransformNode.parent) {
                            tangent = babylonjs_1.Quaternion.FromArray([0, 1, 0, 0]).multiply(babylonjs_1.Quaternion.FromArray(tangent)).asArray();
                        }
                    }
                }
                else {
                    tangent = [0, 0, 0, 0];
                }
            }
            else {
                if (tangentValue) {
                    tangent = tangentValue.scale(frameDelta).asArray();
                    if (convertToRightHandedSystem) {
                        if (animationChannelTargetPath === "translation" /* TRANSLATION */) {
                            glTFUtilities_1._GLTFUtilities._GetRightHandedPositionArray3FromRef(tangent);
                            if (!babylonTransformNode.parent) {
                                tangent[0] *= -1; // x
                                tangent[2] *= -1; // z
                            }
                        }
                    }
                }
                else {
                    tangent = [0, 0, 0];
                }
            }
            outputs.push(tangent);
        }
    };
    /**
     * Get the minimum and maximum key frames' frame values
     * @param keyFrames animation key frames
     * @returns the minimum and maximum key frame value
     */
    _GLTFAnimation.calculateMinMaxKeyFrames = function (keyFrames) {
        var min = Infinity;
        var max = -Infinity;
        keyFrames.forEach(function (keyFrame) {
            min = Math.min(min, keyFrame.frame);
            max = Math.max(max, keyFrame.frame);
        });
        return { min: min, max: max };
    };
    return _GLTFAnimation;
}());
exports._GLTFAnimation = _GLTFAnimation;


/***/ }),

/***/ "./src/glTF/2.0/glTFData.ts":
/*!**********************************!*\
  !*** ./src/glTF/2.0/glTFData.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class for holding and downloading glTF file data
 */
var GLTFData = /** @class */ (function () {
    /**
     * Initializes the glTF file object
     */
    function GLTFData() {
        this.glTFFiles = {};
    }
    /**
     * Downloads the glTF data as files based on their names and data
     */
    GLTFData.prototype.downloadFiles = function () {
        /**
        * Checks for a matching suffix at the end of a string (for ES5 and lower)
        * @param str Source string
        * @param suffix Suffix to search for in the source string
        * @returns Boolean indicating whether the suffix was found (true) or not (false)
        */
        function endsWith(str, suffix) {
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        }
        for (var key in this.glTFFiles) {
            var link = document.createElement('a');
            document.body.appendChild(link);
            link.setAttribute("type", "hidden");
            link.download = key;
            var blob = this.glTFFiles[key];
            var mimeType = void 0;
            if (endsWith(key, ".glb")) {
                mimeType = { type: "model/gltf-binary" };
            }
            else if (endsWith(key, ".bin")) {
                mimeType = { type: "application/octet-stream" };
            }
            else if (endsWith(key, ".gltf")) {
                mimeType = { type: "model/gltf+json" };
            }
            else if (endsWith(key, ".jpeg" || ".jpg")) {
                mimeType = { type: "image/jpeg" /* JPEG */ };
            }
            else if (endsWith(key, ".png")) {
                mimeType = { type: "image/png" /* PNG */ };
            }
            link.href = window.URL.createObjectURL(new Blob([blob], mimeType));
            link.click();
        }
    };
    return GLTFData;
}());
exports.GLTFData = GLTFData;


/***/ }),

/***/ "./src/glTF/2.0/glTFExporter.ts":
/*!**************************************!*\
  !*** ./src/glTF/2.0/glTFExporter.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var babylonjs_1 = __webpack_require__(/*! babylonjs */ "babylonjs");
var glTFMaterialExporter_1 = __webpack_require__(/*! ./glTFMaterialExporter */ "./src/glTF/2.0/glTFMaterialExporter.ts");
var glTFUtilities_1 = __webpack_require__(/*! ./glTFUtilities */ "./src/glTF/2.0/glTFUtilities.ts");
var glTFData_1 = __webpack_require__(/*! ./glTFData */ "./src/glTF/2.0/glTFData.ts");
var glTFAnimation_1 = __webpack_require__(/*! ./glTFAnimation */ "./src/glTF/2.0/glTFAnimation.ts");
/**
 * Converts Babylon Scene into glTF 2.0.
 * @hidden
 */
var _Exporter = /** @class */ (function () {
    /**
     * Creates a glTF Exporter instance, which can accept optional exporter options
     * @param babylonScene Babylon scene object
     * @param options Options to modify the behavior of the exporter
     */
    function _Exporter(babylonScene, options) {
        this._extensions = {};
        this._asset = { generator: "BabylonJS", version: "2.0" };
        this._extensionsUsed = [];
        this._extensionsRequired = [];
        this._babylonScene = babylonScene;
        this._bufferViews = [];
        this._accessors = [];
        this._meshes = [];
        this._scenes = [];
        this._nodes = [];
        this._images = [];
        this._materials = [];
        this._materialMap = [];
        this._textures = [];
        this._samplers = [];
        this._animations = [];
        this._imageData = {};
        this._convertToRightHandedSystem = this._babylonScene.useRightHandedSystem ? false : true;
        var _options = options || {};
        this._shouldExportTransformNode = _options.shouldExportTransformNode ? _options.shouldExportTransformNode : function (babylonTransformNode) { return true; };
        this._animationSampleRate = _options.animationSampleRate ? _options.animationSampleRate : 1 / 60;
        this._glTFMaterialExporter = new glTFMaterialExporter_1._GLTFMaterialExporter(this);
        this._loadExtensions();
    }
    _Exporter.prototype._applyExtensions = function (property, actionAsync) {
        for (var _i = 0, _a = _Exporter._ExtensionNames; _i < _a.length; _i++) {
            var name_1 = _a[_i];
            var extension = this._extensions[name_1];
            if (extension.enabled) {
                var exporterProperty = property;
                exporterProperty._activeLoaderExtensions = exporterProperty._activeLoaderExtensions || {};
                var activeLoaderExtensions = exporterProperty._activeLoaderExtensions;
                if (!activeLoaderExtensions[name_1]) {
                    activeLoaderExtensions[name_1] = true;
                    try {
                        var result = actionAsync(extension);
                        if (result) {
                            return result;
                        }
                    }
                    finally {
                        delete activeLoaderExtensions[name_1];
                        delete exporterProperty._activeLoaderExtensions;
                    }
                }
            }
        }
        return null;
    };
    _Exporter.prototype._extensionsPreExportTextureAsync = function (context, babylonTexture, mimeType) {
        return this._applyExtensions(babylonTexture, function (extension) { return extension.preExportTextureAsync && extension.preExportTextureAsync(context, babylonTexture, mimeType); });
    };
    _Exporter.prototype._extensionsPostExportMeshPrimitiveAsync = function (context, meshPrimitive, babylonSubMesh, binaryWriter) {
        return this._applyExtensions(meshPrimitive, function (extension) { return extension.postExportMeshPrimitiveAsync && extension.postExportMeshPrimitiveAsync(context, meshPrimitive, babylonSubMesh, binaryWriter); });
    };
    /**
     * Load glTF serializer extensions
     */
    _Exporter.prototype._loadExtensions = function () {
        for (var _i = 0, _a = _Exporter._ExtensionNames; _i < _a.length; _i++) {
            var name_2 = _a[_i];
            var extension = _Exporter._ExtensionFactories[name_2](this);
            this._extensions[name_2] = extension;
        }
    };
    /**
     * Registers a glTF exporter extension
     * @param name Name of the extension to export
     * @param factory The factory function that creates the exporter extension
     */
    _Exporter.RegisterExtension = function (name, factory) {
        if (_Exporter.UnregisterExtension(name)) {
            babylonjs_1.Tools.Warn("Extension with the name " + name + " already exists");
        }
        _Exporter._ExtensionFactories[name] = factory;
        _Exporter._ExtensionNames.push(name);
    };
    /**
     * Un-registers an exporter extension
     * @param name The name fo the exporter extension
     * @returns A boolean indicating whether the extension has been un-registered
     */
    _Exporter.UnregisterExtension = function (name) {
        if (!_Exporter._ExtensionFactories[name]) {
            return false;
        }
        delete _Exporter._ExtensionFactories[name];
        var index = _Exporter._ExtensionNames.indexOf(name);
        if (index !== -1) {
            _Exporter._ExtensionNames.splice(index, 1);
        }
        return true;
    };
    /**
     * Lazy load a local engine with premultiplied alpha set to false
     */
    _Exporter.prototype._getLocalEngine = function () {
        if (!this._localEngine) {
            var localCanvas = document.createElement('canvas');
            localCanvas.id = "WriteCanvas";
            localCanvas.width = 2048;
            localCanvas.height = 2048;
            this._localEngine = new babylonjs_1.Engine(localCanvas, true, { premultipliedAlpha: false, preserveDrawingBuffer: true });
            this._localEngine.setViewport(new babylonjs_1.Viewport(0, 0, 1, 1));
        }
        return this._localEngine;
    };
    _Exporter.prototype.reorderIndicesBasedOnPrimitiveMode = function (submesh, primitiveMode, babylonIndices, byteOffset, binaryWriter) {
        switch (primitiveMode) {
            case babylonjs_1.Material.TriangleFillMode: {
                if (!byteOffset) {
                    byteOffset = 0;
                }
                for (var i = submesh.indexStart, length_1 = submesh.indexStart + submesh.indexCount; i < length_1; i = i + 3) {
                    var index = byteOffset + i * 4;
                    // swap the second and third indices
                    var secondIndex = binaryWriter.getUInt32(index + 4);
                    var thirdIndex = binaryWriter.getUInt32(index + 8);
                    binaryWriter.setUInt32(thirdIndex, index + 4);
                    binaryWriter.setUInt32(secondIndex, index + 8);
                }
                break;
            }
            case babylonjs_1.Material.TriangleFanDrawMode: {
                for (var i = submesh.indexStart + submesh.indexCount - 1, start = submesh.indexStart; i >= start; --i) {
                    binaryWriter.setUInt32(babylonIndices[i], byteOffset);
                    byteOffset += 4;
                }
                break;
            }
            case babylonjs_1.Material.TriangleStripDrawMode: {
                if (submesh.indexCount >= 3) {
                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 2], byteOffset + 4);
                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 1], byteOffset + 8);
                }
                break;
            }
        }
    };
    /**
     * Reorders the vertex attribute data based on the primitive mode.  This is necessary when indices are not available and the winding order is
     * clock-wise during export to glTF
     * @param submesh BabylonJS submesh
     * @param primitiveMode Primitive mode of the mesh
     * @param sideOrientation the winding order of the submesh
     * @param vertexBufferKind The type of vertex attribute
     * @param meshAttributeArray The vertex attribute data
     * @param byteOffset The offset to the binary data
     * @param binaryWriter The binary data for the glTF file
     */
    _Exporter.prototype.reorderVertexAttributeDataBasedOnPrimitiveMode = function (submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter) {
        if (this._convertToRightHandedSystem && sideOrientation === babylonjs_1.Material.ClockWiseSideOrientation) {
            switch (primitiveMode) {
                case babylonjs_1.Material.TriangleFillMode: {
                    this.reorderTriangleFillMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);
                    break;
                }
                case babylonjs_1.Material.TriangleStripDrawMode: {
                    this.reorderTriangleStripDrawMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);
                    break;
                }
                case babylonjs_1.Material.TriangleFanDrawMode: {
                    this.reorderTriangleFanMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);
                    break;
                }
            }
        }
    };
    /**
     * Reorders the vertex attributes in the correct triangle mode order .  This is necessary when indices are not available and the winding order is
     * clock-wise during export to glTF
     * @param submesh BabylonJS submesh
     * @param primitiveMode Primitive mode of the mesh
     * @param sideOrientation the winding order of the submesh
     * @param vertexBufferKind The type of vertex attribute
     * @param meshAttributeArray The vertex attribute data
     * @param byteOffset The offset to the binary data
     * @param binaryWriter The binary data for the glTF file
     */
    _Exporter.prototype.reorderTriangleFillMode = function (submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter) {
        var vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh());
        if (vertexBuffer) {
            var stride = vertexBuffer.byteStride / babylonjs_1.VertexBuffer.GetTypeByteLength(vertexBuffer.type);
            if (submesh.verticesCount % 3 !== 0) {
                babylonjs_1.Tools.Error('The submesh vertices for the triangle fill mode is not divisible by 3!');
            }
            else {
                var vertexData = [];
                var index = 0;
                switch (vertexBufferKind) {
                    case babylonjs_1.VertexBuffer.PositionKind:
                    case babylonjs_1.VertexBuffer.NormalKind: {
                        for (var x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {
                            index = x * stride;
                            vertexData.push(babylonjs_1.Vector3.FromArray(meshAttributeArray, index));
                            vertexData.push(babylonjs_1.Vector3.FromArray(meshAttributeArray, index + 2 * stride));
                            vertexData.push(babylonjs_1.Vector3.FromArray(meshAttributeArray, index + stride));
                        }
                        break;
                    }
                    case babylonjs_1.VertexBuffer.TangentKind: {
                        for (var x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {
                            index = x * stride;
                            vertexData.push(babylonjs_1.Vector4.FromArray(meshAttributeArray, index));
                            vertexData.push(babylonjs_1.Vector4.FromArray(meshAttributeArray, index + 2 * stride));
                            vertexData.push(babylonjs_1.Vector4.FromArray(meshAttributeArray, index + stride));
                        }
                        break;
                    }
                    case babylonjs_1.VertexBuffer.ColorKind: {
                        var size = vertexBuffer.getSize();
                        for (var x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + size) {
                            index = x * stride;
                            if (size === 4) {
                                vertexData.push(babylonjs_1.Vector4.FromArray(meshAttributeArray, index));
                                vertexData.push(babylonjs_1.Vector4.FromArray(meshAttributeArray, index + 2 * stride));
                                vertexData.push(babylonjs_1.Vector4.FromArray(meshAttributeArray, index + stride));
                            }
                            else {
                                vertexData.push(babylonjs_1.Vector3.FromArray(meshAttributeArray, index));
                                vertexData.push(babylonjs_1.Vector3.FromArray(meshAttributeArray, index + 2 * stride));
                                vertexData.push(babylonjs_1.Vector3.FromArray(meshAttributeArray, index + stride));
                            }
                        }
                        break;
                    }
                    case babylonjs_1.VertexBuffer.UVKind:
                    case babylonjs_1.VertexBuffer.UV2Kind: {
                        for (var x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {
                            index = x * stride;
                            vertexData.push(babylonjs_1.Vector2.FromArray(meshAttributeArray, index));
                            vertexData.push(babylonjs_1.Vector2.FromArray(meshAttributeArray, index + 2 * stride));
                            vertexData.push(babylonjs_1.Vector2.FromArray(meshAttributeArray, index + stride));
                        }
                        break;
                    }
                    default: {
                        babylonjs_1.Tools.Error("Unsupported Vertex Buffer type: " + vertexBufferKind);
                    }
                }
                this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter);
            }
        }
        else {
            babylonjs_1.Tools.Warn("reorderTriangleFillMode: Vertex Buffer Kind " + vertexBufferKind + " not present!");
        }
    };
    /**
     * Reorders the vertex attributes in the correct triangle strip order.  This is necessary when indices are not available and the winding order is
     * clock-wise during export to glTF
     * @param submesh BabylonJS submesh
     * @param primitiveMode Primitive mode of the mesh
     * @param sideOrientation the winding order of the submesh
     * @param vertexBufferKind The type of vertex attribute
     * @param meshAttributeArray The vertex attribute data
     * @param byteOffset The offset to the binary data
     * @param binaryWriter The binary data for the glTF file
     */
    _Exporter.prototype.reorderTriangleStripDrawMode = function (submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter) {
        var vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh());
        if (vertexBuffer) {
            var stride = vertexBuffer.byteStride / babylonjs_1.VertexBuffer.GetTypeByteLength(vertexBuffer.type);
            var vertexData = [];
            var index = 0;
            switch (vertexBufferKind) {
                case babylonjs_1.VertexBuffer.PositionKind:
                case babylonjs_1.VertexBuffer.NormalKind: {
                    index = submesh.verticesStart;
                    vertexData.push(babylonjs_1.Vector3.FromArray(meshAttributeArray, index + 2 * stride));
                    vertexData.push(babylonjs_1.Vector3.FromArray(meshAttributeArray, index + stride));
                    break;
                }
                case babylonjs_1.VertexBuffer.TangentKind: {
                    for (var x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {
                        index = x * stride;
                        vertexData.push(babylonjs_1.Vector4.FromArray(meshAttributeArray, index));
                    }
                    break;
                }
                case babylonjs_1.VertexBuffer.ColorKind: {
                    for (var x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {
                        index = x * stride;
                        vertexBuffer.getSize() === 4 ? vertexData.push(babylonjs_1.Vector4.FromArray(meshAttributeArray, index)) : vertexData.push(babylonjs_1.Vector3.FromArray(meshAttributeArray, index));
                    }
                    break;
                }
                case babylonjs_1.VertexBuffer.UVKind:
                case babylonjs_1.VertexBuffer.UV2Kind: {
                    for (var x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {
                        index = x * stride;
                        vertexData.push(babylonjs_1.Vector2.FromArray(meshAttributeArray, index));
                    }
                    break;
                }
                default: {
                    babylonjs_1.Tools.Error("Unsupported Vertex Buffer type: " + vertexBufferKind);
                }
            }
            this.writeVertexAttributeData(vertexData, byteOffset + 12, vertexBufferKind, meshAttributeArray, binaryWriter);
        }
        else {
            babylonjs_1.Tools.Warn("reorderTriangleStripDrawMode: Vertex buffer kind " + vertexBufferKind + " not present!");
        }
    };
    /**
     * Reorders the vertex attributes in the correct triangle fan order.  This is necessary when indices are not available and the winding order is
     * clock-wise during export to glTF
     * @param submesh BabylonJS submesh
     * @param primitiveMode Primitive mode of the mesh
     * @param sideOrientation the winding order of the submesh
     * @param vertexBufferKind The type of vertex attribute
     * @param meshAttributeArray The vertex attribute data
     * @param byteOffset The offset to the binary data
     * @param binaryWriter The binary data for the glTF file
     */
    _Exporter.prototype.reorderTriangleFanMode = function (submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter) {
        var vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh());
        if (vertexBuffer) {
            var stride = vertexBuffer.byteStride / babylonjs_1.VertexBuffer.GetTypeByteLength(vertexBuffer.type);
            var vertexData = [];
            var index = 0;
            switch (vertexBufferKind) {
                case babylonjs_1.VertexBuffer.PositionKind:
                case babylonjs_1.VertexBuffer.NormalKind: {
                    for (var x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {
                        index = x * stride;
                        vertexData.push(babylonjs_1.Vector3.FromArray(meshAttributeArray, index));
                    }
                    break;
                }
                case babylonjs_1.VertexBuffer.TangentKind: {
                    for (var x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {
                        index = x * stride;
                        vertexData.push(babylonjs_1.Vector4.FromArray(meshAttributeArray, index));
                    }
                    break;
                }
                case babylonjs_1.VertexBuffer.ColorKind: {
                    for (var x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {
                        index = x * stride;
                        vertexData.push(babylonjs_1.Vector4.FromArray(meshAttributeArray, index));
                        vertexBuffer.getSize() === 4 ? vertexData.push(babylonjs_1.Vector4.FromArray(meshAttributeArray, index)) : vertexData.push(babylonjs_1.Vector3.FromArray(meshAttributeArray, index));
                    }
                    break;
                }
                case babylonjs_1.VertexBuffer.UVKind:
                case babylonjs_1.VertexBuffer.UV2Kind: {
                    for (var x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {
                        index = x * stride;
                        vertexData.push(babylonjs_1.Vector2.FromArray(meshAttributeArray, index));
                    }
                    break;
                }
                default: {
                    babylonjs_1.Tools.Error("Unsupported Vertex Buffer type: " + vertexBufferKind);
                }
            }
            this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter);
        }
        else {
            babylonjs_1.Tools.Warn("reorderTriangleFanMode: Vertex buffer kind " + vertexBufferKind + " not present!");
        }
    };
    /**
     * Writes the vertex attribute data to binary
     * @param vertices The vertices to write to the binary writer
     * @param byteOffset The offset into the binary writer to overwrite binary data
     * @param vertexAttributeKind The vertex attribute type
     * @param meshAttributeArray The vertex attribute data
     * @param binaryWriter The writer containing the binary data
     */
    _Exporter.prototype.writeVertexAttributeData = function (vertices, byteOffset, vertexAttributeKind, meshAttributeArray, binaryWriter) {
        for (var _i = 0, vertices_1 = vertices; _i < vertices_1.length; _i++) {
            var vertex = vertices_1[_i];
            if (this._convertToRightHandedSystem && !(vertexAttributeKind === babylonjs_1.VertexBuffer.ColorKind) && !(vertex instanceof babylonjs_1.Vector2)) {
                if (vertex instanceof babylonjs_1.Vector3) {
                    if (vertexAttributeKind === babylonjs_1.VertexBuffer.NormalKind) {
                        glTFUtilities_1._GLTFUtilities._GetRightHandedNormalVector3FromRef(vertex);
                    }
                    else if (vertexAttributeKind === babylonjs_1.VertexBuffer.PositionKind) {
                        glTFUtilities_1._GLTFUtilities._GetRightHandedPositionVector3FromRef(vertex);
                    }
                    else {
                        babylonjs_1.Tools.Error('Unsupported vertex attribute kind!');
                    }
                }
                else {
                    glTFUtilities_1._GLTFUtilities._GetRightHandedVector4FromRef(vertex);
                }
            }
            if (vertexAttributeKind === babylonjs_1.VertexBuffer.NormalKind) {
                vertex.normalize();
            }
            else if (vertexAttributeKind === babylonjs_1.VertexBuffer.TangentKind && vertex instanceof babylonjs_1.Vector4) {
                glTFUtilities_1._GLTFUtilities._NormalizeTangentFromRef(vertex);
            }
            for (var _a = 0, _b = vertex.asArray(); _a < _b.length; _a++) {
                var component = _b[_a];
                binaryWriter.setFloat32(component, byteOffset);
                byteOffset += 4;
            }
        }
    };
    /**
     * Writes mesh attribute data to a data buffer
     * Returns the bytelength of the data
     * @param vertexBufferKind Indicates what kind of vertex data is being passed in
     * @param meshAttributeArray Array containing the attribute data
     * @param binaryWriter The buffer to write the binary data to
     * @param indices Used to specify the order of the vertex data
     */
    _Exporter.prototype.writeAttributeData = function (vertexBufferKind, meshAttributeArray, byteStride, binaryWriter) {
        var stride = byteStride / 4;
        var vertexAttributes = [];
        var index;
        switch (vertexBufferKind) {
            case babylonjs_1.VertexBuffer.PositionKind: {
                for (var k = 0, length_2 = meshAttributeArray.length / stride; k < length_2; ++k) {
                    index = k * stride;
                    var vertexData = babylonjs_1.Vector3.FromArray(meshAttributeArray, index);
                    if (this._convertToRightHandedSystem) {
                        glTFUtilities_1._GLTFUtilities._GetRightHandedPositionVector3FromRef(vertexData);
                    }
                    vertexAttributes.push(vertexData.asArray());
                }
                break;
            }
            case babylonjs_1.VertexBuffer.NormalKind: {
                for (var k = 0, length_3 = meshAttributeArray.length / stride; k < length_3; ++k) {
                    index = k * stride;
                    var vertexData = babylonjs_1.Vector3.FromArray(meshAttributeArray, index);
                    if (this._convertToRightHandedSystem) {
                        glTFUtilities_1._GLTFUtilities._GetRightHandedNormalVector3FromRef(vertexData);
                    }
                    vertexData.normalize();
                    vertexAttributes.push(vertexData.asArray());
                }
                break;
            }
            case babylonjs_1.VertexBuffer.TangentKind: {
                for (var k = 0, length_4 = meshAttributeArray.length / stride; k < length_4; ++k) {
                    index = k * stride;
                    var vertexData = babylonjs_1.Vector4.FromArray(meshAttributeArray, index);
                    if (this._convertToRightHandedSystem) {
                        glTFUtilities_1._GLTFUtilities._GetRightHandedVector4FromRef(vertexData);
                    }
                    glTFUtilities_1._GLTFUtilities._NormalizeTangentFromRef(vertexData);
                    vertexAttributes.push(vertexData.asArray());
                }
                break;
            }
            case babylonjs_1.VertexBuffer.ColorKind: {
                for (var k = 0, length_5 = meshAttributeArray.length / stride; k < length_5; ++k) {
                    index = k * stride;
                    var vertexData = stride === 3 ? babylonjs_1.Vector3.FromArray(meshAttributeArray, index) : babylonjs_1.Vector4.FromArray(meshAttributeArray, index);
                    vertexAttributes.push(vertexData.asArray());
                }
                break;
            }
            case babylonjs_1.VertexBuffer.UVKind:
            case babylonjs_1.VertexBuffer.UV2Kind: {
                for (var k = 0, length_6 = meshAttributeArray.length / stride; k < length_6; ++k) {
                    index = k * stride;
                    vertexAttributes.push(this._convertToRightHandedSystem ? [meshAttributeArray[index], meshAttributeArray[index + 1]] : [meshAttributeArray[index], meshAttributeArray[index + 1]]);
                }
                break;
            }
            default: {
                babylonjs_1.Tools.Warn("Unsupported Vertex Buffer Type: " + vertexBufferKind);
                vertexAttributes = [];
            }
        }
        for (var _i = 0, vertexAttributes_1 = vertexAttributes; _i < vertexAttributes_1.length; _i++) {
            var vertexAttribute = vertexAttributes_1[_i];
            for (var _a = 0, vertexAttribute_1 = vertexAttribute; _a < vertexAttribute_1.length; _a++) {
                var component = vertexAttribute_1[_a];
                binaryWriter.setFloat32(component);
            }
        }
    };
    /**
     * Generates glTF json data
     * @param shouldUseGlb Indicates whether the json should be written for a glb file
     * @param glTFPrefix Text to use when prefixing a glTF file
     * @param prettyPrint Indicates whether the json file should be pretty printed (true) or not (false)
     * @returns json data as string
     */
    _Exporter.prototype.generateJSON = function (shouldUseGlb, glTFPrefix, prettyPrint) {
        var _this = this;
        var buffer = { byteLength: this._totalByteLength };
        var imageName;
        var imageData;
        var bufferView;
        var byteOffset = this._totalByteLength;
        var glTF = {
            asset: this._asset
        };
        if (this._extensionsUsed && this._extensionsUsed.length) {
            glTF.extensionsUsed = this._extensionsUsed;
        }
        if (this._extensionsRequired && this._extensionsRequired.length) {
            glTF.extensionsRequired = this._extensionsRequired;
        }
        if (buffer.byteLength) {
            glTF.buffers = [buffer];
        }
        if (this._nodes && this._nodes.length) {
            glTF.nodes = this._nodes;
        }
        if (this._meshes && this._meshes.length) {
            glTF.meshes = this._meshes;
        }
        if (this._scenes && this._scenes.length) {
            glTF.scenes = this._scenes;
            glTF.scene = 0;
        }
        if (this._bufferViews && this._bufferViews.length) {
            glTF.bufferViews = this._bufferViews;
        }
        if (this._accessors && this._accessors.length) {
            glTF.accessors = this._accessors;
        }
        if (this._animations && this._animations.length) {
            glTF.animations = this._animations;
        }
        if (this._materials && this._materials.length) {
            glTF.materials = this._materials;
        }
        if (this._textures && this._textures.length) {
            glTF.textures = this._textures;
        }
        if (this._samplers && this._samplers.length) {
            glTF.samplers = this._samplers;
        }
        if (this._images && this._images.length) {
            if (!shouldUseGlb) {
                glTF.images = this._images;
            }
            else {
                glTF.images = [];
                this._images.forEach(function (image) {
                    if (image.uri) {
                        imageData = _this._imageData[image.uri];
                        imageName = image.uri.split('.')[0] + " image";
                        bufferView = glTFUtilities_1._GLTFUtilities._CreateBufferView(0, byteOffset, imageData.data.length, undefined, imageName);
                        byteOffset += imageData.data.buffer.byteLength;
                        _this._bufferViews.push(bufferView);
                        image.bufferView = _this._bufferViews.length - 1;
                        image.name = imageName;
                        image.mimeType = imageData.mimeType;
                        image.uri = undefined;
                        if (!glTF.images) {
                            glTF.images = [];
                        }
                        glTF.images.push(image);
                    }
                });
                // Replace uri with bufferview and mime type for glb
                buffer.byteLength = byteOffset;
            }
        }
        if (!shouldUseGlb) {
            buffer.uri = glTFPrefix + ".bin";
        }
        var jsonText = prettyPrint ? JSON.stringify(glTF, null, 2) : JSON.stringify(glTF);
        return jsonText;
    };
    /**
     * Generates data for .gltf and .bin files based on the glTF prefix string
     * @param glTFPrefix Text to use when prefixing a glTF file
     * @returns GLTFData with glTF file data
     */
    _Exporter.prototype._generateGLTFAsync = function (glTFPrefix) {
        var _this = this;
        return this._generateBinaryAsync().then(function (binaryBuffer) {
            var jsonText = _this.generateJSON(false, glTFPrefix, true);
            var bin = new Blob([binaryBuffer], { type: 'application/octet-stream' });
            var glTFFileName = glTFPrefix + '.gltf';
            var glTFBinFile = glTFPrefix + '.bin';
            var container = new glTFData_1.GLTFData();
            container.glTFFiles[glTFFileName] = jsonText;
            container.glTFFiles[glTFBinFile] = bin;
            if (_this._imageData) {
                for (var image in _this._imageData) {
                    container.glTFFiles[image] = new Blob([_this._imageData[image].data], { type: _this._imageData[image].mimeType });
                }
            }
            return container;
        });
    };
    /**
     * Creates a binary buffer for glTF
     * @returns array buffer for binary data
     */
    _Exporter.prototype._generateBinaryAsync = function () {
        var _this = this;
        var binaryWriter = new _BinaryWriter(4);
        return this.createSceneAsync(this._babylonScene, binaryWriter).then(function () {
            if (_this._localEngine) {
                _this._localEngine.dispose();
            }
            return binaryWriter.getArrayBuffer();
        });
    };
    /**
     * Pads the number to a multiple of 4
     * @param num number to pad
     * @returns padded number
     */
    _Exporter.prototype._getPadding = function (num) {
        var remainder = num % 4;
        var padding = remainder === 0 ? remainder : 4 - remainder;
        return padding;
    };
    /**
     * Generates a glb file from the json and binary data
     * Returns an object with the glb file name as the key and data as the value
     * @param glTFPrefix
     * @returns object with glb filename as key and data as value
     */
    _Exporter.prototype._generateGLBAsync = function (glTFPrefix) {
        var _this = this;
        return this._generateBinaryAsync().then(function (binaryBuffer) {
            var jsonText = _this.generateJSON(true);
            var glbFileName = glTFPrefix + '.glb';
            var headerLength = 12;
            var chunkLengthPrefix = 8;
            var jsonLength = jsonText.length;
            var imageByteLength = 0;
            for (var key in _this._imageData) {
                imageByteLength += _this._imageData[key].data.byteLength;
            }
            var jsonPadding = _this._getPadding(jsonLength);
            var binPadding = _this._getPadding(binaryBuffer.byteLength);
            var imagePadding = _this._getPadding(imageByteLength);
            var byteLength = headerLength + (2 * chunkLengthPrefix) + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding + imageByteLength + imagePadding;
            //header
            var headerBuffer = new ArrayBuffer(headerLength);
            var headerBufferView = new DataView(headerBuffer);
            headerBufferView.setUint32(0, 0x46546C67, true); //glTF
            headerBufferView.setUint32(4, 2, true); // version
            headerBufferView.setUint32(8, byteLength, true); // total bytes in file
            //json chunk
            var jsonChunkBuffer = new ArrayBuffer(chunkLengthPrefix + jsonLength + jsonPadding);
            var jsonChunkBufferView = new DataView(jsonChunkBuffer);
            jsonChunkBufferView.setUint32(0, jsonLength + jsonPadding, true);
            jsonChunkBufferView.setUint32(4, 0x4E4F534A, true);
            //json chunk bytes
            var jsonData = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix);
            for (var i = 0; i < jsonLength; ++i) {
                jsonData[i] = jsonText.charCodeAt(i);
            }
            //json padding
            var jsonPaddingView = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix + jsonLength);
            for (var i = 0; i < jsonPadding; ++i) {
                jsonPaddingView[i] = 0x20;
            }
            //binary chunk
            var binaryChunkBuffer = new ArrayBuffer(chunkLengthPrefix);
            var binaryChunkBufferView = new DataView(binaryChunkBuffer);
            binaryChunkBufferView.setUint32(0, binaryBuffer.byteLength + imageByteLength + imagePadding, true);
            binaryChunkBufferView.setUint32(4, 0x004E4942, true);
            // binary padding
            var binPaddingBuffer = new ArrayBuffer(binPadding);
            var binPaddingView = new Uint8Array(binPaddingBuffer);
            for (var i = 0; i < binPadding; ++i) {
                binPaddingView[i] = 0;
            }
            var imagePaddingBuffer = new ArrayBuffer(imagePadding);
            var imagePaddingView = new Uint8Array(imagePaddingBuffer);
            for (var i = 0; i < imagePadding; ++i) {
                imagePaddingView[i] = 0;
            }
            var glbData = [headerBuffer, jsonChunkBuffer, binaryChunkBuffer, binaryBuffer];
            // binary data
            for (var key in _this._imageData) {
                glbData.push(_this._imageData[key].data.buffer);
            }
            glbData.push(binPaddingBuffer);
            glbData.push(imagePaddingBuffer);
            var glbFile = new Blob(glbData, { type: 'application/octet-stream' });
            var container = new glTFData_1.GLTFData();
            container.glTFFiles[glbFileName] = glbFile;
            if (_this._localEngine != null) {
                _this._localEngine.dispose();
            }
            return container;
        });
    };
    /**
     * Sets the TRS for each node
     * @param node glTF Node for storing the transformation data
     * @param babylonTransformNode Babylon mesh used as the source for the transformation data
     */
    _Exporter.prototype.setNodeTransformation = function (node, babylonTransformNode) {
        if (!babylonTransformNode.getPivotPoint().equalsToFloats(0, 0, 0)) {
            BABYLON.Tools.Warn("Pivot points are not supported in the glTF serializer");
        }
        if (!babylonTransformNode.position.equalsToFloats(0, 0, 0)) {
            node.translation = this._convertToRightHandedSystem ? glTFUtilities_1._GLTFUtilities._GetRightHandedPositionVector3(babylonTransformNode.position).asArray() : babylonTransformNode.position.asArray();
        }
        if (!babylonTransformNode.scaling.equalsToFloats(1, 1, 1)) {
            node.scale = babylonTransformNode.scaling.asArray();
        }
        var rotationQuaternion = babylonjs_1.Quaternion.RotationYawPitchRoll(babylonTransformNode.rotation.y, babylonTransformNode.rotation.x, babylonTransformNode.rotation.z);
        if (babylonTransformNode.rotationQuaternion) {
            rotationQuaternion.multiplyInPlace(babylonTransformNode.rotationQuaternion);
        }
        if (!(rotationQuaternion.x === 0 && rotationQuaternion.y === 0 && rotationQuaternion.z === 0 && rotationQuaternion.w === 1)) {
            if (this._convertToRightHandedSystem) {
                glTFUtilities_1._GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);
            }
            node.rotation = rotationQuaternion.normalize().asArray();
        }
    };
    _Exporter.prototype.getVertexBufferFromMesh = function (attributeKind, bufferMesh) {
        if (bufferMesh.isVerticesDataPresent(attributeKind)) {
            var vertexBuffer = bufferMesh.getVertexBuffer(attributeKind);
            if (vertexBuffer) {
                return vertexBuffer;
            }
        }
        return null;
    };
    /**
     * Creates a bufferview based on the vertices type for the Babylon mesh
     * @param kind Indicates the type of vertices data
     * @param babylonTransformNode The Babylon mesh to get the vertices data from
     * @param binaryWriter The buffer to write the bufferview data to
     */
    _Exporter.prototype.createBufferViewKind = function (kind, babylonTransformNode, binaryWriter, byteStride) {
        var bufferMesh = babylonTransformNode instanceof babylonjs_1.Mesh ?
            babylonTransformNode : babylonTransformNode instanceof babylonjs_1.InstancedMesh ?
            babylonTransformNode.sourceMesh : null;
        if (bufferMesh) {
            var vertexData = bufferMesh.getVerticesData(kind);
            if (vertexData) {
                var byteLength = vertexData.length * 4;
                var bufferView = glTFUtilities_1._GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, kind + " - " + bufferMesh.name);
                this._bufferViews.push(bufferView);
                this.writeAttributeData(kind, vertexData, byteStride, binaryWriter);
            }
        }
    };
    /**
     * The primitive mode of the Babylon mesh
     * @param babylonMesh The BabylonJS mesh
     */
    _Exporter.prototype.getMeshPrimitiveMode = function (babylonMesh) {
        if (babylonMesh instanceof babylonjs_1.LinesMesh) {
            return babylonjs_1.Material.LineListDrawMode;
        }
        return babylonMesh.material ? babylonMesh.material.fillMode : babylonjs_1.Material.TriangleFillMode;
    };
    /**
     * Sets the primitive mode of the glTF mesh primitive
     * @param meshPrimitive glTF mesh primitive
     * @param primitiveMode The primitive mode
     */
    _Exporter.prototype.setPrimitiveMode = function (meshPrimitive, primitiveMode) {
        switch (primitiveMode) {
            case babylonjs_1.Material.TriangleFillMode: {
                // glTF defaults to using Triangle Mode
                break;
            }
            case babylonjs_1.Material.TriangleStripDrawMode: {
                meshPrimitive.mode = 5 /* TRIANGLE_STRIP */;
                break;
            }
            case babylonjs_1.Material.TriangleFanDrawMode: {
                meshPrimitive.mode = 6 /* TRIANGLE_FAN */;
                break;
            }
            case babylonjs_1.Material.PointListDrawMode: {
                meshPrimitive.mode = 0 /* POINTS */;
            }
            case babylonjs_1.Material.PointFillMode: {
                meshPrimitive.mode = 0 /* POINTS */;
                break;
            }
            case babylonjs_1.Material.LineLoopDrawMode: {
                meshPrimitive.mode = 2 /* LINE_LOOP */;
                break;
            }
            case babylonjs_1.Material.LineListDrawMode: {
                meshPrimitive.mode = 1 /* LINES */;
                break;
            }
            case babylonjs_1.Material.LineStripDrawMode: {
                meshPrimitive.mode = 3 /* LINE_STRIP */;
                break;
            }
        }
    };
    /**
     * Sets the vertex attribute accessor based of the glTF mesh primitive
     * @param meshPrimitive glTF mesh primitive
     * @param attributeKind vertex attribute
     * @returns boolean specifying if uv coordinates are present
     */
    _Exporter.prototype.setAttributeKind = function (meshPrimitive, attributeKind) {
        switch (attributeKind) {
            case babylonjs_1.VertexBuffer.PositionKind: {
                meshPrimitive.attributes.POSITION = this._accessors.length - 1;
                break;
            }
            case babylonjs_1.VertexBuffer.NormalKind: {
                meshPrimitive.attributes.NORMAL = this._accessors.length - 1;
                break;
            }
            case babylonjs_1.VertexBuffer.ColorKind: {
                meshPrimitive.attributes.COLOR_0 = this._accessors.length - 1;
                break;
            }
            case babylonjs_1.VertexBuffer.TangentKind: {
                meshPrimitive.attributes.TANGENT = this._accessors.length - 1;
                break;
            }
            case babylonjs_1.VertexBuffer.UVKind: {
                meshPrimitive.attributes.TEXCOORD_0 = this._accessors.length - 1;
                break;
            }
            case babylonjs_1.VertexBuffer.UV2Kind: {
                meshPrimitive.attributes.TEXCOORD_1 = this._accessors.length - 1;
                break;
            }
            default: {
                babylonjs_1.Tools.Warn("Unsupported Vertex Buffer Type: " + attributeKind);
            }
        }
    };
    /**
     * Sets data for the primitive attributes of each submesh
     * @param mesh glTF Mesh object to store the primitive attribute information
     * @param babylonTransformNode Babylon mesh to get the primitive attribute data from
     * @param binaryWriter Buffer to write the attribute data to
     */
    _Exporter.prototype.setPrimitiveAttributesAsync = function (mesh, babylonTransformNode, binaryWriter) {
        var promises = [];
        var bufferMesh = null;
        var bufferView;
        var uvCoordsPresent;
        var minMax;
        if (babylonTransformNode instanceof babylonjs_1.Mesh) {
            bufferMesh = babylonTransformNode;
        }
        else if (babylonTransformNode instanceof babylonjs_1.InstancedMesh) {
            bufferMesh = babylonTransformNode.sourceMesh;
        }
        var attributeData = [
            { kind: babylonjs_1.VertexBuffer.PositionKind, accessorType: "VEC3" /* VEC3 */, byteStride: 12 },
            { kind: babylonjs_1.VertexBuffer.NormalKind, accessorType: "VEC3" /* VEC3 */, byteStride: 12 },
            { kind: babylonjs_1.VertexBuffer.ColorKind, accessorType: "VEC4" /* VEC4 */, byteStride: 16 },
            { kind: babylonjs_1.VertexBuffer.TangentKind, accessorType: "VEC4" /* VEC4 */, byteStride: 16 },
            { kind: babylonjs_1.VertexBuffer.UVKind, accessorType: "VEC2" /* VEC2 */, byteStride: 8 },
            { kind: babylonjs_1.VertexBuffer.UV2Kind, accessorType: "VEC2" /* VEC2 */, byteStride: 8 },
        ];
        if (bufferMesh) {
            var indexBufferViewIndex = null;
            var primitiveMode = this.getMeshPrimitiveMode(bufferMesh);
            var vertexAttributeBufferViews = {};
            // For each BabylonMesh, create bufferviews for each 'kind'
            for (var _i = 0, attributeData_1 = attributeData; _i < attributeData_1.length; _i++) {
                var attribute = attributeData_1[_i];
                var attributeKind = attribute.kind;
                if (bufferMesh.isVerticesDataPresent(attributeKind)) {
                    var vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);
                    attribute.byteStride = vertexBuffer ? vertexBuffer.getSize() * 4 : babylonjs_1.VertexBuffer.DeduceStride(attributeKind) * 4;
                    if (attribute.byteStride === 12) {
                        attribute.accessorType = "VEC3" /* VEC3 */;
                    }
                    this.createBufferViewKind(attributeKind, babylonTransformNode, binaryWriter, attribute.byteStride);
                    attribute.bufferViewIndex = this._bufferViews.length - 1;
                    vertexAttributeBufferViews[attributeKind] = attribute.bufferViewIndex;
                }
            }
            if (bufferMesh.getTotalIndices()) {
                var indices = bufferMesh.getIndices();
                if (indices) {
                    var byteLength = indices.length * 4;
                    bufferView = glTFUtilities_1._GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, "Indices - " + bufferMesh.name);
                    this._bufferViews.push(bufferView);
                    indexBufferViewIndex = this._bufferViews.length - 1;
                    for (var k = 0, length_7 = indices.length; k < length_7; ++k) {
                        binaryWriter.setUInt32(indices[k]);
                    }
                }
            }
            if (bufferMesh.subMeshes) {
                // go through all mesh primitives (submeshes)
                for (var _a = 0, _b = bufferMesh.subMeshes; _a < _b.length; _a++) {
                    var submesh = _b[_a];
                    uvCoordsPresent = false;
                    var babylonMaterial = submesh.getMaterial() || bufferMesh.getScene().defaultMaterial;
                    var materialIndex = null;
                    if (babylonMaterial) {
                        if (bufferMesh instanceof babylonjs_1.LinesMesh) {
                            // get the color from the lines mesh and set it in the material
                            var material = {
                                name: bufferMesh.name + ' material'
                            };
                            if (!bufferMesh.color.equals(babylonjs_1.Color3.White()) || bufferMesh.alpha < 1) {
                                material.pbrMetallicRoughness = {
                                    baseColorFactor: bufferMesh.color.asArray().concat([bufferMesh.alpha])
                                };
                            }
                            this._materials.push(material);
                            materialIndex = this._materials.length - 1;
                        }
                        else if (babylonMaterial instanceof babylonjs_1.MultiMaterial) {
                            var subMaterial = babylonMaterial.subMaterials[submesh.materialIndex];
                            if (subMaterial) {
                                babylonMaterial = subMaterial;
                                materialIndex = this._materialMap[babylonMaterial.uniqueId];
                            }
                        }
                        else {
                            materialIndex = this._materialMap[babylonMaterial.uniqueId];
                        }
                    }
                    var glTFMaterial = materialIndex != null ? this._materials[materialIndex] : null;
                    var meshPrimitive = { attributes: {} };
                    this.setPrimitiveMode(meshPrimitive, primitiveMode);
                    for (var _c = 0, attributeData_2 = attributeData; _c < attributeData_2.length; _c++) {
                        var attribute = attributeData_2[_c];
                        var attributeKind = attribute.kind;
                        if (attributeKind === babylonjs_1.VertexBuffer.UVKind || attributeKind === babylonjs_1.VertexBuffer.UV2Kind) {
                            if (glTFMaterial && !this._glTFMaterialExporter._hasTexturesPresent(glTFMaterial)) {
                                continue;
                            }
                        }
                        var vertexData = bufferMesh.getVerticesData(attributeKind);
                        if (vertexData) {
                            var vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);
                            if (vertexBuffer) {
                                var stride = vertexBuffer.getSize();
                                var bufferViewIndex = attribute.bufferViewIndex;
                                if (bufferViewIndex != undefined) { // check to see if bufferviewindex has a numeric value assigned.
                                    minMax = { min: null, max: null };
                                    if (attributeKind == babylonjs_1.VertexBuffer.PositionKind) {
                                        minMax = glTFUtilities_1._GLTFUtilities._CalculateMinMaxPositions(vertexData, 0, vertexData.length / stride, this._convertToRightHandedSystem);
                                    }
                                    var accessor = glTFUtilities_1._GLTFUtilities._CreateAccessor(bufferViewIndex, attributeKind + " - " + babylonTransformNode.name, attribute.accessorType, 5126 /* FLOAT */, vertexData.length / stride, 0, minMax.min, minMax.max);
                                    this._accessors.push(accessor);
                                    this.setAttributeKind(meshPrimitive, attributeKind);
                                    if (meshPrimitive.attributes.TEXCOORD_0 != null || meshPrimitive.attributes.TEXCOORD_1 != null) {
                                        uvCoordsPresent = true;
                                    }
                                }
                            }
                        }
                    }
                    if (indexBufferViewIndex) {
                        // Create accessor
                        var accessor = glTFUtilities_1._GLTFUtilities._CreateAccessor(indexBufferViewIndex, "indices - " + babylonTransformNode.name, "SCALAR" /* SCALAR */, 5125 /* UNSIGNED_INT */, submesh.indexCount, submesh.indexStart * 4, null, null);
                        this._accessors.push(accessor);
                        meshPrimitive.indices = this._accessors.length - 1;
                    }
                    if (materialIndex != null && Object.keys(meshPrimitive.attributes).length > 0) {
                        var sideOrientation = babylonMaterial.sideOrientation;
                        if (this._convertToRightHandedSystem && sideOrientation === babylonjs_1.Material.ClockWiseSideOrientation) {
                            //Overwrite the indices to be counter-clockwise
                            var byteOffset = indexBufferViewIndex != null ? this._bufferViews[indexBufferViewIndex].byteOffset : null;
                            if (byteOffset == null) {
                                byteOffset = 0;
                            }
                            var babylonIndices = null;
                            if (indexBufferViewIndex != null) {
                                babylonIndices = bufferMesh.getIndices();
                            }
                            if (babylonIndices) {
                                this.reorderIndicesBasedOnPrimitiveMode(submesh, primitiveMode, babylonIndices, byteOffset, binaryWriter);
                            }
                            else {
                                for (var _d = 0, attributeData_3 = attributeData; _d < attributeData_3.length; _d++) {
                                    var attribute = attributeData_3[_d];
                                    var vertexData = bufferMesh.getVerticesData(attribute.kind);
                                    if (vertexData) {
                                        var byteOffset_1 = this._bufferViews[vertexAttributeBufferViews[attribute.kind]].byteOffset;
                                        if (!byteOffset_1) {
                                            byteOffset_1 = 0;
                                        }
                                        this.reorderVertexAttributeDataBasedOnPrimitiveMode(submesh, primitiveMode, sideOrientation, attribute.kind, vertexData, byteOffset_1, binaryWriter);
                                    }
                                }
                            }
                        }
                        if (!uvCoordsPresent && this._glTFMaterialExporter._hasTexturesPresent(this._materials[materialIndex])) {
                            var newMat = this._glTFMaterialExporter._stripTexturesFromMaterial(this._materials[materialIndex]);
                            this._materials.push(newMat);
                            materialIndex = this._materials.length - 1;
                        }
                        meshPrimitive.material = materialIndex;
                    }
                    mesh.primitives.push(meshPrimitive);
                    var promise = this._extensionsPostExportMeshPrimitiveAsync("postExport", meshPrimitive, submesh, binaryWriter);
                    if (promise) {
                        promises.push();
                    }
                }
            }
        }
        return Promise.all(promises).then(function () {
            /* do nothing */
        });
    };
    /**
     * Creates a glTF scene based on the array of meshes
     * Returns the the total byte offset
     * @param babylonScene Babylon scene to get the mesh data from
     * @param binaryWriter Buffer to write binary data to
     */
    _Exporter.prototype.createSceneAsync = function (babylonScene, binaryWriter) {
        var _this = this;
        var scene = { nodes: [] };
        var glTFNodeIndex;
        var glTFNode;
        var directDescendents;
        var nodes = babylonScene.transformNodes.concat(babylonScene.meshes);
        return this._glTFMaterialExporter._convertMaterialsToGLTFAsync(babylonScene.materials, "image/png" /* PNG */, true).then(function () {
            return _this.createNodeMapAndAnimationsAsync(babylonScene, nodes, _this._shouldExportTransformNode, binaryWriter).then(function (nodeMap) {
                _this._nodeMap = nodeMap;
                _this._totalByteLength = binaryWriter.getByteOffset();
                if (_this._totalByteLength == undefined) {
                    throw new Error("undefined byte length!");
                }
                // Build Hierarchy with the node map.
                for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                    var babylonTransformNode = nodes_1[_i];
                    glTFNodeIndex = _this._nodeMap[babylonTransformNode.uniqueId];
                    if (glTFNodeIndex != null) {
                        glTFNode = _this._nodes[glTFNodeIndex];
                        if (!babylonTransformNode.parent) {
                            if (!_this._shouldExportTransformNode(babylonTransformNode)) {
                                babylonjs_1.Tools.Log("Omitting " + babylonTransformNode.name + " from scene.");
                            }
                            else {
                                if (_this._convertToRightHandedSystem) {
                                    if (glTFNode.translation) {
                                        glTFNode.translation[2] *= -1;
                                        glTFNode.translation[0] *= -1;
                                    }
                                    glTFNode.rotation = glTFNode.rotation ? babylonjs_1.Quaternion.FromArray([0, 1, 0, 0]).multiply(babylonjs_1.Quaternion.FromArray(glTFNode.rotation)).asArray() : (babylonjs_1.Quaternion.FromArray([0, 1, 0, 0])).asArray();
                                }
                                scene.nodes.push(glTFNodeIndex);
                            }
                        }
                        directDescendents = babylonTransformNode.getDescendants(true);
                        if (!glTFNode.children && directDescendents && directDescendents.length) {
                            var children = [];
                            for (var _a = 0, directDescendents_1 = directDescendents; _a < directDescendents_1.length; _a++) {
                                var descendent = directDescendents_1[_a];
                                if (_this._nodeMap[descendent.uniqueId] != null) {
                                    children.push(_this._nodeMap[descendent.uniqueId]);
                                }
                            }
                            if (children.length) {
                                glTFNode.children = children;
                            }
                        }
                    }
                }
                if (scene.nodes.length) {
                    _this._scenes.push(scene);
                }
            });
        });
    };
    /**
     * Creates a mapping of Node unique id to node index and handles animations
     * @param babylonScene Babylon Scene
     * @param nodes Babylon transform nodes
     * @param shouldExportTransformNode Callback specifying if a transform node should be exported
     * @param binaryWriter Buffer to write binary data to
     * @returns Node mapping of unique id to index
     */
    _Exporter.prototype.createNodeMapAndAnimationsAsync = function (babylonScene, nodes, shouldExportTransformNode, binaryWriter) {
        var _this = this;
        var promiseChain = Promise.resolve();
        var nodeMap = {};
        var nodeIndex;
        var runtimeGLTFAnimation = {
            name: 'runtime animations',
            channels: [],
            samplers: []
        };
        var idleGLTFAnimations = [];
        var _loop_1 = function (babylonTransformNode) {
            if (shouldExportTransformNode(babylonTransformNode)) {
                promiseChain = promiseChain.then(function () {
                    return _this.createNodeAsync(babylonTransformNode, binaryWriter).then(function (node) {
                        var directDescendents = babylonTransformNode.getDescendants(true, function (node) { return (node instanceof babylonjs_1.TransformNode); });
                        if (directDescendents.length || node.mesh != null) {
                            _this._nodes.push(node);
                            nodeIndex = _this._nodes.length - 1;
                            nodeMap[babylonTransformNode.uniqueId] = nodeIndex;
                        }
                        if (!babylonScene.animationGroups.length && babylonTransformNode.animations.length) {
                            glTFAnimation_1._GLTFAnimation._CreateNodeAnimationFromTransformNodeAnimations(babylonTransformNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, _this._nodes, binaryWriter, _this._bufferViews, _this._accessors, _this._convertToRightHandedSystem, _this._animationSampleRate);
                        }
                    });
                });
            }
            else {
                "Excluding mesh " + babylonTransformNode.name;
            }
        };
        for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
            var babylonTransformNode = nodes_2[_i];
            _loop_1(babylonTransformNode);
        }
        return promiseChain.then(function () {
            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {
                _this._animations.push(runtimeGLTFAnimation);
            }
            idleGLTFAnimations.forEach(function (idleGLTFAnimation) {
                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {
                    _this._animations.push(idleGLTFAnimation);
                }
            });
            if (babylonScene.animationGroups.length) {
                glTFAnimation_1._GLTFAnimation._CreateNodeAnimationFromAnimationGroups(babylonScene, _this._animations, nodeMap, _this._nodes, binaryWriter, _this._bufferViews, _this._accessors, _this._convertToRightHandedSystem, _this._animationSampleRate);
            }
            return nodeMap;
        });
    };
    /**
     * Creates a glTF node from a Babylon mesh
     * @param babylonMesh Source Babylon mesh
     * @param binaryWriter Buffer for storing geometry data
     * @returns glTF node
     */
    _Exporter.prototype.createNodeAsync = function (babylonTransformNode, binaryWriter) {
        var _this = this;
        return Promise.resolve().then(function () {
            // create node to hold translation/rotation/scale and the mesh
            var node = {};
            // create mesh
            var mesh = { primitives: [] };
            if (babylonTransformNode.name) {
                node.name = babylonTransformNode.name;
            }
            // Set transformation
            _this.setNodeTransformation(node, babylonTransformNode);
            return _this.setPrimitiveAttributesAsync(mesh, babylonTransformNode, binaryWriter).then(function () {
                if (mesh.primitives.length) {
                    _this._meshes.push(mesh);
                    node.mesh = _this._meshes.length - 1;
                }
                return node;
            });
        });
    };
    _Exporter._ExtensionNames = new Array();
    _Exporter._ExtensionFactories = {};
    return _Exporter;
}());
exports._Exporter = _Exporter;
/**
 * @hidden
 *
 * Stores glTF binary data.  If the array buffer byte length is exceeded, it doubles in size dynamically
 */
var _BinaryWriter = /** @class */ (function () {
    /**
     * Initialize binary writer with an initial byte length
     * @param byteLength Initial byte length of the array buffer
     */
    function _BinaryWriter(byteLength) {
        this._arrayBuffer = new ArrayBuffer(byteLength);
        this._dataView = new DataView(this._arrayBuffer);
        this._byteOffset = 0;
    }
    /**
     * Resize the array buffer to the specified byte length
     * @param byteLength
     */
    _BinaryWriter.prototype.resizeBuffer = function (byteLength) {
        var newBuffer = new ArrayBuffer(byteLength);
        var oldUint8Array = new Uint8Array(this._arrayBuffer);
        var newUint8Array = new Uint8Array(newBuffer);
        for (var i = 0, length_8 = newUint8Array.byteLength; i < length_8; ++i) {
            newUint8Array[i] = oldUint8Array[i];
        }
        this._arrayBuffer = newBuffer;
        this._dataView = new DataView(this._arrayBuffer);
        return newBuffer;
    };
    /**
     * Get an array buffer with the length of the byte offset
     * @returns ArrayBuffer resized to the byte offset
     */
    _BinaryWriter.prototype.getArrayBuffer = function () {
        return this.resizeBuffer(this.getByteOffset());
    };
    /**
     * Get the byte offset of the array buffer
     * @returns byte offset
     */
    _BinaryWriter.prototype.getByteOffset = function () {
        if (this._byteOffset == undefined) {
            throw new Error("Byte offset is undefined!");
        }
        return this._byteOffset;
    };
    /**
     * Stores an UInt8 in the array buffer
     * @param entry
     * @param byteOffset If defined, specifies where to set the value as an offset.
     */
    _BinaryWriter.prototype.setUInt8 = function (entry, byteOffset) {
        if (byteOffset != null) {
            if (byteOffset < this._byteOffset) {
                this._dataView.setUint8(byteOffset, entry);
            }
            else {
                babylonjs_1.Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');
            }
        }
        else {
            if (this._byteOffset + 1 > this._arrayBuffer.byteLength) {
                this.resizeBuffer(this._arrayBuffer.byteLength * 2);
            }
            this._dataView.setUint8(this._byteOffset++, entry);
        }
    };
    /**
     * Gets an UInt32 in the array buffer
     * @param entry
     * @param byteOffset If defined, specifies where to set the value as an offset.
     */
    _BinaryWriter.prototype.getUInt32 = function (byteOffset) {
        if (byteOffset < this._byteOffset) {
            return this._dataView.getUint32(byteOffset, true);
        }
        else {
            babylonjs_1.Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');
            throw new Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');
        }
    };
    _BinaryWriter.prototype.getVector3Float32FromRef = function (vector3, byteOffset) {
        if (byteOffset + 8 > this._byteOffset) {
            babylonjs_1.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!");
        }
        else {
            vector3.x = this._dataView.getFloat32(byteOffset, true);
            vector3.y = this._dataView.getFloat32(byteOffset + 4, true);
            vector3.z = this._dataView.getFloat32(byteOffset + 8, true);
        }
    };
    _BinaryWriter.prototype.setVector3Float32FromRef = function (vector3, byteOffset) {
        if (byteOffset + 8 > this._byteOffset) {
            babylonjs_1.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!");
        }
        else {
            this._dataView.setFloat32(byteOffset, vector3.x, true);
            this._dataView.setFloat32(byteOffset + 4, vector3.y, true);
            this._dataView.setFloat32(byteOffset + 8, vector3.z, true);
        }
    };
    _BinaryWriter.prototype.getVector4Float32FromRef = function (vector4, byteOffset) {
        if (byteOffset + 12 > this._byteOffset) {
            babylonjs_1.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!");
        }
        else {
            vector4.x = this._dataView.getFloat32(byteOffset, true);
            vector4.y = this._dataView.getFloat32(byteOffset + 4, true);
            vector4.z = this._dataView.getFloat32(byteOffset + 8, true);
            vector4.w = this._dataView.getFloat32(byteOffset + 12, true);
        }
    };
    _BinaryWriter.prototype.setVector4Float32FromRef = function (vector4, byteOffset) {
        if (byteOffset + 12 > this._byteOffset) {
            babylonjs_1.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!");
        }
        else {
            this._dataView.setFloat32(byteOffset, vector4.x, true);
            this._dataView.setFloat32(byteOffset + 4, vector4.y, true);
            this._dataView.setFloat32(byteOffset + 8, vector4.z, true);
            this._dataView.setFloat32(byteOffset + 12, vector4.w, true);
        }
    };
    /**
     * Stores a Float32 in the array buffer
     * @param entry
     */
    _BinaryWriter.prototype.setFloat32 = function (entry, byteOffset) {
        if (isNaN(entry)) {
            babylonjs_1.Tools.Error('Invalid data being written!');
        }
        if (byteOffset != null) {
            if (byteOffset < this._byteOffset) {
                this._dataView.setFloat32(byteOffset, entry, true);
            }
            else {
                babylonjs_1.Tools.Error('BinaryWriter: byteoffset is greater than the current binary length!');
            }
        }
        if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {
            this.resizeBuffer(this._arrayBuffer.byteLength * 2);
        }
        this._dataView.setFloat32(this._byteOffset, entry, true);
        this._byteOffset += 4;
    };
    /**
     * Stores an UInt32 in the array buffer
     * @param entry
     * @param byteOffset If defined, specifies where to set the value as an offset.
     */
    _BinaryWriter.prototype.setUInt32 = function (entry, byteOffset) {
        if (byteOffset != null) {
            if (byteOffset < this._byteOffset) {
                this._dataView.setUint32(byteOffset, entry, true);
            }
            else {
                babylonjs_1.Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');
            }
        }
        else {
            if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {
                this.resizeBuffer(this._arrayBuffer.byteLength * 2);
            }
            this._dataView.setUint32(this._byteOffset, entry, true);
            this._byteOffset += 4;
        }
    };
    return _BinaryWriter;
}());
exports._BinaryWriter = _BinaryWriter;


/***/ }),

/***/ "./src/glTF/2.0/glTFExporterExtension.ts":
/*!***********************************************!*\
  !*** ./src/glTF/2.0/glTFExporterExtension.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @hidden */
exports.__IGLTFExporterExtensionV2 = 0; // I am here to allow dts to be created


/***/ }),

/***/ "./src/glTF/2.0/glTFMaterialExporter.ts":
/*!**********************************************!*\
  !*** ./src/glTF/2.0/glTFMaterialExporter.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var babylonjs_1 = __webpack_require__(/*! babylonjs */ "babylonjs");
/**
 * Utility methods for working with glTF material conversion properties.  This class should only be used internally
 * @hidden
 */
var _GLTFMaterialExporter = /** @class */ (function () {
    function _GLTFMaterialExporter(exporter) {
        /**
         * Mapping to store textures
         */
        this._textureMap = {};
        this._textureMap = {};
        this._exporter = exporter;
    }
    /**
     * Specifies if two colors are approximately equal in value
     * @param color1 first color to compare to
     * @param color2 second color to compare to
     * @param epsilon threshold value
     */
    _GLTFMaterialExporter.FuzzyEquals = function (color1, color2, epsilon) {
        return babylonjs_1.Scalar.WithinEpsilon(color1.r, color2.r, epsilon) &&
            babylonjs_1.Scalar.WithinEpsilon(color1.g, color2.g, epsilon) &&
            babylonjs_1.Scalar.WithinEpsilon(color1.b, color2.b, epsilon);
    };
    /**
     * Gets the materials from a Babylon scene and converts them to glTF materials
     * @param scene babylonjs scene
     * @param mimeType texture mime type
     * @param images array of images
     * @param textures array of textures
     * @param materials array of materials
     * @param imageData mapping of texture names to base64 textures
     * @param hasTextureCoords specifies if texture coordinates are present on the material
     */
    _GLTFMaterialExporter.prototype._convertMaterialsToGLTFAsync = function (babylonMaterials, mimeType, hasTextureCoords) {
        var promises = [];
        for (var _i = 0, babylonMaterials_1 = babylonMaterials; _i < babylonMaterials_1.length; _i++) {
            var babylonMaterial = babylonMaterials_1[_i];
            if (babylonMaterial instanceof babylonjs_1.StandardMaterial) {
                promises.push(this._convertStandardMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));
            }
            else if (babylonMaterial instanceof babylonjs_1.PBRMetallicRoughnessMaterial) {
                promises.push(this._convertPBRMetallicRoughnessMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));
            }
            else if (babylonMaterial instanceof babylonjs_1.PBRMaterial) {
                promises.push(this._convertPBRMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));
            }
            else {
                babylonjs_1.Tools.Warn("Unsupported material type: " + babylonMaterial.name);
            }
        }
        return Promise.all(promises).then(function () { });
    };
    /**
     * Makes a copy of the glTF material without the texture parameters
     * @param originalMaterial original glTF material
     * @returns glTF material without texture parameters
     */
    _GLTFMaterialExporter.prototype._stripTexturesFromMaterial = function (originalMaterial) {
        var newMaterial = {};
        if (originalMaterial) {
            newMaterial.name = originalMaterial.name;
            newMaterial.doubleSided = originalMaterial.doubleSided;
            newMaterial.alphaMode = originalMaterial.alphaMode;
            newMaterial.alphaCutoff = originalMaterial.alphaCutoff;
            newMaterial.emissiveFactor = originalMaterial.emissiveFactor;
            var originalPBRMetallicRoughness = originalMaterial.pbrMetallicRoughness;
            if (originalPBRMetallicRoughness) {
                newMaterial.pbrMetallicRoughness = {};
                newMaterial.pbrMetallicRoughness.baseColorFactor = originalPBRMetallicRoughness.baseColorFactor;
                newMaterial.pbrMetallicRoughness.metallicFactor = originalPBRMetallicRoughness.metallicFactor;
                newMaterial.pbrMetallicRoughness.roughnessFactor = originalPBRMetallicRoughness.roughnessFactor;
            }
        }
        return newMaterial;
    };
    /**
     * Specifies if the material has any texture parameters present
     * @param material glTF Material
     * @returns boolean specifying if texture parameters are present
     */
    _GLTFMaterialExporter.prototype._hasTexturesPresent = function (material) {
        if (material.emissiveTexture || material.normalTexture || material.occlusionTexture) {
            return true;
        }
        var pbrMat = material.pbrMetallicRoughness;
        if (pbrMat) {
            if (pbrMat.baseColorTexture || pbrMat.metallicRoughnessTexture) {
                return true;
            }
        }
        return false;
    };
    /**
     * Converts a Babylon StandardMaterial to a glTF Metallic Roughness Material
     * @param babylonStandardMaterial
     * @returns glTF Metallic Roughness Material representation
     */
    _GLTFMaterialExporter.prototype._convertToGLTFPBRMetallicRoughness = function (babylonStandardMaterial) {
        var P0 = new BABYLON.Vector2(0, 1);
        var P1 = new BABYLON.Vector2(0, 0.1);
        var P2 = new BABYLON.Vector2(0, 0.1);
        var P3 = new BABYLON.Vector2(1300, 0.1);
        /**
         * Given the control points, solve for x based on a given t for a cubic bezier curve
         * @param t a value between 0 and 1
         * @param p0 first control point
         * @param p1 second control point
         * @param p2 third control point
         * @param p3 fourth control point
         * @returns number result of cubic bezier curve at the specified t
         */
        function _cubicBezierCurve(t, p0, p1, p2, p3) {
            return ((1 - t) * (1 - t) * (1 - t) * p0 +
                3 * (1 - t) * (1 - t) * t * p1 +
                3 * (1 - t) * t * t * p2 +
                t * t * t * p3);
        }
        /**
         * Evaluates a specified specular power value to determine the appropriate roughness value,
         * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)
         * and roughness on the ordinant axis (y-axis)
         * @param specularPower specular power of standard material
         * @returns Number representing the roughness value
         */
        function _solveForRoughness(specularPower) {
            var t = Math.pow(specularPower / P3.x, 0.333333);
            return _cubicBezierCurve(t, P0.y, P1.y, P2.y, P3.y);
        }
        var diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace().scale(0.5);
        var opacity = babylonStandardMaterial.alpha;
        var specularPower = babylonjs_1.Scalar.Clamp(babylonStandardMaterial.specularPower, 0, _GLTFMaterialExporter._MaxSpecularPower);
        var roughness = _solveForRoughness(specularPower);
        var glTFPbrMetallicRoughness = {
            baseColorFactor: [
                diffuse.r,
                diffuse.g,
                diffuse.b,
                opacity
            ],
            metallicFactor: 0,
            roughnessFactor: roughness,
        };
        return glTFPbrMetallicRoughness;
    };
    /**
     * Computes the metallic factor
     * @param diffuse diffused value
     * @param specular specular value
     * @param oneMinusSpecularStrength one minus the specular strength
     * @returns metallic value
     */
    _GLTFMaterialExporter._SolveMetallic = function (diffuse, specular, oneMinusSpecularStrength) {
        if (specular < this._DielectricSpecular.r) {
            this._DielectricSpecular;
            return 0;
        }
        var a = this._DielectricSpecular.r;
        var b = diffuse * oneMinusSpecularStrength / (1.0 - this._DielectricSpecular.r) + specular - 2.0 * this._DielectricSpecular.r;
        var c = this._DielectricSpecular.r - specular;
        var D = b * b - 4.0 * a * c;
        return BABYLON.Scalar.Clamp((-b + Math.sqrt(D)) / (2.0 * a), 0, 1);
    };
    /**
     * Gets the glTF alpha mode from the Babylon Material
     * @param babylonMaterial Babylon Material
     * @returns The Babylon alpha mode value
     */
    _GLTFMaterialExporter.prototype._getAlphaMode = function (babylonMaterial) {
        if (babylonMaterial.needAlphaBlending()) {
            return "BLEND" /* BLEND */;
        }
        else if (babylonMaterial.needAlphaTesting()) {
            return "MASK" /* MASK */;
        }
        else {
            return "OPAQUE" /* OPAQUE */;
        }
    };
    /**
     * Converts a Babylon Standard Material to a glTF Material
     * @param babylonStandardMaterial BJS Standard Material
     * @param mimeType mime type to use for the textures
     * @param images array of glTF image interfaces
     * @param textures array of glTF texture interfaces
     * @param materials array of glTF material interfaces
     * @param imageData map of image file name to data
     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied
     */
    _GLTFMaterialExporter.prototype._convertStandardMaterialAsync = function (babylonStandardMaterial, mimeType, hasTextureCoords) {
        var materialMap = this._exporter._materialMap;
        var materials = this._exporter._materials;
        var alphaMode = this._getAlphaMode(babylonStandardMaterial);
        var promises = [];
        var glTFPbrMetallicRoughness = this._convertToGLTFPBRMetallicRoughness(babylonStandardMaterial);
        var glTFMaterial = { name: babylonStandardMaterial.name };
        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {
            if (!babylonStandardMaterial.twoSidedLighting) {
                babylonjs_1.Tools.Warn(babylonStandardMaterial.name + ": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.");
            }
            glTFMaterial.doubleSided = true;
        }
        if (hasTextureCoords) {
            if (babylonStandardMaterial.diffuseTexture) {
                promises.push(this._exportTextureAsync(babylonStandardMaterial.diffuseTexture, mimeType).then(function (glTFTexture) {
                    if (glTFTexture) {
                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;
                    }
                }));
            }
            if (babylonStandardMaterial.bumpTexture) {
                promises.push(this._exportTextureAsync(babylonStandardMaterial.bumpTexture, mimeType).then(function (glTFTexture) {
                    if (glTFTexture) {
                        glTFMaterial.normalTexture = glTFTexture;
                        if (babylonStandardMaterial.bumpTexture != null && babylonStandardMaterial.bumpTexture.level !== 1) {
                            glTFMaterial.normalTexture.scale = babylonStandardMaterial.bumpTexture.level;
                        }
                    }
                }));
            }
            if (babylonStandardMaterial.emissiveTexture) {
                glTFMaterial.emissiveFactor = [1.0, 1.0, 1.0];
                promises.push(this._exportTextureAsync(babylonStandardMaterial.emissiveTexture, mimeType).then(function (glTFEmissiveTexture) {
                    if (glTFEmissiveTexture) {
                        glTFMaterial.emissiveTexture = glTFEmissiveTexture;
                    }
                }));
            }
            if (babylonStandardMaterial.ambientTexture) {
                promises.push(this._exportTextureAsync(babylonStandardMaterial.ambientTexture, mimeType).then(function (glTFTexture) {
                    if (glTFTexture) {
                        var occlusionTexture = {
                            index: glTFTexture.index
                        };
                        glTFMaterial.occlusionTexture = occlusionTexture;
                        occlusionTexture.strength = 1.0;
                    }
                }));
            }
        }
        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {
            if (babylonStandardMaterial.alphaMode === babylonjs_1.Engine.ALPHA_COMBINE) {
                glTFMaterial.alphaMode = "BLEND" /* BLEND */;
            }
            else {
                babylonjs_1.Tools.Warn(babylonStandardMaterial.name + ": glTF 2.0 does not support alpha mode: " + babylonStandardMaterial.alphaMode.toString());
            }
        }
        if (babylonStandardMaterial.emissiveColor && !_GLTFMaterialExporter.FuzzyEquals(babylonStandardMaterial.emissiveColor, babylonjs_1.Color3.Black(), _GLTFMaterialExporter._Epsilon)) {
            glTFMaterial.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();
        }
        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;
        if (alphaMode !== "OPAQUE" /* OPAQUE */) {
            switch (alphaMode) {
                case "BLEND" /* BLEND */: {
                    glTFMaterial.alphaMode = "BLEND" /* BLEND */;
                    break;
                }
                case "MASK" /* MASK */: {
                    glTFMaterial.alphaMode = "MASK" /* MASK */;
                    glTFMaterial.alphaCutoff = babylonStandardMaterial.alphaCutOff;
                    break;
                }
                default: {
                    babylonjs_1.Tools.Warn("Unsupported alpha mode " + alphaMode);
                }
            }
        }
        materials.push(glTFMaterial);
        materialMap[babylonStandardMaterial.uniqueId] = materials.length - 1;
        return Promise.all(promises).then(function () { });
    };
    /**
     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material
     * @param babylonPBRMetalRoughMaterial BJS PBR Metallic Roughness Material
     * @param mimeType mime type to use for the textures
     * @param images array of glTF image interfaces
     * @param textures array of glTF texture interfaces
     * @param materials array of glTF material interfaces
     * @param imageData map of image file name to data
     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied
     */
    _GLTFMaterialExporter.prototype._convertPBRMetallicRoughnessMaterialAsync = function (babylonPBRMetalRoughMaterial, mimeType, hasTextureCoords) {
        var materialMap = this._exporter._materialMap;
        var materials = this._exporter._materials;
        var promises = [];
        var glTFPbrMetallicRoughness = {};
        if (babylonPBRMetalRoughMaterial.baseColor) {
            glTFPbrMetallicRoughness.baseColorFactor = [
                babylonPBRMetalRoughMaterial.baseColor.r,
                babylonPBRMetalRoughMaterial.baseColor.g,
                babylonPBRMetalRoughMaterial.baseColor.b,
                babylonPBRMetalRoughMaterial.alpha
            ];
        }
        if (babylonPBRMetalRoughMaterial.metallic != null && babylonPBRMetalRoughMaterial.metallic !== 1) {
            glTFPbrMetallicRoughness.metallicFactor = babylonPBRMetalRoughMaterial.metallic;
        }
        if (babylonPBRMetalRoughMaterial.roughness != null && babylonPBRMetalRoughMaterial.roughness !== 1) {
            glTFPbrMetallicRoughness.roughnessFactor = babylonPBRMetalRoughMaterial.roughness;
        }
        var glTFMaterial = {
            name: babylonPBRMetalRoughMaterial.name
        };
        if (babylonPBRMetalRoughMaterial.doubleSided) {
            glTFMaterial.doubleSided = babylonPBRMetalRoughMaterial.doubleSided;
        }
        var alphaMode = null;
        if (babylonPBRMetalRoughMaterial.transparencyMode != null) {
            alphaMode = this._getAlphaMode(babylonPBRMetalRoughMaterial);
            if (alphaMode) {
                if (alphaMode !== "OPAQUE" /* OPAQUE */) { //glTF defaults to opaque
                    glTFMaterial.alphaMode = alphaMode;
                    if (alphaMode === "MASK" /* MASK */) {
                        glTFMaterial.alphaCutoff = babylonPBRMetalRoughMaterial.alphaCutOff;
                    }
                }
            }
        }
        if (hasTextureCoords) {
            if (babylonPBRMetalRoughMaterial.baseTexture != null) {
                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.baseTexture, mimeType).then(function (glTFTexture) {
                    if (glTFTexture) {
                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;
                    }
                }));
            }
            if (babylonPBRMetalRoughMaterial.normalTexture) {
                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.normalTexture, mimeType).then(function (glTFTexture) {
                    if (glTFTexture) {
                        glTFMaterial.normalTexture = glTFTexture;
                        if (babylonPBRMetalRoughMaterial.normalTexture.level !== 1) {
                            glTFMaterial.normalTexture.scale = babylonPBRMetalRoughMaterial.normalTexture.level;
                        }
                    }
                }));
            }
            if (babylonPBRMetalRoughMaterial.occlusionTexture) {
                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.occlusionTexture, mimeType).then(function (glTFTexture) {
                    if (glTFTexture) {
                        glTFMaterial.occlusionTexture = glTFTexture;
                        if (babylonPBRMetalRoughMaterial.occlusionStrength != null) {
                            glTFMaterial.occlusionTexture.strength = babylonPBRMetalRoughMaterial.occlusionStrength;
                        }
                    }
                }));
            }
            if (babylonPBRMetalRoughMaterial.emissiveTexture) {
                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.emissiveTexture, mimeType).then(function (glTFTexture) {
                    if (glTFTexture) {
                        glTFMaterial.emissiveTexture = glTFTexture;
                    }
                }));
            }
        }
        if (_GLTFMaterialExporter.FuzzyEquals(babylonPBRMetalRoughMaterial.emissiveColor, babylonjs_1.Color3.Black(), _GLTFMaterialExporter._Epsilon)) {
            glTFMaterial.emissiveFactor = babylonPBRMetalRoughMaterial.emissiveColor.asArray();
        }
        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;
        materials.push(glTFMaterial);
        materialMap[babylonPBRMetalRoughMaterial.uniqueId] = materials.length - 1;
        return Promise.all(promises).then(function () { });
    };
    /**
     * Converts an image typed array buffer to a base64 image
     * @param buffer typed array buffer
     * @param width width of the image
     * @param height height of the image
     * @param mimeType mimetype of the image
     * @returns base64 image string
     */
    _GLTFMaterialExporter.prototype._createBase64FromCanvasAsync = function (buffer, width, height, mimeType) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var hostingScene;
            var textureType = babylonjs_1.Engine.TEXTURETYPE_UNSIGNED_INT;
            var engine = _this._exporter._getLocalEngine();
            hostingScene = new babylonjs_1.Scene(engine);
            // Create a temporary texture with the texture buffer data
            var tempTexture = engine.createRawTexture(buffer, width, height, babylonjs_1.Engine.TEXTUREFORMAT_RGBA, false, true, babylonjs_1.Texture.NEAREST_SAMPLINGMODE, null, textureType);
            var postProcess = new babylonjs_1.PostProcess("pass", "pass", null, null, 1, null, babylonjs_1.Texture.NEAREST_SAMPLINGMODE, engine, false, undefined, babylonjs_1.Engine.TEXTURETYPE_UNSIGNED_INT, undefined, null, false);
            postProcess.getEffect().executeWhenCompiled(function () {
                postProcess.onApply = function (effect) {
                    effect._bindTexture("textureSampler", tempTexture);
                };
                // Set the size of the texture
                engine.setSize(width, height);
                hostingScene.postProcessManager.directRender([postProcess], null);
                postProcess.dispose();
                tempTexture.dispose();
                // Read data from WebGL
                var canvas = engine.getRenderingCanvas();
                if (canvas) {
                    if (!canvas.toBlob) { // fallback for browsers without "canvas.toBlob"
                        var dataURL = canvas.toDataURL();
                        resolve(dataURL);
                    }
                    else {
                        BABYLON.Tools.ToBlob(canvas, function (blob) {
                            if (blob) {
                                var fileReader = new FileReader();
                                fileReader.onload = function (event) {
                                    var base64String = event.target.result;
                                    hostingScene.dispose();
                                    resolve(base64String);
                                };
                                fileReader.readAsDataURL(blob);
                            }
                            else {
                                reject("gltfMaterialExporter: Failed to get blob from image canvas!");
                            }
                        });
                    }
                }
                else {
                    reject("Engine is missing a canvas!");
                }
            });
        });
    };
    /**
     * Generates a white texture based on the specified width and height
     * @param width width of the texture in pixels
     * @param height height of the texture in pixels
     * @param scene babylonjs scene
     * @returns white texture
     */
    _GLTFMaterialExporter.prototype._createWhiteTexture = function (width, height, scene) {
        var data = new Uint8Array(width * height * 4);
        for (var i = 0; i < data.length; i = i + 4) {
            data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xFF;
        }
        var rawTexture = babylonjs_1.RawTexture.CreateRGBATexture(data, width, height, scene);
        return rawTexture;
    };
    /**
     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null
     * @param texture1 first texture to resize
     * @param texture2 second texture to resize
     * @param scene babylonjs scene
     * @returns resized textures or null
     */
    _GLTFMaterialExporter.prototype._resizeTexturesToSameDimensions = function (texture1, texture2, scene) {
        var texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };
        var texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };
        var resizedTexture1;
        var resizedTexture2;
        if (texture1Size.width < texture2Size.width) {
            if (texture1 && texture1 instanceof babylonjs_1.Texture) {
                resizedTexture1 = babylonjs_1.TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);
            }
            else {
                resizedTexture1 = this._createWhiteTexture(texture2Size.width, texture2Size.height, scene);
            }
            resizedTexture2 = texture2;
        }
        else if (texture1Size.width > texture2Size.width) {
            if (texture2 && texture2 instanceof babylonjs_1.Texture) {
                resizedTexture2 = babylonjs_1.TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);
            }
            else {
                resizedTexture2 = this._createWhiteTexture(texture1Size.width, texture1Size.height, scene);
            }
            resizedTexture1 = texture1;
        }
        else {
            resizedTexture1 = texture1;
            resizedTexture2 = texture2;
        }
        return {
            "texture1": resizedTexture1,
            "texture2": resizedTexture2
        };
    };
    /**
     * Converts an array of pixels to a Float32Array
     * Throws an error if the pixel format is not supported
     * @param pixels - array buffer containing pixel values
     * @returns Float32 of pixels
     */
    _GLTFMaterialExporter.prototype._convertPixelArrayToFloat32 = function (pixels) {
        if (pixels instanceof Uint8Array) {
            var length_1 = pixels.length;
            var buffer = new Float32Array(pixels.length);
            for (var i = 0; i < length_1; ++i) {
                buffer[i] = pixels[i] / 255;
            }
            return buffer;
        }
        else if (pixels instanceof Float32Array) {
            return pixels;
        }
        else {
            throw new Error('Unsupported pixel format!');
        }
    };
    /**
     * Convert Specular Glossiness Textures to Metallic Roughness
     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness
     * @link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js
     * @param diffuseTexture texture used to store diffuse information
     * @param specularGlossinessTexture texture used to store specular and glossiness information
     * @param factors specular glossiness material factors
     * @param mimeType the mime type to use for the texture
     * @returns pbr metallic roughness interface or null
     */
    _GLTFMaterialExporter.prototype._convertSpecularGlossinessTexturesToMetallicRoughnessAsync = function (diffuseTexture, specularGlossinessTexture, factors, mimeType) {
        var promises = [];
        if (!(diffuseTexture || specularGlossinessTexture)) {
            return Promise.reject('_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!');
        }
        var scene = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;
        if (scene) {
            var resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);
            var diffuseSize = resizedTextures.texture1.getSize();
            var diffuseBuffer = void 0;
            var specularGlossinessBuffer = void 0;
            var width = diffuseSize.width;
            var height = diffuseSize.height;
            var diffusePixels = resizedTextures.texture1.readPixels();
            var specularPixels = resizedTextures.texture2.readPixels();
            if (diffusePixels) {
                diffuseBuffer = this._convertPixelArrayToFloat32(diffusePixels);
            }
            else {
                return Promise.reject("Failed to retrieve pixels from diffuse texture!");
            }
            if (specularPixels) {
                specularGlossinessBuffer = this._convertPixelArrayToFloat32(specularPixels);
            }
            else {
                return Promise.reject("Failed to retrieve pixels from specular glossiness texture!");
            }
            var byteLength = specularGlossinessBuffer.byteLength;
            var metallicRoughnessBuffer = new Uint8Array(byteLength);
            var baseColorBuffer = new Uint8Array(byteLength);
            var strideSize = 4;
            var maxBaseColor = babylonjs_1.Color3.Black();
            var maxMetallic = 0;
            var maxRoughness = 0;
            for (var h = 0; h < height; ++h) {
                for (var w = 0; w < width; ++w) {
                    var offset = (width * h + w) * strideSize;
                    var diffuseColor = new babylonjs_1.Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2]).toLinearSpace().multiply(factors.diffuseColor);
                    var specularColor = new babylonjs_1.Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2]).toLinearSpace().multiply(factors.specularColor);
                    var glossiness = (specularGlossinessBuffer[offset + 3]) * factors.glossiness;
                    var specularGlossiness = {
                        diffuseColor: diffuseColor,
                        specularColor: specularColor,
                        glossiness: glossiness
                    };
                    var metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);
                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);
                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);
                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);
                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic);
                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness);
                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;
                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;
                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;
                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;
                    metallicRoughnessBuffer[offset] = 0;
                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness * 255;
                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic * 255;
                    metallicRoughnessBuffer[offset + 3] = 255;
                }
            }
            // Retrieves the metallic roughness factors from the maximum texture values.
            var metallicRoughnessFactors_1 = {
                baseColor: maxBaseColor,
                metallic: maxMetallic,
                roughness: maxRoughness
            };
            var writeOutMetallicRoughnessTexture = false;
            var writeOutBaseColorTexture = false;
            for (var h = 0; h < height; ++h) {
                for (var w = 0; w < width; ++w) {
                    var destinationOffset = (width * h + w) * strideSize;
                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors_1.baseColor.r > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors_1.baseColor.r : 1;
                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors_1.baseColor.g > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors_1.baseColor.g : 1;
                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors_1.baseColor.b > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors_1.baseColor.b : 1;
                    var linearBaseColorPixel = babylonjs_1.Color3.FromInts(baseColorBuffer[destinationOffset], baseColorBuffer[destinationOffset + 1], baseColorBuffer[destinationOffset + 2]);
                    var sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace();
                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;
                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;
                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;
                    if (!_GLTFMaterialExporter.FuzzyEquals(sRGBBaseColorPixel, babylonjs_1.Color3.White(), _GLTFMaterialExporter._Epsilon)) {
                        writeOutBaseColorTexture = true;
                    }
                    metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors_1.roughness > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors_1.roughness : 1;
                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors_1.metallic > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors_1.metallic : 1;
                    var metallicRoughnessPixel = babylonjs_1.Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);
                    if (!_GLTFMaterialExporter.FuzzyEquals(metallicRoughnessPixel, babylonjs_1.Color3.White(), _GLTFMaterialExporter._Epsilon)) {
                        writeOutMetallicRoughnessTexture = true;
                    }
                }
            }
            if (writeOutMetallicRoughnessTexture) {
                var promise = this._createBase64FromCanvasAsync(metallicRoughnessBuffer, width, height, mimeType).then(function (metallicRoughnessBase64) {
                    metallicRoughnessFactors_1.metallicRoughnessTextureBase64 = metallicRoughnessBase64;
                });
                promises.push(promise);
            }
            if (writeOutBaseColorTexture) {
                var promise = this._createBase64FromCanvasAsync(baseColorBuffer, width, height, mimeType).then(function (baseColorBase64) {
                    metallicRoughnessFactors_1.baseColorTextureBase64 = baseColorBase64;
                });
                promises.push(promise);
            }
            return Promise.all(promises).then(function () {
                return metallicRoughnessFactors_1;
            });
        }
        else {
            return Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!");
        }
    };
    /**
     * Converts specular glossiness material properties to metallic roughness
     * @param specularGlossiness interface with specular glossiness material properties
     * @returns interface with metallic roughness material properties
     */
    _GLTFMaterialExporter.prototype._convertSpecularGlossinessToMetallicRoughness = function (specularGlossiness) {
        var diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);
        var specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);
        var oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);
        var metallic = _GLTFMaterialExporter._SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);
        var baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1.0 - _GLTFMaterialExporter._DielectricSpecular.r) / Math.max(1 - metallic, _GLTFMaterialExporter._Epsilon));
        var baseColorFromSpecular = specularGlossiness.specularColor.subtract(_GLTFMaterialExporter._DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic, _GLTFMaterialExporter._Epsilon));
        var baseColor = babylonjs_1.Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);
        baseColor = baseColor.clampToRef(0, 1, baseColor);
        var metallicRoughness = {
            baseColor: baseColor,
            metallic: metallic,
            roughness: 1 - specularGlossiness.glossiness
        };
        return metallicRoughness;
    };
    /**
     * Calculates the surface reflectance, independent of lighting conditions
     * @param color Color source to calculate brightness from
     * @returns number representing the perceived brightness, or zero if color is undefined
     */
    _GLTFMaterialExporter.prototype._getPerceivedBrightness = function (color) {
        if (color) {
            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);
        }
        return 0;
    };
    /**
     * Returns the maximum color component value
     * @param color
     * @returns maximum color component value, or zero if color is null or undefined
     */
    _GLTFMaterialExporter.prototype._getMaxComponent = function (color) {
        if (color) {
            return Math.max(color.r, Math.max(color.g, color.b));
        }
        return 0;
    };
    /**
     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors
     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material
     * @param mimeType mime type to use for the textures
     * @param images array of glTF image interfaces
     * @param textures array of glTF texture interfaces
     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface
     * @param imageData map of image file name to data
     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied
     * @returns glTF PBR Metallic Roughness factors
     */
    _GLTFMaterialExporter.prototype._convertMetalRoughFactorsToMetallicRoughnessAsync = function (babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords) {
        var promises = [];
        var metallicRoughness = {
            baseColor: babylonPBRMaterial.albedoColor,
            metallic: babylonPBRMaterial.metallic,
            roughness: babylonPBRMaterial.roughness
        };
        if (hasTextureCoords) {
            if (babylonPBRMaterial.albedoTexture) {
                promises.push(this._exportTextureAsync(babylonPBRMaterial.albedoTexture, mimeType).then(function (glTFTexture) {
                    if (glTFTexture) {
                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;
                    }
                }));
            }
            if (babylonPBRMaterial.metallicTexture) {
                promises.push(this._exportTextureAsync(babylonPBRMaterial.metallicTexture, mimeType).then(function (glTFTexture) {
                    if (glTFTexture) {
                        glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;
                    }
                }));
            }
        }
        return Promise.all(promises).then(function () {
            return metallicRoughness;
        });
    };
    _GLTFMaterialExporter.prototype._getGLTFTextureSampler = function (texture) {
        var sampler = this._getGLTFTextureWrapModesSampler(texture);
        var samplingMode = texture instanceof babylonjs_1.Texture ? texture.samplingMode : null;
        if (samplingMode != null) {
            switch (samplingMode) {
                case babylonjs_1.Texture.LINEAR_LINEAR: {
                    sampler.magFilter = 9729 /* LINEAR */;
                    sampler.minFilter = 9729 /* LINEAR */;
                    break;
                }
                case babylonjs_1.Texture.LINEAR_NEAREST: {
                    sampler.magFilter = 9729 /* LINEAR */;
                    sampler.minFilter = 9728 /* NEAREST */;
                    break;
                }
                case babylonjs_1.Texture.NEAREST_LINEAR: {
                    sampler.magFilter = 9728 /* NEAREST */;
                    sampler.minFilter = 9729 /* LINEAR */;
                    break;
                }
                case babylonjs_1.Texture.NEAREST_LINEAR_MIPLINEAR: {
                    sampler.magFilter = 9728 /* NEAREST */;
                    sampler.minFilter = 9987 /* LINEAR_MIPMAP_LINEAR */;
                    break;
                }
                case babylonjs_1.Texture.NEAREST_NEAREST: {
                    sampler.magFilter = 9728 /* NEAREST */;
                    sampler.minFilter = 9728 /* NEAREST */;
                    break;
                }
                case babylonjs_1.Texture.NEAREST_LINEAR_MIPNEAREST: {
                    sampler.magFilter = 9728 /* NEAREST */;
                    sampler.minFilter = 9985 /* LINEAR_MIPMAP_NEAREST */;
                    break;
                }
                case babylonjs_1.Texture.LINEAR_NEAREST_MIPNEAREST: {
                    sampler.magFilter = 9729 /* LINEAR */;
                    sampler.minFilter = 9984 /* NEAREST_MIPMAP_NEAREST */;
                    break;
                }
                case babylonjs_1.Texture.LINEAR_NEAREST_MIPLINEAR: {
                    sampler.magFilter = 9729 /* LINEAR */;
                    sampler.minFilter = 9986 /* NEAREST_MIPMAP_LINEAR */;
                    break;
                }
                case babylonjs_1.Texture.NEAREST_NEAREST_MIPLINEAR: {
                    sampler.magFilter = 9728 /* NEAREST */;
                    sampler.minFilter = 9986 /* NEAREST_MIPMAP_LINEAR */;
                    break;
                }
                case babylonjs_1.Texture.LINEAR_LINEAR_MIPLINEAR: {
                    sampler.magFilter = 9729 /* LINEAR */;
                    sampler.minFilter = 9987 /* LINEAR_MIPMAP_LINEAR */;
                    break;
                }
                case babylonjs_1.Texture.LINEAR_LINEAR_MIPNEAREST: {
                    sampler.magFilter = 9729 /* LINEAR */;
                    sampler.minFilter = 9985 /* LINEAR_MIPMAP_NEAREST */;
                    break;
                }
                case babylonjs_1.Texture.NEAREST_NEAREST_MIPNEAREST: {
                    sampler.magFilter = 9728 /* NEAREST */;
                    sampler.minFilter = 9984 /* NEAREST_MIPMAP_NEAREST */;
                    break;
                }
            }
        }
        return sampler;
    };
    _GLTFMaterialExporter.prototype._getGLTFTextureWrapMode = function (wrapMode) {
        switch (wrapMode) {
            case babylonjs_1.Texture.WRAP_ADDRESSMODE: {
                return 10497 /* REPEAT */;
            }
            case babylonjs_1.Texture.CLAMP_ADDRESSMODE: {
                return 33071 /* CLAMP_TO_EDGE */;
            }
            case babylonjs_1.Texture.MIRROR_ADDRESSMODE: {
                return 33648 /* MIRRORED_REPEAT */;
            }
            default: {
                babylonjs_1.Tools.Error("Unsupported Texture Wrap Mode " + wrapMode + "!");
                return 10497 /* REPEAT */;
            }
        }
    };
    _GLTFMaterialExporter.prototype._getGLTFTextureWrapModesSampler = function (texture) {
        var wrapS = this._getGLTFTextureWrapMode(texture instanceof babylonjs_1.Texture ? texture.wrapU : babylonjs_1.Texture.WRAP_ADDRESSMODE);
        var wrapT = this._getGLTFTextureWrapMode(texture instanceof babylonjs_1.Texture ? texture.wrapV : babylonjs_1.Texture.WRAP_ADDRESSMODE);
        if (wrapS === 10497 /* REPEAT */ && wrapT === 10497 /* REPEAT */) { // default wrapping mode in glTF, so omitting
            return {};
        }
        return { wrapS: wrapS, wrapT: wrapT };
    };
    /**
     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors
     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material
     * @param mimeType mime type to use for the textures
     * @param images array of glTF image interfaces
     * @param textures array of glTF texture interfaces
     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface
     * @param imageData map of image file name to data
     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied
     * @returns glTF PBR Metallic Roughness factors
     */
    _GLTFMaterialExporter.prototype._convertSpecGlossFactorsToMetallicRoughnessAsync = function (babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords) {
        var _this = this;
        return Promise.resolve().then(function () {
            var samplers = _this._exporter._samplers;
            var textures = _this._exporter._textures;
            var specGloss = {
                diffuseColor: babylonPBRMaterial.albedoColor || babylonjs_1.Color3.White(),
                specularColor: babylonPBRMaterial.reflectivityColor || babylonjs_1.Color3.White(),
                glossiness: babylonPBRMaterial.microSurface || 1,
            };
            var samplerIndex = null;
            var sampler = _this._getGLTFTextureSampler(babylonPBRMaterial.albedoTexture);
            if (sampler.magFilter != null && sampler.minFilter != null && sampler.wrapS != null && sampler.wrapT != null) {
                samplers.push(sampler);
                samplerIndex = samplers.length - 1;
            }
            if (babylonPBRMaterial.reflectivityTexture && !babylonPBRMaterial.useMicroSurfaceFromReflectivityMapAlpha) {
                return Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");
            }
            if ((babylonPBRMaterial.albedoTexture || babylonPBRMaterial.reflectivityTexture) && hasTextureCoords) {
                return _this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(babylonPBRMaterial.albedoTexture, babylonPBRMaterial.reflectivityTexture, specGloss, mimeType).then(function (metallicRoughnessFactors) {
                    if (metallicRoughnessFactors.baseColorTextureBase64) {
                        var glTFBaseColorTexture = _this._getTextureInfoFromBase64(metallicRoughnessFactors.baseColorTextureBase64, "bjsBaseColorTexture_" + (textures.length) + ".png", mimeType, babylonPBRMaterial.albedoTexture ? babylonPBRMaterial.albedoTexture.coordinatesIndex : null, samplerIndex);
                        if (glTFBaseColorTexture) {
                            glTFPbrMetallicRoughness.baseColorTexture = glTFBaseColorTexture;
                        }
                    }
                    if (metallicRoughnessFactors.metallicRoughnessTextureBase64) {
                        var glTFMRColorTexture = _this._getTextureInfoFromBase64(metallicRoughnessFactors.metallicRoughnessTextureBase64, "bjsMetallicRoughnessTexture_" + (textures.length) + ".png", mimeType, babylonPBRMaterial.reflectivityTexture ? babylonPBRMaterial.reflectivityTexture.coordinatesIndex : null, samplerIndex);
                        if (glTFMRColorTexture) {
                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFMRColorTexture;
                        }
                    }
                    return metallicRoughnessFactors;
                });
            }
            else {
                return _this._convertSpecularGlossinessToMetallicRoughness(specGloss);
            }
        });
    };
    /**
     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material
     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material
     * @param mimeType mime type to use for the textures
     * @param images array of glTF image interfaces
     * @param textures array of glTF texture interfaces
     * @param materials array of glTF material interfaces
     * @param imageData map of image file name to data
     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied
     */
    _GLTFMaterialExporter.prototype._convertPBRMaterialAsync = function (babylonPBRMaterial, mimeType, hasTextureCoords) {
        var _this = this;
        var glTFPbrMetallicRoughness = {};
        var glTFMaterial = {
            name: babylonPBRMaterial.name
        };
        var useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();
        if (useMetallicRoughness) {
            if (babylonPBRMaterial.albedoColor) {
                glTFPbrMetallicRoughness.baseColorFactor = [
                    babylonPBRMaterial.albedoColor.r,
                    babylonPBRMaterial.albedoColor.g,
                    babylonPBRMaterial.albedoColor.b,
                    babylonPBRMaterial.alpha
                ];
            }
            return this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then(function (metallicRoughness) {
                return _this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);
            });
        }
        else {
            return this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then(function (metallicRoughness) {
                return _this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);
            });
        }
    };
    _GLTFMaterialExporter.prototype.setMetallicRoughnessPbrMaterial = function (metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords) {
        var materialMap = this._exporter._materialMap;
        var materials = this._exporter._materials;
        var promises = [];
        if (metallicRoughness) {
            var alphaMode = null;
            if (babylonPBRMaterial.transparencyMode != null) {
                alphaMode = this._getAlphaMode(babylonPBRMaterial);
                if (alphaMode) {
                    if (alphaMode !== "OPAQUE" /* OPAQUE */) { //glTF defaults to opaque
                        glTFMaterial.alphaMode = alphaMode;
                        if (alphaMode === "MASK" /* MASK */) {
                            glTFMaterial.alphaCutoff = babylonPBRMaterial.alphaCutOff;
                        }
                    }
                }
            }
            if (!(_GLTFMaterialExporter.FuzzyEquals(metallicRoughness.baseColor, babylonjs_1.Color3.White(), _GLTFMaterialExporter._Epsilon) && babylonPBRMaterial.alpha >= _GLTFMaterialExporter._Epsilon)) {
                glTFPbrMetallicRoughness.baseColorFactor = [
                    metallicRoughness.baseColor.r,
                    metallicRoughness.baseColor.g,
                    metallicRoughness.baseColor.b,
                    babylonPBRMaterial.alpha
                ];
            }
            if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {
                glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;
            }
            if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {
                glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;
            }
            if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {
                if (!babylonPBRMaterial.twoSidedLighting) {
                    babylonjs_1.Tools.Warn(babylonPBRMaterial.name + ": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.");
                }
                glTFMaterial.doubleSided = true;
            }
            if (hasTextureCoords) {
                if (babylonPBRMaterial.bumpTexture) {
                    var promise = this._exportTextureAsync(babylonPBRMaterial.bumpTexture, mimeType).then(function (glTFTexture) {
                        if (glTFTexture) {
                            glTFMaterial.normalTexture = glTFTexture;
                            if (babylonPBRMaterial.bumpTexture.level !== 1) {
                                glTFMaterial.normalTexture.scale = babylonPBRMaterial.bumpTexture.level;
                            }
                        }
                    });
                    promises.push(promise);
                }
                if (babylonPBRMaterial.ambientTexture) {
                    var promise = this._exportTextureAsync(babylonPBRMaterial.ambientTexture, mimeType).then(function (glTFTexture) {
                        if (glTFTexture) {
                            var occlusionTexture = {
                                index: glTFTexture.index
                            };
                            glTFMaterial.occlusionTexture = occlusionTexture;
                            if (babylonPBRMaterial.ambientTextureStrength) {
                                occlusionTexture.strength = babylonPBRMaterial.ambientTextureStrength;
                            }
                        }
                    });
                    promises.push(promise);
                }
                if (babylonPBRMaterial.emissiveTexture) {
                    var promise = this._exportTextureAsync(babylonPBRMaterial.emissiveTexture, mimeType).then(function (glTFTexture) {
                        if (glTFTexture) {
                            glTFMaterial.emissiveTexture = glTFTexture;
                        }
                    });
                    promises.push(promise);
                }
            }
            if (!_GLTFMaterialExporter.FuzzyEquals(babylonPBRMaterial.emissiveColor, babylonjs_1.Color3.Black(), _GLTFMaterialExporter._Epsilon)) {
                glTFMaterial.emissiveFactor = babylonPBRMaterial.emissiveColor.asArray();
            }
            glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;
            materials.push(glTFMaterial);
            materialMap[babylonPBRMaterial.uniqueId] = materials.length - 1;
        }
        return Promise.all(promises).then(function (result) { });
    };
    _GLTFMaterialExporter.prototype.getPixelsFromTexture = function (babylonTexture) {
        var pixels = babylonTexture.textureType === babylonjs_1.Engine.TEXTURETYPE_UNSIGNED_INT ? babylonTexture.readPixels() : babylonTexture.readPixels();
        return pixels;
    };
    /**
     * Extracts a texture from a Babylon texture into file data and glTF data
     * @param babylonTexture Babylon texture to extract
     * @param mimeType Mime Type of the babylonTexture
     * @return glTF texture info, or null if the texture format is not supported
     */
    _GLTFMaterialExporter.prototype._exportTextureAsync = function (babylonTexture, mimeType) {
        var _this = this;
        var extensionPromise = this._exporter._extensionsPreExportTextureAsync("exporter", babylonTexture, mimeType);
        if (!extensionPromise) {
            return this._exportTextureInfoAsync(babylonTexture, mimeType);
        }
        return extensionPromise.then(function (texture) {
            if (!texture) {
                return _this._exportTextureInfoAsync(babylonTexture, mimeType);
            }
            return _this._exportTextureInfoAsync(texture, mimeType);
        });
    };
    _GLTFMaterialExporter.prototype._exportTextureInfoAsync = function (babylonTexture, mimeType) {
        var _this = this;
        return Promise.resolve().then(function () {
            var textureUid = babylonTexture.uid;
            if (textureUid in _this._textureMap) {
                return _this._textureMap[textureUid];
            }
            else {
                var samplers = _this._exporter._samplers;
                var sampler = _this._getGLTFTextureSampler(babylonTexture);
                var samplerIndex_1 = null;
                //  if a pre-existing sampler with identical parameters exists, then reuse the previous sampler
                var foundSamplerIndex = null;
                for (var i = 0; i < samplers.length; ++i) {
                    var s = samplers[i];
                    if (s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter &&
                        s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT) {
                        foundSamplerIndex = i;
                        break;
                    }
                }
                if (foundSamplerIndex == null) {
                    samplers.push(sampler);
                    samplerIndex_1 = samplers.length - 1;
                }
                else {
                    samplerIndex_1 = foundSamplerIndex;
                }
                var pixels = _this.getPixelsFromTexture(babylonTexture);
                var size = babylonTexture.getSize();
                return _this._createBase64FromCanvasAsync(pixels, size.width, size.height, mimeType).then(function (base64Data) {
                    var textureInfo = _this._getTextureInfoFromBase64(base64Data, babylonTexture.name.replace(/\.\/|\/|\.\\|\\/g, "_"), mimeType, babylonTexture.coordinatesIndex, samplerIndex_1);
                    if (textureInfo) {
                        _this._textureMap[textureUid] = textureInfo;
                    }
                    return textureInfo;
                });
            }
        });
    };
    /**
     * Builds a texture from base64 string
     * @param base64Texture base64 texture string
     * @param baseTextureName Name to use for the texture
     * @param mimeType image mime type for the texture
     * @param images array of images
     * @param textures array of textures
     * @param imageData map of image data
     * @returns glTF texture info, or null if the texture format is not supported
     */
    _GLTFMaterialExporter.prototype._getTextureInfoFromBase64 = function (base64Texture, baseTextureName, mimeType, texCoordIndex, samplerIndex) {
        var textures = this._exporter._textures;
        var images = this._exporter._images;
        var imageData = this._exporter._imageData;
        var textureInfo = null;
        var glTFTexture = {
            source: images.length,
            name: baseTextureName
        };
        if (samplerIndex != null) {
            glTFTexture.sampler = samplerIndex;
        }
        var binStr = atob(base64Texture.split(',')[1]);
        var arrBuff = new ArrayBuffer(binStr.length);
        var arr = new Uint8Array(arrBuff);
        for (var i = 0, length_2 = binStr.length; i < length_2; ++i) {
            arr[i] = binStr.charCodeAt(i);
        }
        var imageValues = { data: arr, mimeType: mimeType };
        var extension = mimeType === "image/jpeg" /* JPEG */ ? '.jpeg' : '.png';
        var textureName = baseTextureName + extension;
        if (textureName in imageData) {
            textureName = baseTextureName + "_" + babylonjs_1.Tools.RandomId() + extension;
        }
        imageData[textureName] = imageValues;
        if (mimeType === "image/jpeg" /* JPEG */ || mimeType === "image/png" /* PNG */) {
            var glTFImage = {
                name: baseTextureName,
                uri: textureName
            };
            var foundIndex = null;
            for (var i = 0; i < images.length; ++i) {
                if (images[i].uri === textureName) {
                    foundIndex = i;
                    break;
                }
            }
            if (foundIndex == null) {
                images.push(glTFImage);
                glTFTexture.source = images.length - 1;
            }
            else {
                glTFTexture.source = foundIndex;
            }
            textures.push(glTFTexture);
            textureInfo = {
                index: textures.length - 1
            };
            if (texCoordIndex != null) {
                textureInfo.texCoord = texCoordIndex;
            }
        }
        else {
            babylonjs_1.Tools.Error("Unsupported texture mime type " + mimeType);
        }
        return textureInfo;
    };
    /**
     * Represents the dielectric specular values for R, G and B
     */
    _GLTFMaterialExporter._DielectricSpecular = new babylonjs_1.Color3(0.04, 0.04, 0.04);
    /**
     * Allows the maximum specular power to be defined for material calculations
     */
    _GLTFMaterialExporter._MaxSpecularPower = 1024;
    /**
     * Numeric tolerance value
     */
    _GLTFMaterialExporter._Epsilon = 1e-6;
    return _GLTFMaterialExporter;
}());
exports._GLTFMaterialExporter = _GLTFMaterialExporter;


/***/ }),

/***/ "./src/glTF/2.0/glTFSerializer.ts":
/*!****************************************!*\
  !*** ./src/glTF/2.0/glTFSerializer.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var glTFExporter_1 = __webpack_require__(/*! ./glTFExporter */ "./src/glTF/2.0/glTFExporter.ts");
/**
 * Class for generating glTF data from a Babylon scene.
 */
var GLTF2Export = /** @class */ (function () {
    function GLTF2Export() {
    }
    /**
     * Exports the geometry of the scene to .gltf file format asynchronously
     * @param scene Babylon scene with scene hierarchy information
     * @param filePrefix File prefix to use when generating the glTF file
     * @param options Exporter options
     * @returns Returns an object with a .gltf file and associates texture names
     * as keys and their data and paths as values
     */
    GLTF2Export.GLTFAsync = function (scene, filePrefix, options) {
        return scene.whenReadyAsync().then(function () {
            var glTFPrefix = filePrefix.replace(/\.[^/.]+$/, "");
            var gltfGenerator = new glTFExporter_1._Exporter(scene, options);
            return gltfGenerator._generateGLTFAsync(glTFPrefix);
        });
    };
    GLTF2Export._PreExportAsync = function (scene, options) {
        return Promise.resolve().then(function () {
            if (options && options.exportWithoutWaitingForScene) {
                return Promise.resolve();
            }
            else {
                return scene.whenReadyAsync();
            }
        });
    };
    GLTF2Export._PostExportAsync = function (scene, glTFData, options) {
        return Promise.resolve().then(function () {
            if (options && options.exportWithoutWaitingForScene) {
                return glTFData;
            }
            else {
                return glTFData;
            }
        });
    };
    /**
     * Exports the geometry of the scene to .glb file format asychronously
     * @param scene Babylon scene with scene hierarchy information
     * @param filePrefix File prefix to use when generating glb file
     * @param options Exporter options
     * @returns Returns an object with a .glb filename as key and data as value
     */
    GLTF2Export.GLBAsync = function (scene, filePrefix, options) {
        var _this = this;
        return this._PreExportAsync(scene, options).then(function () {
            var glTFPrefix = filePrefix.replace(/\.[^/.]+$/, "");
            var gltfGenerator = new glTFExporter_1._Exporter(scene, options);
            return gltfGenerator._generateGLBAsync(glTFPrefix).then(function (glTFData) {
                return _this._PostExportAsync(scene, glTFData, options);
            });
        });
    };
    return GLTF2Export;
}());
exports.GLTF2Export = GLTF2Export;


/***/ }),

/***/ "./src/glTF/2.0/glTFUtilities.ts":
/*!***************************************!*\
  !*** ./src/glTF/2.0/glTFUtilities.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var babylonjs_1 = __webpack_require__(/*! babylonjs */ "babylonjs");
/**
 * @hidden
 */
var _GLTFUtilities = /** @class */ (function () {
    function _GLTFUtilities() {
    }
    /**
     * Creates a buffer view based on the supplied arguments
     * @param bufferIndex index value of the specified buffer
     * @param byteOffset byte offset value
     * @param byteLength byte length of the bufferView
     * @param byteStride byte distance between conequential elements
     * @param name name of the buffer view
     * @returns bufferView for glTF
     */
    _GLTFUtilities._CreateBufferView = function (bufferIndex, byteOffset, byteLength, byteStride, name) {
        var bufferview = { buffer: bufferIndex, byteLength: byteLength };
        if (byteOffset) {
            bufferview.byteOffset = byteOffset;
        }
        if (name) {
            bufferview.name = name;
        }
        if (byteStride) {
            bufferview.byteStride = byteStride;
        }
        return bufferview;
    };
    /**
     * Creates an accessor based on the supplied arguments
     * @param bufferviewIndex The index of the bufferview referenced by this accessor
     * @param name The name of the accessor
     * @param type The type of the accessor
     * @param componentType The datatype of components in the attribute
     * @param count The number of attributes referenced by this accessor
     * @param byteOffset The offset relative to the start of the bufferView in bytes
     * @param min Minimum value of each component in this attribute
     * @param max Maximum value of each component in this attribute
     * @returns accessor for glTF
     */
    _GLTFUtilities._CreateAccessor = function (bufferviewIndex, name, type, componentType, count, byteOffset, min, max) {
        var accessor = { name: name, bufferView: bufferviewIndex, componentType: componentType, count: count, type: type };
        if (min != null) {
            accessor.min = min;
        }
        if (max != null) {
            accessor.max = max;
        }
        if (byteOffset != null) {
            accessor.byteOffset = byteOffset;
        }
        return accessor;
    };
    /**
     * Calculates the minimum and maximum values of an array of position floats
     * @param positions Positions array of a mesh
     * @param vertexStart Starting vertex offset to calculate min and max values
     * @param vertexCount Number of vertices to check for min and max values
     * @returns min number array and max number array
     */
    _GLTFUtilities._CalculateMinMaxPositions = function (positions, vertexStart, vertexCount, convertToRightHandedSystem) {
        var min = [Infinity, Infinity, Infinity];
        var max = [-Infinity, -Infinity, -Infinity];
        var positionStrideSize = 3;
        var indexOffset;
        var position;
        var vector;
        if (vertexCount) {
            for (var i = vertexStart, length_1 = vertexStart + vertexCount; i < length_1; ++i) {
                indexOffset = positionStrideSize * i;
                position = babylonjs_1.Vector3.FromArray(positions, indexOffset);
                if (convertToRightHandedSystem) {
                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(position);
                }
                vector = position.asArray();
                for (var j = 0; j < positionStrideSize; ++j) {
                    var num = vector[j];
                    if (num < min[j]) {
                        min[j] = num;
                    }
                    if (num > max[j]) {
                        max[j] = num;
                    }
                    ++indexOffset;
                }
            }
        }
        return { min: min, max: max };
    };
    /**
     * Converts a new right-handed Vector3
     * @param vector vector3 array
     * @returns right-handed Vector3
     */
    _GLTFUtilities._GetRightHandedPositionVector3 = function (vector) {
        return new babylonjs_1.Vector3(vector.x, vector.y, -vector.z);
    };
    /**
     * Converts a Vector3 to right-handed
     * @param vector Vector3 to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedPositionVector3FromRef = function (vector) {
        vector.z *= -1;
    };
    /**
     * Converts a three element number array to right-handed
     * @param vector number array to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedPositionArray3FromRef = function (vector) {
        vector[2] *= -1;
    };
    /**
     * Converts a new right-handed Vector3
     * @param vector vector3 array
     * @returns right-handed Vector3
     */
    _GLTFUtilities._GetRightHandedNormalVector3 = function (vector) {
        return new babylonjs_1.Vector3(vector.x, vector.y, -vector.z);
    };
    /**
     * Converts a Vector3 to right-handed
     * @param vector Vector3 to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedNormalVector3FromRef = function (vector) {
        vector.z *= -1;
    };
    /**
     * Converts a three element number array to right-handed
     * @param vector number array to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedNormalArray3FromRef = function (vector) {
        vector[2] *= -1;
    };
    /**
     * Converts a Vector4 to right-handed
     * @param vector Vector4 to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedVector4FromRef = function (vector) {
        vector.z *= -1;
        vector.w *= -1;
    };
    /**
     * Converts a Vector4 to right-handed
     * @param vector Vector4 to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedArray4FromRef = function (vector) {
        vector[2] *= -1;
        vector[3] *= -1;
    };
    /**
     * Converts a Quaternion to right-handed
     * @param quaternion Source quaternion to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedQuaternionFromRef = function (quaternion) {
        quaternion.x *= -1;
        quaternion.y *= -1;
    };
    /**
     * Converts a Quaternion to right-handed
     * @param quaternion Source quaternion to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedQuaternionArrayFromRef = function (quaternion) {
        quaternion[0] *= -1;
        quaternion[1] *= -1;
    };
    _GLTFUtilities._NormalizeTangentFromRef = function (tangent) {
        var length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);
        if (length > 0) {
            tangent.x /= length;
            tangent.y /= length;
            tangent.z /= length;
        }
    };
    return _GLTFUtilities;
}());
exports._GLTFUtilities = _GLTFUtilities;


/***/ }),

/***/ "./src/glTF/2.0/index.ts":
/*!*******************************!*\
  !*** ./src/glTF/2.0/index.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./glTFAnimation */ "./src/glTF/2.0/glTFAnimation.ts"));
__export(__webpack_require__(/*! ./glTFData */ "./src/glTF/2.0/glTFData.ts"));
__export(__webpack_require__(/*! ./glTFExporter */ "./src/glTF/2.0/glTFExporter.ts"));
__export(__webpack_require__(/*! ./glTFExporterExtension */ "./src/glTF/2.0/glTFExporterExtension.ts"));
__export(__webpack_require__(/*! ./glTFMaterialExporter */ "./src/glTF/2.0/glTFMaterialExporter.ts"));
__export(__webpack_require__(/*! ./glTFSerializer */ "./src/glTF/2.0/glTFSerializer.ts"));
__export(__webpack_require__(/*! ./glTFUtilities */ "./src/glTF/2.0/glTFUtilities.ts"));
__export(__webpack_require__(/*! ./Extensions */ "./src/glTF/2.0/Extensions/index.ts"));


/***/ }),

/***/ "./src/glTF/2.0/shaders/textureTransform.fragment.fx":
/*!***********************************************************!*\
  !*** ./src/glTF/2.0/shaders/textureTransform.fragment.fx ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform mat4 textureTransformMat;\nvoid main(void) {\nvec2 uvTransformed=(textureTransformMat*vec4(vUV.xy,1,1)).xy;\ngl_FragColor=texture2D(textureSampler,uvTransformed);\n}"

/***/ }),

/***/ "./src/glTF/glTFFileExporter.ts":
/*!**************************************!*\
  !*** ./src/glTF/glTFFileExporter.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @hidden */
exports.__IGLTFExporterExtension = 0; // I am here to allow dts to be created


/***/ }),

/***/ "babylonjs":
/*!****************************************************************************************************!*\
  !*** external {"root":"BABYLON","commonjs":"babylonjs","commonjs2":"babylonjs","amd":"babylonjs"} ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_babylonjs__;

/***/ })

/******/ });
});
//# sourceMappingURL=babylon.glTF2Serializer.min.js.map
=======
var BABYLON;BABYLON.Effect.ShadersStore.textureTransformPixelShader="precision highp float;\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform mat4 textureTransformMat;\nvoid main(void) {\nvec2 uvTransformed=(textureTransformMat*vec4(vUV.xy,1,1)).xy;\ngl_FragColor=texture2D(textureSampler,uvTransformed);\n}",(function(i){var e=(function(){function e(){}return e.GLTFAsync=function(t,r,n){return t.whenReadyAsync().then((function(){var e=r.replace(/\.[^/.]+$/,"");return new i.GLTF2.Exporter._Exporter(t,n)._generateGLTFAsync(e)}))},e._PreExportAsync=function(e,t){return Promise.resolve().then((function(){return t&&t.exportWithoutWaitingForScene?Promise.resolve():e.whenReadyAsync()}))},e._PostExportAsync=function(e,t,r){return Promise.resolve().then((function(){return r&&r.exportWithoutWaitingForScene,t}))},e.GLBAsync=function(t,r,n){var a=this;return this._PreExportAsync(t,n).then((function(){var e=r.replace(/\.[^/.]+$/,"");return new i.GLTF2.Exporter._Exporter(t,n)._generateGLBAsync(e).then((function(e){return a._PostExportAsync(t,e,n)}))}))},e})();i.GLTF2Export=e})(BABYLON||(BABYLON={})),(function(W){var e;(function(z){var e=(function(){function u(e,t){this._extensions={},this._asset={generator:"BabylonJS",version:"2.0"},this._extensionsUsed=[],this._extensionsRequired=[],this._babylonScene=e,this._bufferViews=[],this._accessors=[],this._meshes=[],this._scenes=[],this._nodes=[],this._images=[],this._materials=[],this._materialMap=[],this._textures=[],this._samplers=[],this._animations=[],this._imageData={},this._convertToRightHandedSystem=!this._babylonScene.useRightHandedSystem;var r=t||{};this._shouldExportTransformNode=r.shouldExportTransformNode?r.shouldExportTransformNode:function(e){return!0},this._animationSampleRate=r.animationSampleRate?r.animationSampleRate:1/60,this._glTFMaterialExporter=new z._GLTFMaterialExporter(this),this._loadExtensions()}return u.prototype._applyExtensions=function(e,t){for(var r=0,n=u._ExtensionNames;r<n.length;r++){var a=n[r],i=this._extensions[a];if(i.enabled){var o=e;o._activeLoaderExtensions=o._activeLoaderExtensions||{};var s=o._activeLoaderExtensions;if(!s[a]){s[a]=!0;try{var l=t(i);if(l)return l}finally{delete s[a],delete o._activeLoaderExtensions}}}}return null},u.prototype._extensionsPreExportTextureAsync=function(t,r,n){return this._applyExtensions(r,(function(e){return e.preExportTextureAsync&&e.preExportTextureAsync(t,r,n)}))},u.prototype._extensionsPostExportMeshPrimitiveAsync=function(t,r,n,a){return this._applyExtensions(r,(function(e){return e.postExportMeshPrimitiveAsync&&e.postExportMeshPrimitiveAsync(t,r,n,a)}))},u.prototype._loadExtensions=function(){for(var e=0,t=u._ExtensionNames;e<t.length;e++){var r=t[e],n=u._ExtensionFactories[r](this);this._extensions[r]=n}},u.RegisterExtension=function(e,t){u.UnregisterExtension(e)&&W.Tools.Warn("Extension with the name "+e+" already exists"),u._ExtensionFactories[e]=t,u._ExtensionNames.push(e)},u.UnregisterExtension=function(e){if(!u._ExtensionFactories[e])return!1;delete u._ExtensionFactories[e];var t=u._ExtensionNames.indexOf(e);return-1!==t&&u._ExtensionNames.splice(t,1),!0},u.prototype._getLocalEngine=function(){if(!this._localEngine){var e=document.createElement("canvas");e.id="WriteCanvas",e.width=2048,e.height=2048,this._localEngine=new W.Engine(e,!0,{premultipliedAlpha:!1,preserveDrawingBuffer:!0}),this._localEngine.setViewport(new W.Viewport(0,0,1,1))}return this._localEngine},u.prototype.reorderIndicesBasedOnPrimitiveMode=function(e,t,r,n,a){switch(t){case W.Material.TriangleFillMode:n||(n=0);for(var i=e.indexStart,o=e.indexStart+e.indexCount;i<o;i+=3){var s=n+4*i,l=a.getUInt32(s+4),u=a.getUInt32(s+8);a.setUInt32(u,s+4),a.setUInt32(l,s+8)}break;case W.Material.TriangleFanDrawMode:i=e.indexStart+e.indexCount-1;for(var c=e.indexStart;c<=i;--i)a.setUInt32(r[i],n),n+=4;break;case W.Material.TriangleStripDrawMode:3<=e.indexCount&&(a.setUInt32(r[e.indexStart+2],n+4),a.setUInt32(r[e.indexStart+1],n+8))}},u.prototype.reorderVertexAttributeDataBasedOnPrimitiveMode=function(e,t,r,n,a,i,o){if(this._convertToRightHandedSystem&&r===W.Material.ClockWiseSideOrientation)switch(t){case W.Material.TriangleFillMode:this.reorderTriangleFillMode(e,t,r,n,a,i,o);break;case W.Material.TriangleStripDrawMode:this.reorderTriangleStripDrawMode(e,t,r,n,a,i,o);break;case W.Material.TriangleFanDrawMode:this.reorderTriangleFanMode(e,t,r,n,a,i,o)}},u.prototype.reorderTriangleFillMode=function(e,t,r,n,a,i,o){var s=this.getVertexBufferFromMesh(n,e.getMesh());if(s){var l=s.byteStride/W.VertexBuffer.GetTypeByteLength(s.type);if(e.verticesCount%3!=0)W.Tools.Error("The submesh vertices for the triangle fill mode is not divisible by 3!");else{var u=[],c=0;switch(n){case W.VertexBuffer.PositionKind:case W.VertexBuffer.NormalKind:for(var f=e.verticesStart;f<e.verticesStart+e.verticesCount;f+=3)c=f*l,u.push(W.Vector3.FromArray(a,c)),u.push(W.Vector3.FromArray(a,c+2*l)),u.push(W.Vector3.FromArray(a,c+l));break;case W.VertexBuffer.TangentKind:for(f=e.verticesStart;f<e.verticesStart+e.verticesCount;f+=3)c=f*l,u.push(W.Vector4.FromArray(a,c)),u.push(W.Vector4.FromArray(a,c+2*l)),u.push(W.Vector4.FromArray(a,c+l));break;case W.VertexBuffer.ColorKind:var h=s.getSize();for(f=e.verticesStart;f<e.verticesStart+e.verticesCount;f+=h)c=f*l,4===h?(u.push(W.Vector4.FromArray(a,c)),u.push(W.Vector4.FromArray(a,c+2*l)),u.push(W.Vector4.FromArray(a,c+l))):(u.push(W.Vector3.FromArray(a,c)),u.push(W.Vector3.FromArray(a,c+2*l)),u.push(W.Vector3.FromArray(a,c+l)));break;case W.VertexBuffer.UVKind:case W.VertexBuffer.UV2Kind:for(f=e.verticesStart;f<e.verticesStart+e.verticesCount;f+=3)c=f*l,u.push(W.Vector2.FromArray(a,c)),u.push(W.Vector2.FromArray(a,c+2*l)),u.push(W.Vector2.FromArray(a,c+l));break;default:W.Tools.Error("Unsupported Vertex Buffer type: "+n)}this.writeVertexAttributeData(u,i,n,a,o)}}else W.Tools.Warn("reorderTriangleFillMode: Vertex Buffer Kind "+n+" not present!")},u.prototype.reorderTriangleStripDrawMode=function(e,t,r,n,a,i,o){var s=this.getVertexBufferFromMesh(n,e.getMesh());if(s){var l=s.byteStride/W.VertexBuffer.GetTypeByteLength(s.type),u=[],c=0;switch(n){case W.VertexBuffer.PositionKind:case W.VertexBuffer.NormalKind:c=e.verticesStart,u.push(W.Vector3.FromArray(a,c+2*l)),u.push(W.Vector3.FromArray(a,c+l));break;case W.VertexBuffer.TangentKind:for(var f=e.verticesStart+e.verticesCount-1;f>=e.verticesStart;--f)c=f*l,u.push(W.Vector4.FromArray(a,c));break;case W.VertexBuffer.ColorKind:for(f=e.verticesStart+e.verticesCount-1;f>=e.verticesStart;--f)c=f*l,4===s.getSize()?u.push(W.Vector4.FromArray(a,c)):u.push(W.Vector3.FromArray(a,c));break;case W.VertexBuffer.UVKind:case W.VertexBuffer.UV2Kind:for(f=e.verticesStart+e.verticesCount-1;f>=e.verticesStart;--f)c=f*l,u.push(W.Vector2.FromArray(a,c));break;default:W.Tools.Error("Unsupported Vertex Buffer type: "+n)}this.writeVertexAttributeData(u,i+12,n,a,o)}else W.Tools.Warn("reorderTriangleStripDrawMode: Vertex buffer kind "+n+" not present!")},u.prototype.reorderTriangleFanMode=function(e,t,r,n,a,i,o){var s=this.getVertexBufferFromMesh(n,e.getMesh());if(s){var l=s.byteStride/W.VertexBuffer.GetTypeByteLength(s.type),u=[],c=0;switch(n){case W.VertexBuffer.PositionKind:case W.VertexBuffer.NormalKind:for(var f=e.verticesStart+e.verticesCount-1;f>=e.verticesStart;--f)c=f*l,u.push(W.Vector3.FromArray(a,c));break;case W.VertexBuffer.TangentKind:for(f=e.verticesStart+e.verticesCount-1;f>=e.verticesStart;--f)c=f*l,u.push(W.Vector4.FromArray(a,c));break;case W.VertexBuffer.ColorKind:for(f=e.verticesStart+e.verticesCount-1;f>=e.verticesStart;--f)c=f*l,u.push(W.Vector4.FromArray(a,c)),4===s.getSize()?u.push(W.Vector4.FromArray(a,c)):u.push(W.Vector3.FromArray(a,c));break;case W.VertexBuffer.UVKind:case W.VertexBuffer.UV2Kind:for(f=e.verticesStart+e.verticesCount-1;f>=e.verticesStart;--f)c=f*l,u.push(W.Vector2.FromArray(a,c));break;default:W.Tools.Error("Unsupported Vertex Buffer type: "+n)}this.writeVertexAttributeData(u,i,n,a,o)}else W.Tools.Warn("reorderTriangleFanMode: Vertex buffer kind "+n+" not present!")},u.prototype.writeVertexAttributeData=function(e,t,r,n,a){for(var i=0,o=e;i<o.length;i++){var s=o[i];!this._convertToRightHandedSystem||r===W.VertexBuffer.ColorKind||s instanceof W.Vector2||(s instanceof W.Vector3?r===W.VertexBuffer.NormalKind?z._GLTFUtilities._GetRightHandedNormalVector3FromRef(s):r===W.VertexBuffer.PositionKind?z._GLTFUtilities._GetRightHandedPositionVector3FromRef(s):W.Tools.Error("Unsupported vertex attribute kind!"):z._GLTFUtilities._GetRightHandedVector4FromRef(s)),r===W.VertexBuffer.NormalKind?s.normalize():r===W.VertexBuffer.TangentKind&&s instanceof W.Vector4&&z._GLTFUtilities._NormalizeTangentFromRef(s);for(var l=0,u=s.asArray();l<u.length;l++){var c=u[l];a.setFloat32(c,t),t+=4}}},u.prototype.writeAttributeData=function(e,t,r,n){var a,i=r/4,o=[];switch(e){case W.VertexBuffer.PositionKind:for(var s=0,l=t.length/i;s<l;++s){a=s*i;var u=W.Vector3.FromArray(t,a);this._convertToRightHandedSystem&&z._GLTFUtilities._GetRightHandedPositionVector3FromRef(u),o.push(u.asArray())}break;case W.VertexBuffer.NormalKind:s=0;for(var c=t.length/i;s<c;++s)a=s*i,u=W.Vector3.FromArray(t,a),this._convertToRightHandedSystem&&z._GLTFUtilities._GetRightHandedNormalVector3FromRef(u),u.normalize(),o.push(u.asArray());break;case W.VertexBuffer.TangentKind:s=0;for(var f=t.length/i;s<f;++s)a=s*i,u=W.Vector4.FromArray(t,a),this._convertToRightHandedSystem&&z._GLTFUtilities._GetRightHandedVector4FromRef(u),z._GLTFUtilities._NormalizeTangentFromRef(u),o.push(u.asArray());break;case W.VertexBuffer.ColorKind:s=0;for(var h=t.length/i;s<h;++s)a=s*i,u=3===i?W.Vector3.FromArray(t,a):W.Vector4.FromArray(t,a),o.push(u.asArray());break;case W.VertexBuffer.UVKind:case W.VertexBuffer.UV2Kind:s=0;for(var p=t.length/i;s<p;++s)a=s*i,o.push((this._convertToRightHandedSystem,[t[a],t[a+1]]));break;default:W.Tools.Warn("Unsupported Vertex Buffer Type: "+e),o=[]}for(var d=0,m=o;d<m.length;d++)for(var g=0,_=m[d];g<_.length;g++){var y=_[g];n.setFloat32(y)}},u.prototype.generateJSON=function(e,t,r){var n,a,i,o=this,s={byteLength:this._totalByteLength},l=this._totalByteLength,u={asset:this._asset};return this._extensionsUsed&&this._extensionsUsed.length&&(u.extensionsUsed=this._extensionsUsed),this._extensionsRequired&&this._extensionsRequired.length&&(u.extensionsRequired=this._extensionsRequired),s.byteLength&&(u.buffers=[s]),this._nodes&&this._nodes.length&&(u.nodes=this._nodes),this._meshes&&this._meshes.length&&(u.meshes=this._meshes),this._scenes&&this._scenes.length&&(u.scenes=this._scenes,u.scene=0),this._bufferViews&&this._bufferViews.length&&(u.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(u.accessors=this._accessors),this._animations&&this._animations.length&&(u.animations=this._animations),this._materials&&this._materials.length&&(u.materials=this._materials),this._textures&&this._textures.length&&(u.textures=this._textures),this._samplers&&this._samplers.length&&(u.samplers=this._samplers),this._images&&this._images.length&&(e?(u.images=[],this._images.forEach((function(e){e.uri&&(a=o._imageData[e.uri],n=e.uri.split(".")[0]+" image",i=z._GLTFUtilities._CreateBufferView(0,l,a.data.length,void 0,n),l+=a.data.buffer.byteLength,o._bufferViews.push(i),e.bufferView=o._bufferViews.length-1,e.name=n,e.mimeType=a.mimeType,e.uri=void 0,u.images||(u.images=[]),u.images.push(e))})),s.byteLength=l):u.images=this._images),e||(s.uri=t+".bin"),r?JSON.stringify(u,null,2):JSON.stringify(u)},u.prototype._generateGLTFAsync=function(s){var l=this;return this._generateBinaryAsync().then((function(e){var t=l.generateJSON(!1,s,!0),r=new Blob([e],{type:"application/octet-stream"}),n=s+".gltf",a=s+".bin",i=new W.GLTFData;if(i.glTFFiles[n]=t,i.glTFFiles[a]=r,l._imageData)for(var o in l._imageData)i.glTFFiles[o]=new Blob([l._imageData[o].data],{type:l._imageData[o].mimeType});return i}))},u.prototype._generateBinaryAsync=function(){var e=this,t=new r(4);return this.createSceneAsync(this._babylonScene,t).then((function(){return e._localEngine&&e._localEngine.dispose(),t.getArrayBuffer()}))},u.prototype._getPadding=function(e){var t=e%4;return 0===t?t:4-t},u.prototype._generateGLBAsync=function(M){var R=this;return this._generateBinaryAsync().then((function(e){var t=R.generateJSON(!0),r=M+".glb",n=t.length,a=0;for(var i in R._imageData)a+=R._imageData[i].data.byteLength;var o=R._getPadding(n),s=R._getPadding(e.byteLength),l=R._getPadding(a),u=28+n+o+e.byteLength+s+a+l,c=new ArrayBuffer(12),f=new DataView(c);f.setUint32(0,1179937895,!0),f.setUint32(4,2,!0),f.setUint32(8,u,!0);var h=new ArrayBuffer(8+n+o),p=new DataView(h);p.setUint32(0,n+o,!0),p.setUint32(4,1313821514,!0);for(var d=new Uint8Array(h,8),m=0;m<n;++m)d[m]=t.charCodeAt(m);var g=new Uint8Array(h,8+n);for(m=0;m<o;++m)g[m]=32;var _=new ArrayBuffer(8),y=new DataView(_);y.setUint32(0,e.byteLength+a+l,!0),y.setUint32(4,5130562,!0);var T=new ArrayBuffer(s),x=new Uint8Array(T);for(m=0;m<s;++m)x[m]=0;var v=new ArrayBuffer(l),A=new Uint8Array(v);for(m=0;m<l;++m)A[m]=0;var b=[c,h,_,e];for(var i in R._imageData)b.push(R._imageData[i].data.buffer);b.push(T),b.push(v);var F=new Blob(b,{type:"application/octet-stream"}),E=new W.GLTFData;return E.glTFFiles[r]=F,null!=R._localEngine&&R._localEngine.dispose(),E}))},u.prototype.setNodeTransformation=function(e,t){t.getPivotPoint().equalsToFloats(0,0,0)||W.Tools.Warn("Pivot points are not supported in the glTF serializer"),t.position.equalsToFloats(0,0,0)||(e.translation=this._convertToRightHandedSystem?z._GLTFUtilities._GetRightHandedPositionVector3(t.position).asArray():t.position.asArray()),t.scaling.equalsToFloats(1,1,1)||(e.scale=t.scaling.asArray());var r=W.Quaternion.RotationYawPitchRoll(t.rotation.y,t.rotation.x,t.rotation.z);t.rotationQuaternion&&r.multiplyInPlace(t.rotationQuaternion),0===r.x&&0===r.y&&0===r.z&&1===r.w||(this._convertToRightHandedSystem&&z._GLTFUtilities._GetRightHandedQuaternionFromRef(r),e.rotation=r.normalize().asArray())},u.prototype.getVertexBufferFromMesh=function(e,t){if(t.isVerticesDataPresent(e)){var r=t.getVertexBuffer(e);if(r)return r}return null},u.prototype.createBufferViewKind=function(e,t,r,n){var a=t instanceof W.Mesh?t:t instanceof W.InstancedMesh?t.sourceMesh:null;if(a){var i=a.getVerticesData(e);if(i){var o=4*i.length,s=z._GLTFUtilities._CreateBufferView(0,r.getByteOffset(),o,n,e+" - "+a.name);this._bufferViews.push(s),this.writeAttributeData(e,i,n,r)}}},u.prototype.getMeshPrimitiveMode=function(e){return e instanceof W.LinesMesh?W.Material.LineListDrawMode:e.material?e.material.fillMode:W.Material.TriangleFillMode},u.prototype.setPrimitiveMode=function(e,t){switch(t){case W.Material.TriangleFillMode:break;case W.Material.TriangleStripDrawMode:e.mode=5;break;case W.Material.TriangleFanDrawMode:e.mode=6;break;case W.Material.PointListDrawMode:e.mode=0;case W.Material.PointFillMode:e.mode=0;break;case W.Material.LineLoopDrawMode:e.mode=2;break;case W.Material.LineListDrawMode:e.mode=1;break;case W.Material.LineStripDrawMode:e.mode=3}},u.prototype.setAttributeKind=function(e,t){switch(t){case W.VertexBuffer.PositionKind:e.attributes.POSITION=this._accessors.length-1;break;case W.VertexBuffer.NormalKind:e.attributes.NORMAL=this._accessors.length-1;break;case W.VertexBuffer.ColorKind:e.attributes.COLOR_0=this._accessors.length-1;break;case W.VertexBuffer.TangentKind:e.attributes.TANGENT=this._accessors.length-1;break;case W.VertexBuffer.UVKind:e.attributes.TEXCOORD_0=this._accessors.length-1;break;case W.VertexBuffer.UV2Kind:e.attributes.TEXCOORD_1=this._accessors.length-1;break;default:W.Tools.Warn("Unsupported Vertex Buffer Type: "+t)}},u.prototype.setPrimitiveAttributesAsync=function(e,t,r){var n,a,i,o=[],s=null;t instanceof W.Mesh?s=t:t instanceof W.InstancedMesh&&(s=t.sourceMesh);var l=[{kind:W.VertexBuffer.PositionKind,accessorType:"VEC3",byteStride:12},{kind:W.VertexBuffer.NormalKind,accessorType:"VEC3",byteStride:12},{kind:W.VertexBuffer.ColorKind,accessorType:"VEC4",byteStride:16},{kind:W.VertexBuffer.TangentKind,accessorType:"VEC4",byteStride:16},{kind:W.VertexBuffer.UVKind,accessorType:"VEC2",byteStride:8},{kind:W.VertexBuffer.UV2Kind,accessorType:"VEC2",byteStride:8}];if(s){for(var u=null,c=this.getMeshPrimitiveMode(s),f={},h=0,p=l;h<p.length;h++){var d=(D=p[h]).kind;if(s.isVerticesDataPresent(d)){var m=this.getVertexBufferFromMesh(d,s);D.byteStride=m?4*m.getSize():4*W.VertexBuffer.DeduceStride(d),12===D.byteStride&&(D.accessorType="VEC3"),this.createBufferViewKind(d,t,r,D.byteStride),D.bufferViewIndex=this._bufferViews.length-1,f[d]=D.bufferViewIndex}}if(s.getTotalIndices()){var g=s.getIndices();if(g){var _=4*g.length;n=z._GLTFUtilities._CreateBufferView(0,r.getByteOffset(),_,void 0,"Indices - "+s.name),this._bufferViews.push(n),u=this._bufferViews.length-1;for(var y=0,T=g.length;y<T;++y)r.setUInt32(g[y])}}if(s.subMeshes)for(var x=0,v=s.subMeshes;x<v.length;x++){var A=v[x];a=!1;var b=A.getMaterial()||s.getScene().defaultMaterial,F=null;if(b)if(s instanceof W.LinesMesh){var E={name:s.name+" material"};(!s.color.equals(W.Color3.White())||s.alpha<1)&&(E.pbrMetallicRoughness={baseColorFactor:s.color.asArray().concat([s.alpha])}),this._materials.push(E),F=this._materials.length-1}else if(b instanceof W.MultiMaterial){var M=b.subMaterials[A.materialIndex];M&&(b=M,F=this._materialMap[b.uniqueId])}else F=this._materialMap[b.uniqueId];var R=null!=F?this._materials[F]:null,S={attributes:{}};this.setPrimitiveMode(S,c);for(var V=0,B=l;V<B.length;V++)if(((d=(D=B[V]).kind)!==W.VertexBuffer.UVKind&&d!==W.VertexBuffer.UV2Kind||!R||this._glTFMaterialExporter._hasTexturesPresent(R))&&(O=s.getVerticesData(d))&&(m=this.getVertexBufferFromMesh(d,s))){var w=m.getSize(),C=D.bufferViewIndex;if(null!=C){i={min:null,max:null},d==W.VertexBuffer.PositionKind&&(i=z._GLTFUtilities._CalculateMinMaxPositions(O,0,O.length/w,this._convertToRightHandedSystem));var L=z._GLTFUtilities._CreateAccessor(C,d+" - "+t.name,D.accessorType,5126,O.length/w,0,i.min,i.max);this._accessors.push(L),this.setAttributeKind(S,d),null==S.attributes.TEXCOORD_0&&null==S.attributes.TEXCOORD_1||(a=!0)}}if(u&&(L=z._GLTFUtilities._CreateAccessor(u,"indices - "+t.name,"SCALAR",5125,A.indexCount,4*A.indexStart,null,null),this._accessors.push(L),S.indices=this._accessors.length-1),null!=F&&0<Object.keys(S.attributes).length){var P=b.sideOrientation;if(this._convertToRightHandedSystem&&P===W.Material.ClockWiseSideOrientation){var N=null!=u?this._bufferViews[u].byteOffset:null;null==N&&(N=0);var G=null;if(null!=u&&(G=s.getIndices()),G)this.reorderIndicesBasedOnPrimitiveMode(A,c,G,N,r);else for(var I=0,U=l;I<U.length;I++){var O,D=U[I];if(O=s.getVerticesData(D.kind)){var k=this._bufferViews[f[D.kind]].byteOffset;k||(k=0),this.reorderVertexAttributeDataBasedOnPrimitiveMode(A,c,P,D.kind,O,k,r)}}}if(!a&&this._glTFMaterialExporter._hasTexturesPresent(this._materials[F])){var K=this._glTFMaterialExporter._stripTexturesFromMaterial(this._materials[F]);this._materials.push(K),F=this._materials.length-1}S.material=F}e.primitives.push(S),this._extensionsPostExportMeshPrimitiveAsync("postExport",S,A,r)&&o.push()}}return Promise.all(o).then((function(){}))},u.prototype.createSceneAsync=function(e,l){var u,c,f,h=this,p={nodes:[]},d=e.transformNodes.concat(e.meshes);return this._glTFMaterialExporter._convertMaterialsToGLTFAsync(e.materials,"image/png",!0).then((function(){return h.createNodeMapAndAnimationsAsync(e,d,h._shouldExportTransformNode,l).then((function(e){if(h._nodeMap=e,h._totalByteLength=l.getByteOffset(),null==h._totalByteLength)throw new Error("undefined byte length!");for(var t=0,r=d;t<r.length;t++){var n=r[t];if(null!=(u=h._nodeMap[n.uniqueId])&&(c=h._nodes[u],n.parent||(h._shouldExportTransformNode(n)?(h._convertToRightHandedSystem&&(c.translation&&(c.translation[2]*=-1,c.translation[0]*=-1),c.rotation=c.rotation?W.Quaternion.FromArray([0,1,0,0]).multiply(W.Quaternion.FromArray(c.rotation)).asArray():W.Quaternion.FromArray([0,1,0,0]).asArray()),p.nodes.push(u)):W.Tools.Log("Omitting "+n.name+" from scene.")),f=n.getDescendants(!0),!c.children&&f&&f.length)){for(var a=[],i=0,o=f;i<o.length;i++){var s=o[i];null!=h._nodeMap[s.uniqueId]&&a.push(h._nodeMap[s.uniqueId])}a.length&&(c.children=a)}}p.nodes.length&&h._scenes.push(p)}))}))},u.prototype.createNodeMapAndAnimationsAsync=function(r,e,n,a){for(var i,o=this,s=Promise.resolve(),l={},u={name:"runtime animations",channels:[],samplers:[]},c=[],t=function(t){n(t)?s=s.then((function(){return o.createNodeAsync(t,a).then((function(e){(t.getDescendants(!0,(function(e){return e instanceof W.TransformNode})).length||null!=e.mesh)&&(o._nodes.push(e),i=o._nodes.length-1,l[t.uniqueId]=i),!r.animationGroups.length&&t.animations.length&&z._GLTFAnimation._CreateNodeAnimationFromTransformNodeAnimations(t,u,c,l,o._nodes,a,o._bufferViews,o._accessors,o._convertToRightHandedSystem,o._animationSampleRate)}))})):t.name},f=0,h=e;f<h.length;f++)t(h[f]);return s.then((function(){return u.channels.length&&u.samplers.length&&o._animations.push(u),c.forEach((function(e){e.channels.length&&e.samplers.length&&o._animations.push(e)})),r.animationGroups.length&&z._GLTFAnimation._CreateNodeAnimationFromAnimationGroups(r,o._animations,l,o._nodes,a,o._bufferViews,o._accessors,o._convertToRightHandedSystem,o._animationSampleRate),l}))},u.prototype.createNodeAsync=function(r,n){var a=this;return Promise.resolve().then((function(){var e={},t={primitives:[]};return r.name&&(e.name=r.name),a.setNodeTransformation(e,r),a.setPrimitiveAttributesAsync(t,r,n).then((function(){return t.primitives.length&&(a._meshes.push(t),e.mesh=a._meshes.length-1),e}))}))},u._ExtensionNames=new Array,u._ExtensionFactories={},u})();z._Exporter=e;var r=(function(){function e(e){this._arrayBuffer=new ArrayBuffer(e),this._dataView=new DataView(this._arrayBuffer),this._byteOffset=0}return e.prototype.resizeBuffer=function(e){for(var t=new ArrayBuffer(e),r=new Uint8Array(this._arrayBuffer),n=new Uint8Array(t),a=0,i=n.byteLength;a<i;++a)n[a]=r[a];return this._arrayBuffer=t,this._dataView=new DataView(this._arrayBuffer),t},e.prototype.getArrayBuffer=function(){return this.resizeBuffer(this.getByteOffset())},e.prototype.getByteOffset=function(){if(null==this._byteOffset)throw new Error("Byte offset is undefined!");return this._byteOffset},e.prototype.setUInt8=function(e,t){null!=t?t<this._byteOffset?this._dataView.setUint8(t,e):W.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._byteOffset+1>this._arrayBuffer.byteLength&&this.resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setUint8(this._byteOffset++,e))},e.prototype.getUInt32=function(e){if(e<this._byteOffset)return this._dataView.getUint32(e,!0);throw W.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"),new Error("BinaryWriter: byteoffset is greater than the current binary buffer length!")},e.prototype.getVector3Float32FromRef=function(e,t){t+8>this._byteOffset?W.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(e.x=this._dataView.getFloat32(t,!0),e.y=this._dataView.getFloat32(t+4,!0),e.z=this._dataView.getFloat32(t+8,!0))},e.prototype.setVector3Float32FromRef=function(e,t){t+8>this._byteOffset?W.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._dataView.setFloat32(t,e.x,!0),this._dataView.setFloat32(t+4,e.y,!0),this._dataView.setFloat32(t+8,e.z,!0))},e.prototype.getVector4Float32FromRef=function(e,t){t+12>this._byteOffset?W.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(e.x=this._dataView.getFloat32(t,!0),e.y=this._dataView.getFloat32(t+4,!0),e.z=this._dataView.getFloat32(t+8,!0),e.w=this._dataView.getFloat32(t+12,!0))},e.prototype.setVector4Float32FromRef=function(e,t){t+12>this._byteOffset?W.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._dataView.setFloat32(t,e.x,!0),this._dataView.setFloat32(t+4,e.y,!0),this._dataView.setFloat32(t+8,e.z,!0),this._dataView.setFloat32(t+12,e.w,!0))},e.prototype.setFloat32=function(e,t){isNaN(e)&&W.Tools.Error("Invalid data being written!"),null!=t&&(t<this._byteOffset?this._dataView.setFloat32(t,e,!0):W.Tools.Error("BinaryWriter: byteoffset is greater than the current binary length!")),this._byteOffset+4>this._arrayBuffer.byteLength&&this.resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setFloat32(this._byteOffset,e,!0),this._byteOffset+=4},e.prototype.setUInt32=function(e,t){null!=t?t<this._byteOffset?this._dataView.setUint32(t,e,!0):W.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._byteOffset+4>this._arrayBuffer.byteLength&&this.resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setUint32(this._byteOffset,e,!0),this._byteOffset+=4)},e})();z._BinaryWriter=r})((e=W.GLTF2||(W.GLTF2={})).Exporter||(e.Exporter={}))})(BABYLON||(BABYLON={})),(function(e){var t=(function(){function e(){this.glTFFiles={}}return e.prototype.downloadFiles=function(){function e(e,t){return-1!==e.indexOf(t,e.length-t.length)}for(var t in this.glTFFiles){var r=document.createElement("a");document.body.appendChild(r),r.setAttribute("type","hidden"),r.download=t;var n=this.glTFFiles[t],a=void 0;e(t,".glb")?a={type:"model/gltf-binary"}:e(t,".bin")?a={type:"application/octet-stream"}:e(t,".gltf")?a={type:"model/gltf+json"}:e(t,".jpeg")?a={type:"image/jpeg"}:e(t,".png")&&(a={type:"image/png"}),r.href=window.URL.createObjectURL(new Blob([n],a)),r.click()}},e})();e.GLTFData=t})(BABYLON||(BABYLON={})),(function(L){var e,t,r;e=L.GLTF2||(L.GLTF2={}),t=e.Exporter||(e.Exporter={}),r=(function(){function C(e){this._textureMap={},this._textureMap={},this._exporter=e}return C.FuzzyEquals=function(e,t,r){return L.Scalar.WithinEpsilon(e.r,t.r,r)&&L.Scalar.WithinEpsilon(e.g,t.g,r)&&L.Scalar.WithinEpsilon(e.b,t.b,r)},C.prototype._convertMaterialsToGLTFAsync=function(e,t,r){for(var n=[],a=0,i=e;a<i.length;a++){var o=i[a];o instanceof L.StandardMaterial?n.push(this._convertStandardMaterialAsync(o,t,r)):o instanceof L.PBRMetallicRoughnessMaterial?n.push(this._convertPBRMetallicRoughnessMaterialAsync(o,t,r)):o instanceof L.PBRMaterial?n.push(this._convertPBRMaterialAsync(o,t,r)):L.Tools.Warn("Unsupported material type: "+o.name)}return Promise.all(n).then((function(){}))},C.prototype._stripTexturesFromMaterial=function(e){var t={};if(e){t.name=e.name,t.doubleSided=e.doubleSided,t.alphaMode=e.alphaMode,t.alphaCutoff=e.alphaCutoff,t.emissiveFactor=e.emissiveFactor;var r=e.pbrMetallicRoughness;r&&(t.pbrMetallicRoughness={},t.pbrMetallicRoughness.baseColorFactor=r.baseColorFactor,t.pbrMetallicRoughness.metallicFactor=r.metallicFactor,t.pbrMetallicRoughness.roughnessFactor=r.roughnessFactor)}return t},C.prototype._hasTexturesPresent=function(e){if(e.emissiveTexture||e.normalTexture||e.occlusionTexture)return!0;var t=e.pbrMetallicRoughness;return!(!t||!t.baseColorTexture&&!t.metallicRoughnessTexture)},C.prototype._convertToGLTFPBRMetallicRoughness=function(e){var t,r,n,a,i,o,s,l=new L.Vector2(0,1),u=new L.Vector2(0,.1),c=new L.Vector2(0,.1),f=new L.Vector2(1300,.1),h=e.diffuseColor.toLinearSpace().scale(.5),p=e.alpha,d=L.Scalar.Clamp(e.specularPower,0,C._MaxSpecularPower),m=(t=d,s=Math.pow(t/f.x,.333333),r=s,n=l.y,a=u.y,i=c.y,o=f.y,(1-r)*(1-r)*(1-r)*n+3*(1-r)*(1-r)*r*a+3*(1-r)*r*r*i+r*r*r*o);return{baseColorFactor:[h.r,h.g,h.b,p],metallicFactor:0,roughnessFactor:m}},C._SolveMetallic=function(e,t,r){if(t<this._DielectricSpecular.r)return this._DielectricSpecular,0;var n=this._DielectricSpecular.r,a=e*r/(1-this._DielectricSpecular.r)+t-2*this._DielectricSpecular.r,i=a*a-4*n*(this._DielectricSpecular.r-t);return L.Scalar.Clamp((-a+Math.sqrt(i))/(2*n),0,1)},C.prototype._getAlphaMode=function(e){return e.needAlphaBlending()?"BLEND":e.needAlphaTesting()?"MASK":"OPAQUE"},C.prototype._convertStandardMaterialAsync=function(t,e,r){var n=this._exporter._materialMap,a=this._exporter._materials,i=this._getAlphaMode(t),o=[],s=this._convertToGLTFPBRMetallicRoughness(t),l={name:t.name};if(null==t.backFaceCulling||t.backFaceCulling||(t.twoSidedLighting||L.Tools.Warn(t.name+": Back-face culling enabled and two-sided lighting disabled is not supported in glTF."),l.doubleSided=!0),r&&(t.diffuseTexture&&o.push(this._exportTextureAsync(t.diffuseTexture,e).then((function(e){e&&(s.baseColorTexture=e)}))),t.bumpTexture&&o.push(this._exportTextureAsync(t.bumpTexture,e).then((function(e){e&&(l.normalTexture=e,null!=t.bumpTexture&&1!==t.bumpTexture.level&&(l.normalTexture.scale=t.bumpTexture.level))}))),t.emissiveTexture&&(l.emissiveFactor=[1,1,1],o.push(this._exportTextureAsync(t.emissiveTexture,e).then((function(e){e&&(l.emissiveTexture=e)})))),t.ambientTexture&&o.push(this._exportTextureAsync(t.ambientTexture,e).then((function(e){if(e){var t={index:e.index};(l.occlusionTexture=t).strength=1}})))),(t.alpha<1||t.opacityTexture)&&(t.alphaMode===L.Engine.ALPHA_COMBINE?l.alphaMode="BLEND":L.Tools.Warn(t.name+": glTF 2.0 does not support alpha mode: "+t.alphaMode.toString())),t.emissiveColor&&!C.FuzzyEquals(t.emissiveColor,L.Color3.Black(),C._Epsilon)&&(l.emissiveFactor=t.emissiveColor.asArray()),l.pbrMetallicRoughness=s,"OPAQUE"!==i)switch(i){case"BLEND":l.alphaMode="BLEND";break;case"MASK":l.alphaMode="MASK",l.alphaCutoff=t.alphaCutOff;break;default:L.Tools.Warn("Unsupported alpha mode "+i)}return a.push(l),n[t.uniqueId]=a.length-1,Promise.all(o).then((function(){}))},C.prototype._convertPBRMetallicRoughnessMaterialAsync=function(t,e,r){var n=this._exporter._materialMap,a=this._exporter._materials,i=[],o={};t.baseColor&&(o.baseColorFactor=[t.baseColor.r,t.baseColor.g,t.baseColor.b,t.alpha]),null!=t.metallic&&1!==t.metallic&&(o.metallicFactor=t.metallic),null!=t.roughness&&1!==t.roughness&&(o.roughnessFactor=t.roughness);var s={name:t.name};t.doubleSided&&(s.doubleSided=t.doubleSided);var l=null;return null!=t.transparencyMode&&(l=this._getAlphaMode(t))&&"OPAQUE"!==l&&"MASK"===(s.alphaMode=l)&&(s.alphaCutoff=t.alphaCutOff),r&&(null!=t.baseTexture&&i.push(this._exportTextureAsync(t.baseTexture,e).then((function(e){e&&(o.baseColorTexture=e)}))),t.normalTexture&&i.push(this._exportTextureAsync(t.normalTexture,e).then((function(e){e&&(s.normalTexture=e,1!==t.normalTexture.level&&(s.normalTexture.scale=t.normalTexture.level))}))),t.occlusionTexture&&i.push(this._exportTextureAsync(t.occlusionTexture,e).then((function(e){e&&(s.occlusionTexture=e,null!=t.occlusionStrength&&(s.occlusionTexture.strength=t.occlusionStrength))}))),t.emissiveTexture&&i.push(this._exportTextureAsync(t.emissiveTexture,e).then((function(e){e&&(s.emissiveTexture=e)})))),C.FuzzyEquals(t.emissiveColor,L.Color3.Black(),C._Epsilon)&&(s.emissiveFactor=t.emissiveColor.asArray()),s.pbrMetallicRoughness=o,a.push(s),n[t.uniqueId]=a.length-1,Promise.all(i).then((function(){}))},C.prototype._createBase64FromCanvasAsync=function(t,l,u,e){var c=this;return new Promise(function(r,n){var a,e=L.Engine.TEXTURETYPE_UNSIGNED_INT,i=c._exporter._getLocalEngine();a=new L.Scene(i);var o=i.createRawTexture(t,l,u,L.Engine.TEXTUREFORMAT_RGBA,!1,!0,L.Texture.NEAREST_SAMPLINGMODE,null,e),s=new L.PostProcess("pass","pass",null,null,1,null,L.Texture.NEAREST_SAMPLINGMODE,i,!1,void 0,L.Engine.TEXTURETYPE_UNSIGNED_INT,void 0,null,!1);s.getEffect().executeWhenCompiled((function(){s.onApply=function(e){e._bindTexture("textureSampler",o)},i.setSize(l,u),a.postProcessManager.directRender([s],null),s.dispose(),o.dispose();var e=i.getRenderingCanvas();if(e)if(e.toBlob)L.Tools.ToBlob(e,(function(e){if(e){var t=new FileReader;t.onload=function(e){var t=e.target.result;a.dispose(),r(t)},t.readAsDataURL(e)}else n("gltfMaterialExporter: Failed to get blob from image canvas!")}));else{var t=e.toDataURL();r(t)}else n("Engine is missing a canvas!")}))})},C.prototype._createWhiteTexture=function(e,t,r){for(var n=new Uint8Array(e*t*4),a=0;a<n.length;a+=4)n[a]=n[a+1]=n[a+2]=n[a+3]=255;return L.RawTexture.CreateRGBATexture(n,e,t,r)},C.prototype._resizeTexturesToSameDimensions=function(e,t,r){var n,a,i=e?e.getSize():{width:0,height:0},o=t?t.getSize():{width:0,height:0};return i.width<o.width?(n=e&&e instanceof L.Texture?L.TextureTools.CreateResizedCopy(e,o.width,o.height,!0):this._createWhiteTexture(o.width,o.height,r),a=t):i.width>o.width?(a=t&&t instanceof L.Texture?L.TextureTools.CreateResizedCopy(t,i.width,i.height,!0):this._createWhiteTexture(i.width,i.height,r),n=e):(n=e,a=t),{texture1:n,texture2:a}},C.prototype._convertPixelArrayToFloat32=function(e){if(e instanceof Uint8Array){for(var t=e.length,r=new Float32Array(e.length),n=0;n<t;++n)r[n]=e[n]/255;return r}if(e instanceof Float32Array)return e;throw new Error("Unsupported pixel format!")},C.prototype._convertSpecularGlossinessTexturesToMetallicRoughnessAsync=function(e,t,r,n){var a=[];if(!e&&!t)return Promise.reject("_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!");var i=e?e.getScene():t?t.getScene():null;if(i){var o=this._resizeTexturesToSameDimensions(e,t,i),s=o.texture1.getSize(),l=void 0,u=void 0,c=s.width,f=s.height,h=o.texture1.readPixels(),p=o.texture2.readPixels();if(!h)return Promise.reject("Failed to retrieve pixels from diffuse texture!");if(l=this._convertPixelArrayToFloat32(h),!p)return Promise.reject("Failed to retrieve pixels from specular glossiness texture!");for(var d=(u=this._convertPixelArrayToFloat32(p)).byteLength,m=new Uint8Array(d),g=new Uint8Array(d),_=L.Color3.Black(),y=0,T=0,x=0;x<f;++x)for(var v=0;v<c;++v){var A=4*(c*x+v),b={diffuseColor:new L.Color3(l[A],l[A+1],l[A+2]).toLinearSpace().multiply(r.diffuseColor),specularColor:new L.Color3(u[A],u[A+1],u[A+2]).toLinearSpace().multiply(r.specularColor),glossiness:u[A+3]*r.glossiness},F=this._convertSpecularGlossinessToMetallicRoughness(b);_.r=Math.max(_.r,F.baseColor.r),_.g=Math.max(_.g,F.baseColor.g),_.b=Math.max(_.b,F.baseColor.b),y=Math.max(y,F.metallic),T=Math.max(T,F.roughness),g[A]=255*F.baseColor.r,g[A+1]=255*F.baseColor.g,g[A+2]=255*F.baseColor.b,g[A+3]=o.texture1.hasAlpha?255*l[A+3]:255,m[A]=0,m[A+1]=255*F.roughness,m[A+2]=255*F.metallic,m[A+3]=255}var E={baseColor:_,metallic:y,roughness:T},M=!1,R=!1;for(x=0;x<f;++x)for(v=0;v<c;++v){var S=4*(c*x+v);g[S]/=E.baseColor.r>C._Epsilon?E.baseColor.r:1,g[S+1]/=E.baseColor.g>C._Epsilon?E.baseColor.g:1,g[S+2]/=E.baseColor.b>C._Epsilon?E.baseColor.b:1;var V=L.Color3.FromInts(g[S],g[S+1],g[S+2]).toGammaSpace();g[S]=255*V.r,g[S+1]=255*V.g,g[S+2]=255*V.b,C.FuzzyEquals(V,L.Color3.White(),C._Epsilon)||(R=!0),m[S+1]/=E.roughness>C._Epsilon?E.roughness:1,m[S+2]/=E.metallic>C._Epsilon?E.metallic:1;var B=L.Color3.FromInts(255,m[S+1],m[S+2]);C.FuzzyEquals(B,L.Color3.White(),C._Epsilon)||(M=!0)}if(M){var w=this._createBase64FromCanvasAsync(m,c,f,n).then((function(e){E.metallicRoughnessTextureBase64=e}));a.push(w)}return R&&(w=this._createBase64FromCanvasAsync(g,c,f,n).then((function(e){E.baseColorTextureBase64=e})),a.push(w)),Promise.all(a).then((function(){return E}))}return Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")},C.prototype._convertSpecularGlossinessToMetallicRoughness=function(e){var t=this._getPerceivedBrightness(e.diffuseColor),r=this._getPerceivedBrightness(e.specularColor),n=1-this._getMaxComponent(e.specularColor),a=C._SolveMetallic(t,r,n),i=e.diffuseColor.scale(n/(1-C._DielectricSpecular.r)/Math.max(1-a,C._Epsilon)),o=e.specularColor.subtract(C._DielectricSpecular.scale(1-a)).scale(1/Math.max(a,C._Epsilon)),s=L.Color3.Lerp(i,o,a*a);return{baseColor:s=s.clampToRef(0,1,s),metallic:a,roughness:1-e.glossiness}},C.prototype._getPerceivedBrightness=function(e){return e?Math.sqrt(.299*e.r*e.r+.587*e.g*e.g+.114*e.b*e.b):0},C.prototype._getMaxComponent=function(e){return e?Math.max(e.r,Math.max(e.g,e.b)):0},C.prototype._convertMetalRoughFactorsToMetallicRoughnessAsync=function(e,t,r,n){var a=[],i={baseColor:e.albedoColor,metallic:e.metallic,roughness:e.roughness};return n&&(e.albedoTexture&&a.push(this._exportTextureAsync(e.albedoTexture,t).then((function(e){e&&(r.baseColorTexture=e)}))),e.metallicTexture&&a.push(this._exportTextureAsync(e.metallicTexture,t).then((function(e){e&&(r.metallicRoughnessTexture=e)})))),Promise.all(a).then((function(){return i}))},C.prototype._getGLTFTextureSampler=function(e){var t=this._getGLTFTextureWrapModesSampler(e),r=e instanceof L.Texture?e.samplingMode:null;if(null!=r)switch(r){case L.Texture.LINEAR_LINEAR:t.magFilter=9729,t.minFilter=9729;break;case L.Texture.LINEAR_NEAREST:t.magFilter=9729,t.minFilter=9728;break;case L.Texture.NEAREST_LINEAR:t.magFilter=9728,t.minFilter=9729;break;case L.Texture.NEAREST_LINEAR_MIPLINEAR:t.magFilter=9728,t.minFilter=9987;break;case L.Texture.NEAREST_NEAREST:t.magFilter=9728,t.minFilter=9728;break;case L.Texture.NEAREST_LINEAR_MIPNEAREST:t.magFilter=9728,t.minFilter=9985;break;case L.Texture.LINEAR_NEAREST_MIPNEAREST:t.magFilter=9729,t.minFilter=9984;break;case L.Texture.LINEAR_NEAREST_MIPLINEAR:t.magFilter=9729,t.minFilter=9986;break;case L.Texture.NEAREST_NEAREST_MIPLINEAR:t.magFilter=9728,t.minFilter=9986;break;case L.Texture.LINEAR_LINEAR_MIPLINEAR:t.magFilter=9729,t.minFilter=9987;break;case L.Texture.LINEAR_LINEAR_MIPNEAREST:t.magFilter=9729,t.minFilter=9985;break;case L.Texture.NEAREST_NEAREST_MIPNEAREST:t.magFilter=9728,t.minFilter=9984}return t},C.prototype._getGLTFTextureWrapMode=function(e){switch(e){case L.Texture.WRAP_ADDRESSMODE:return 10497;case L.Texture.CLAMP_ADDRESSMODE:return 33071;case L.Texture.MIRROR_ADDRESSMODE:return 33648;default:return L.Tools.Error("Unsupported Texture Wrap Mode "+e+"!"),10497}},C.prototype._getGLTFTextureWrapModesSampler=function(e){var t=this._getGLTFTextureWrapMode(e instanceof L.Texture?e.wrapU:L.Texture.WRAP_ADDRESSMODE),r=this._getGLTFTextureWrapMode(e instanceof L.Texture?e.wrapV:L.Texture.WRAP_ADDRESSMODE);return 10497===t&&10497===r?{}:{wrapS:t,wrapT:r}},C.prototype._convertSpecGlossFactorsToMetallicRoughnessAsync=function(i,o,s,l){var u=this;return Promise.resolve().then((function(){var e=u._exporter._samplers,n=u._exporter._textures,t={diffuseColor:i.albedoColor||L.Color3.White(),specularColor:i.reflectivityColor||L.Color3.White(),glossiness:i.microSurface||1},a=null,r=u._getGLTFTextureSampler(i.albedoTexture);return null!=r.magFilter&&null!=r.minFilter&&null!=r.wrapS&&null!=r.wrapT&&(e.push(r),a=e.length-1),i.reflectivityTexture&&!i.useMicroSurfaceFromReflectivityMapAlpha?Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported"):(i.albedoTexture||i.reflectivityTexture)&&l?u._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(i.albedoTexture,i.reflectivityTexture,t,o).then((function(e){if(e.baseColorTextureBase64){var t=u._getTextureInfoFromBase64(e.baseColorTextureBase64,"bjsBaseColorTexture_"+n.length+".png",o,i.albedoTexture?i.albedoTexture.coordinatesIndex:null,a);t&&(s.baseColorTexture=t)}if(e.metallicRoughnessTextureBase64){var r=u._getTextureInfoFromBase64(e.metallicRoughnessTextureBase64,"bjsMetallicRoughnessTexture_"+n.length+".png",o,i.reflectivityTexture?i.reflectivityTexture.coordinatesIndex:null,a);r&&(s.metallicRoughnessTexture=r)}return e})):u._convertSpecularGlossinessToMetallicRoughness(t)}))},C.prototype._convertPBRMaterialAsync=function(t,r,n){var a=this,i={},o={name:t.name};return t.isMetallicWorkflow()?(t.albedoColor&&(i.baseColorFactor=[t.albedoColor.r,t.albedoColor.g,t.albedoColor.b,t.alpha]),this._convertMetalRoughFactorsToMetallicRoughnessAsync(t,r,i,n).then((function(e){return a.setMetallicRoughnessPbrMaterial(e,t,o,i,r,n)}))):this._convertSpecGlossFactorsToMetallicRoughnessAsync(t,r,i,n).then((function(e){return a.setMetallicRoughnessPbrMaterial(e,t,o,i,r,n)}))},C.prototype.setMetallicRoughnessPbrMaterial=function(e,r,n,t,a,i){var o=this._exporter._materialMap,s=this._exporter._materials,l=[];if(e){var u=null;if(null!=r.transparencyMode&&(u=this._getAlphaMode(r))&&"OPAQUE"!==u&&"MASK"===(n.alphaMode=u)&&(n.alphaCutoff=r.alphaCutOff),C.FuzzyEquals(e.baseColor,L.Color3.White(),C._Epsilon)&&r.alpha>=C._Epsilon||(t.baseColorFactor=[e.baseColor.r,e.baseColor.g,e.baseColor.b,r.alpha]),null!=e.metallic&&1!==e.metallic&&(t.metallicFactor=e.metallic),null!=e.roughness&&1!==e.roughness&&(t.roughnessFactor=e.roughness),null==r.backFaceCulling||r.backFaceCulling||(r.twoSidedLighting||L.Tools.Warn(r.name+": Back-face culling enabled and two-sided lighting disabled is not supported in glTF."),n.doubleSided=!0),i){if(r.bumpTexture){var c=this._exportTextureAsync(r.bumpTexture,a).then((function(e){e&&(n.normalTexture=e,1!==r.bumpTexture.level&&(n.normalTexture.scale=r.bumpTexture.level))}));l.push(c)}r.ambientTexture&&(c=this._exportTextureAsync(r.ambientTexture,a).then((function(e){if(e){var t={index:e.index};n.occlusionTexture=t,r.ambientTextureStrength&&(t.strength=r.ambientTextureStrength)}})),l.push(c)),r.emissiveTexture&&(c=this._exportTextureAsync(r.emissiveTexture,a).then((function(e){e&&(n.emissiveTexture=e)})),l.push(c))}C.FuzzyEquals(r.emissiveColor,L.Color3.Black(),C._Epsilon)||(n.emissiveFactor=r.emissiveColor.asArray()),n.pbrMetallicRoughness=t,s.push(n),o[r.uniqueId]=s.length-1}return Promise.all(l).then((function(e){}))},C.prototype.getPixelsFromTexture=function(e){return e.textureType,L.Engine.TEXTURETYPE_UNSIGNED_INT,e.readPixels()},C.prototype._exportTextureAsync=function(t,r){var n=this,e=this._exporter._extensionsPreExportTextureAsync("exporter",t,r);return e?e.then((function(e){return e?n._exportTextureInfoAsync(e,r):n._exportTextureInfoAsync(t,r)})):this._exportTextureInfoAsync(t,r)},C.prototype._exportTextureInfoAsync=function(u,c){var f=this;return Promise.resolve().then((function(){var r=u.uid;if(r in f._textureMap)return f._textureMap[r];for(var e=f._exporter._samplers,t=f._getGLTFTextureSampler(u),n=null,a=null,i=0;i<e.length;++i){var o=e[i];if(o.minFilter===t.minFilter&&o.magFilter===t.magFilter&&o.wrapS===t.wrapS&&o.wrapT===t.wrapT){a=i;break}}n=null==a?(e.push(t),e.length-1):a;var s=f.getPixelsFromTexture(u),l=u.getSize();return f._createBase64FromCanvasAsync(s,l.width,l.height,c).then((function(e){var t=f._getTextureInfoFromBase64(e,u.name.replace(/\.\/|\/|\.\\|\\/g,"_"),c,u.coordinatesIndex,n);return t&&(f._textureMap[r]=t),t}))}))},C.prototype._getTextureInfoFromBase64=function(e,t,r,n,a){var i=this._exporter._textures,o=this._exporter._images,s=this._exporter._imageData,l=null,u={source:o.length,name:t};null!=a&&(u.sampler=a);for(var c=atob(e.split(",")[1]),f=new ArrayBuffer(c.length),h=new Uint8Array(f),p=0,d=c.length;p<d;++p)h[p]=c.charCodeAt(p);var m={data:h,mimeType:r},g="image/jpeg"===r?".jpeg":".png",_=t+g;if(_ in s&&(_=t+"_"+L.Tools.RandomId()+g),s[_]=m,"image/jpeg"===r||"image/png"===r){var y={name:t,uri:_},T=null;for(p=0;p<o.length;++p)if(o[p].uri===_){T=p;break}u.source=null==T?(o.push(y),o.length-1):T,i.push(u),l={index:i.length-1},null!=n&&(l.texCoord=n)}else L.Tools.Error("Unsupported texture mime type "+r);return l},C._DielectricSpecular=new L.Color3(.04,.04,.04),C._MaxSpecularPower=1024,C._Epsilon=1e-6,C})(),t._GLTFMaterialExporter=r})(BABYLON||(BABYLON={})),(function(M){var e;(function(b){var h,e;(e=h||(h={}))[e.INTANGENT=0]="INTANGENT",e[e.OUTTANGENT=1]="OUTTANGENT";var t=(function(){function E(){}return E._CreateNodeAnimation=function(e,t,r,n,a,i){var o=[],s=[],l=t.getKeys(),u=E.calculateMinMaxKeyFrames(l),c=E._DeduceInterpolation(l,r,a),f=u.max-u.min,h=c.interpolationType,p=c.shouldBakeAnimation;return p?E._CreateBakedAnimation(e,t,r,u.min,u.max,t.framePerSecond,i,o,s,u,n,a):"LINEAR"===h||"STEP"===h?E._CreateLinearOrStepAnimation(e,t,r,f,o,s,n,a):"CUBICSPLINE"===h?E._CreateCubicSplineAnimation(e,t,r,f,o,s,n,a):E._CreateBakedAnimation(e,t,r,u.min,u.max,t.framePerSecond,i,o,s,u,n,a),o.length&&s.length?{inputs:o,outputs:s,samplerInterpolation:h,inputsMin:p?u.min:M.Tools.FloatRound(u.min/t.framePerSecond),inputsMax:p?u.max:M.Tools.FloatRound(u.max/t.framePerSecond)}:null},E._DeduceAnimationInfo=function(e){var t=null,r="VEC3",n=!1,a=e.targetProperty.split(".");switch(a[0]){case"scaling":t="scale";break;case"position":t="translation";break;case"rotation":r="VEC4",t="rotation";break;case"rotationQuaternion":r="VEC4",n=!0,t="rotation";break;default:M.Tools.Error("Unsupported animatable property "+a[0])}return t?{animationChannelTargetPath:t,dataAccessorType:r,useQuaternion:n}:(M.Tools.Error("animation channel target path and data accessor type could be deduced"),null)},E._CreateNodeAnimationFromTransformNodeAnimations=function(e,t,r,n,a,i,o,s,l,u){var c;if(e.animations)for(var f=0,h=e.animations;f<h.length;f++){var p=h[f],d=E._DeduceAnimationInfo(p);d&&(c={name:p.name,samplers:[],channels:[]},E.AddAnimation(""+p.name,p.hasRunningRuntimeAnimations?t:c,e,p,d.dataAccessorType,d.animationChannelTargetPath,n,i,o,s,l,d.useQuaternion,u),c.samplers.length&&c.channels.length&&r.push(c))}},E._CreateNodeAnimationFromAnimationGroups=function(e,t,r,n,a,i,o,s,l){var u;if(e.animationGroups)for(var c=0,f=e.animationGroups;c<f.length;c++){var h=f[c];u={name:h.name,channels:[],samplers:[]};for(var p=0,d=h.targetedAnimations;p<d.length;p++){var m=d[p],g=m.target,_=m.animation;if(g instanceof M.Mesh||1===g.length&&g[0]instanceof M.Mesh){var y=E._DeduceAnimationInfo(m.animation);if(y){var T=g instanceof M.Mesh?g:g[0];E.AddAnimation(""+_.name,u,T,_,y.dataAccessorType,y.animationChannelTargetPath,r,a,i,o,s,y.useQuaternion,l)}}}u.channels.length&&u.samplers.length&&t.push(u)}},E.AddAnimation=function(e,t,r,n,a,i,o,s,l,u,c,f,h){var p,d,m,g,_,y,T,x=E._CreateNodeAnimation(r,n,i,c,f,h);if(x){var v=o[r.uniqueId],A=4*x.inputs.length;p=b._GLTFUtilities._CreateBufferView(0,s.getByteOffset(),A,void 0,e+"  keyframe data view"),l.push(p),x.inputs.forEach((function(e){s.setFloat32(e)})),d=b._GLTFUtilities._CreateAccessor(l.length-1,e+"  keyframes","SCALAR",5126,x.inputs.length,null,[x.inputsMin],[x.inputsMax]),u.push(d),m=u.length-1,_=x.outputs.length,A="VEC3"===a?12*x.outputs.length:16*x.outputs.length,p=b._GLTFUtilities._CreateBufferView(0,s.getByteOffset(),A,void 0,e+"  data view"),l.push(p),x.outputs.forEach((function(e){e.forEach((function(e){s.setFloat32(e)}))})),d=b._GLTFUtilities._CreateAccessor(l.length-1,e+"  data",a,5126,_,null,null,null),u.push(d),g=u.length-1,y={interpolation:x.samplerInterpolation,input:m,output:g},t.samplers.push(y),T={sampler:t.samplers.length-1,target:{node:v,path:i}},t.channels.push(T)}},E._CreateBakedAnimation=function(e,t,r,n,a,i,o,s,l,u,c,f){var h,p,d=M.Quaternion.Identity(),m=null,g=null,_=null,y=null,T=null,x=null;u.min=M.Tools.FloatRound(n/i);for(var v=t.getKeys(),A=0,b=v.length;A<b;++A){if(x=null,_=v[A],A+1<b)if(y=v[A+1],_.value.equals(y.value)){if(0!==A)continue;x=_.frame}else x=y.frame;else{if(T=v[A-1],_.value.equals(T.value))continue;x=a}if(x)for(var F=_.frame;F<=x;F+=o)(p=M.Tools.FloatRound(F/i))!==m&&(g=m=p,h=t._interpolate(F,0,void 0,t.loopMode),E._SetInterpolatedValue(e,h,p,t,r,d,s,l,c,f))}g&&(u.max=g)},E._ConvertFactorToVector3OrQuaternion=function(e,t,r,n,a,i,o){var s,l,u=null,c=E._GetBasePositionRotationOrScale(t,a,i,o);if(n===M.Animation.ANIMATIONTYPE_FLOAT)switch(l=(s=r.targetProperty.split("."))?s[1]:"",u=o?M.Quaternion.FromArray(c).normalize():M.Vector3.FromArray(c),l){case"x":case"y":u[l]=i&&o&&"scale"!==a?-e:e;break;case"z":u[l]=i&&!o&&"scale"!==a?-e:e;break;case"w":u.w=e;break;default:M.Tools.Error('glTFAnimation: Unsupported component type "'+l+'" for scale animation!')}return u},E._SetInterpolatedValue=function(e,t,r,n,a,i,o,s,l,u){var c,f=n.dataType;o.push(r),"number"==typeof t&&(t=this._ConvertFactorToVector3OrQuaternion(t,e,n,f,a,l,u)),t&&("rotation"===a?(u?i=t:(c=t,M.Quaternion.RotationYawPitchRollToRef(c.y,c.x,c.z,i)),l&&(b._GLTFUtilities._GetRightHandedQuaternionFromRef(i),e.parent||(i=M.Quaternion.FromArray([0,1,0,0]).multiply(i))),s.push(i.asArray())):(c=t,l&&"scale"!==a&&(b._GLTFUtilities._GetRightHandedPositionVector3FromRef(c),e.parent||(c.x*=-1,c.z*=-1)),s.push(c.asArray())))},E._CreateLinearOrStepAnimation=function(e,t,r,n,a,i,o,s){for(var l=0,u=t.getKeys();l<u.length;l++){var c=u[l];a.push(c.frame/t.framePerSecond),E._AddKeyframeValue(c,t,i,r,e,o,s)}},E._CreateCubicSplineAnimation=function(t,r,n,a,i,o,s,l){r.getKeys().forEach((function(e){i.push(e.frame/r.framePerSecond),E.AddSplineTangent(t,h.INTANGENT,o,n,"CUBICSPLINE",e,a,l,s),E._AddKeyframeValue(e,r,o,n,t,s,l),E.AddSplineTangent(t,h.OUTTANGENT,o,n,"CUBICSPLINE",e,a,l,s)}))},E._GetBasePositionRotationOrScale=function(e,t,r,n){var a;return"rotation"===t?n?e.rotationQuaternion?(a=e.rotationQuaternion.asArray(),r&&(b._GLTFUtilities._GetRightHandedQuaternionArrayFromRef(a),e.parent||(a=M.Quaternion.FromArray([0,1,0,0]).multiply(M.Quaternion.FromArray(a)).asArray()))):a=M.Quaternion.Identity().asArray():(a=e.rotation.asArray(),b._GLTFUtilities._GetRightHandedNormalArray3FromRef(a)):"translation"===t?(a=e.position.asArray(),r&&b._GLTFUtilities._GetRightHandedPositionArray3FromRef(a)):a=e.scaling.asArray(),a},E._AddKeyframeValue=function(e,t,r,n,a,i,o){var s,l,u=t.dataType;if(u===M.Animation.ANIMATIONTYPE_VECTOR3){if(s=e.value.asArray(),"rotation"===n){var c=M.Vector3.FromArray(s),f=M.Quaternion.RotationYawPitchRoll(c.y,c.x,c.z);i&&(b._GLTFUtilities._GetRightHandedQuaternionFromRef(f),a.parent||(f=M.Quaternion.FromArray([0,1,0,0]).multiply(f))),s=f.asArray()}else"translation"===n&&i&&(b._GLTFUtilities._GetRightHandedNormalArray3FromRef(s),a.parent||(s[0]*=-1,s[2]*=-1));r.push(s)}else if(u===M.Animation.ANIMATIONTYPE_FLOAT){if(l=this._ConvertFactorToVector3OrQuaternion(e.value,a,t,u,n,i,o)){if("rotation"===n){var h=o?l:M.Quaternion.RotationYawPitchRoll(l.y,l.x,l.z).normalize();i&&(b._GLTFUtilities._GetRightHandedQuaternionFromRef(h),a.parent||(h=M.Quaternion.FromArray([0,1,0,0]).multiply(h))),r.push(h.asArray())}else"translation"===n&&i&&(b._GLTFUtilities._GetRightHandedNormalVector3FromRef(l),a.parent||(l.x*=-1,l.z*=-1));r.push(l.asArray())}}else u===M.Animation.ANIMATIONTYPE_QUATERNION?(s=e.value.normalize().asArray(),i&&(b._GLTFUtilities._GetRightHandedQuaternionArrayFromRef(s),a.parent||(s=M.Quaternion.FromArray([0,1,0,0]).multiply(M.Quaternion.FromArray(s)).asArray())),r.push(s)):M.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")},E._DeduceInterpolation=function(e,t,r){var n,a,i=!1;if("rotation"===t&&!r)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(var o=0,s=e.length;o<s;++o)if((a=e[o]).inTangent||a.outTangent)if(n){if("CUBICSPLINE"!==n){n="LINEAR",i=!0;break}}else n="CUBICSPLINE";else if(n){if("CUBICSPLINE"===n||a.interpolation&&a.interpolation===M.AnimationKeyInterpolation.STEP&&"STEP"!==n){n="LINEAR",i=!0;break}}else n=a.interpolation&&a.interpolation===M.AnimationKeyInterpolation.STEP?"STEP":"LINEAR";return n||(n="LINEAR"),{interpolationType:n,shouldBakeAnimation:i}},E.AddSplineTangent=function(e,t,r,n,a,i,o,s,l){var u,c=t===h.INTANGENT?i.inTangent:i.outTangent;if("CUBICSPLINE"===a){if("rotation"===n)if(c){if(s)u=c.scale(o).asArray();else{var f=c.scale(o);u=M.Quaternion.RotationYawPitchRoll(f.y,f.x,f.z).asArray()}l&&(b._GLTFUtilities._GetRightHandedQuaternionArrayFromRef(u),e.parent||(u=M.Quaternion.FromArray([0,1,0,0]).multiply(M.Quaternion.FromArray(u)).asArray()))}else u=[0,0,0,0];else c?(u=c.scale(o).asArray(),l&&"translation"===n&&(b._GLTFUtilities._GetRightHandedPositionArray3FromRef(u),e.parent||(u[0]*=-1,u[2]*=-1))):u=[0,0,0];r.push(u)}},E.calculateMinMaxKeyFrames=function(e){var t=1/0,r=-1/0;return e.forEach((function(e){t=Math.min(t,e.frame),r=Math.max(r,e.frame)})),{min:t,max:r}},E})();b._GLTFAnimation=t})((e=M.GLTF2||(M.GLTF2={})).Exporter||(e.Exporter={}))})(BABYLON||(BABYLON={})),(function(d){var e,t,r;e=d.GLTF2||(d.GLTF2={}),t=e.Exporter||(e.Exporter={}),r=(function(){function p(){}return p._CreateBufferView=function(e,t,r,n,a){var i={buffer:e,byteLength:r};return t&&(i.byteOffset=t),a&&(i.name=a),n&&(i.byteStride=n),i},p._CreateAccessor=function(e,t,r,n,a,i,o,s){var l={name:t,bufferView:e,componentType:n,count:a,type:r};return null!=o&&(l.min=o),null!=s&&(l.max=s),null!=i&&(l.byteOffset=i),l},p._CalculateMinMaxPositions=function(e,t,r,n){var a,i,o,s=[1/0,1/0,1/0],l=[-1/0,-1/0,-1/0];if(r)for(var u=t,c=t+r;u<c;++u){a=3*u,i=d.Vector3.FromArray(e,a),n&&p._GetRightHandedPositionVector3FromRef(i),o=i.asArray();for(var f=0;f<3;++f){var h=o[f];h<s[f]&&(s[f]=h),h>l[f]&&(l[f]=h),++a}}return{min:s,max:l}},p._GetRightHandedPositionVector3=function(e){return new d.Vector3(e.x,e.y,-e.z)},p._GetRightHandedPositionVector3FromRef=function(e){e.z*=-1},p._GetRightHandedPositionArray3FromRef=function(e){e[2]*=-1},p._GetRightHandedNormalVector3=function(e){return new d.Vector3(e.x,e.y,-e.z)},p._GetRightHandedNormalVector3FromRef=function(e){e.z*=-1},p._GetRightHandedNormalArray3FromRef=function(e){e[2]*=-1},p._GetRightHandedVector4FromRef=function(e){e.z*=-1,e.w*=-1},p._GetRightHandedArray4FromRef=function(e){e[2]*=-1,e[3]*=-1},p._GetRightHandedQuaternionFromRef=function(e){e.x*=-1,e.y*=-1},p._GetRightHandedQuaternionArrayFromRef=function(e){e[0]*=-1,e[1]*=-1},p._NormalizeTangentFromRef=function(e){var t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z);0<t&&(e.x/=t,e.y/=t,e.z/=t)},p})(),t._GLTFUtilities=r})(BABYLON||(BABYLON={})),(function(c){var e,t,r,n,a;e=c.GLTF2||(c.GLTF2={}),t=e.Exporter||(e.Exporter={}),r=t.Extensions||(t.Extensions={}),n="KHR_texture_transform",a=(function(){function e(e){this.name=n,this.enabled=!0,this.required=!1,this._exporter=e}return e.prototype.dispose=function(){delete this._exporter},e.prototype.preExportTextureAsync=function(s,l,e){var u=this;return new Promise(function(t,e){var r={};0===l.uOffset&&0===l.vOffset||(r.offset=[l.uOffset,l.vOffset]),1===l.uScale&&1===l.vScale||(r.scale=[l.uScale,l.vScale]),0!==l.wAng&&(r.rotation=l.wAng),Object.keys(r).length||t(l);var n=r.scale?new c.Vector2(r.scale[0],r.scale[1]):c.Vector2.One(),a=null!=r.rotation?r.rotation:0,i=r.offset?new c.Vector2(r.offset[0],r.offset[1]):c.Vector2.Zero(),o=l.getScene();o?u.textureTransformTextureAsync(l,i,a,n,o).then((function(e){t(e)})):e(s+': "scene" is not defined for Babylon texture '+l.name+"!")})},e.prototype.textureTransformTextureAsync=function(n,e,t,r,a){return new Promise(function(e,t){var r=new c.ProceduralTexture(""+n.name,n.getSize(),"textureTransform",a);r||(c.Tools.Log("Cannot create procedural texture for "+n.name+"!"),e(n)),r.setTexture("textureSampler",n),r.setMatrix("textureTransformMat",n.getTextureMatrix()),r.isReady()?(r.render(),e(r)):r.getEffect().executeWhenCompiled((function(){r.render(),e(r)}))})},e})(),r.KHR_texture_transform=a,t._Exporter.RegisterExtension(n,(function(e){return new a(e)}))})(BABYLON||(BABYLON={}));
>>>>>>> upstream/master
