{"version":3,"sources":["webpack://LOADERS/webpack/universalModuleDefinition","webpack://LOADERS/webpack/bootstrap","webpack://LOADERS/external {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/glTFLoaderV1.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/glTFLoaderInterfaces.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/glTFFileLoader.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/glTFLoaderExtension.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/glTFLoaderUtils.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/legacy.ts","webpack://LOADERS/../node_modules/webpack/buildin/global.js","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/glTFBinaryExtension.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/glTFLoader.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/glTFLoaderExtension.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/glTFLoaderInterfaces.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/Extensions/index.ts","webpack://LOADERS/./src/glTF/2.0/Extensions/EXT_lights_image_based.js","webpack://LOADERS/./src/glTF/2.0/Extensions/KHR_draco_mesh_compression.js","webpack://LOADERS/./src/glTF/2.0/Extensions/KHR_lights_punctual.js","webpack://LOADERS/./src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.js","webpack://LOADERS/./src/glTF/2.0/Extensions/KHR_materials_unlit.js","webpack://LOADERS/./src/glTF/2.0/Extensions/KHR_texture_transform.js","webpack://LOADERS/./src/glTF/2.0/Extensions/MSFT_audio_emitter.js","webpack://LOADERS/./src/glTF/2.0/Extensions/MSFT_lod.js","webpack://LOADERS/./src/glTF/2.0/Extensions/MSFT_minecraftMesh.js","webpack://LOADERS/./src/glTF/2.0/Extensions/MSFT_sRGBFactors.js","webpack://LOADERS/../Tools/Gulp/../../loaders/src/OBJ/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/OBJ/objFileLoader.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/STL/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/STL/stlFileLoader.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ETokenType","glTFLoaderInterfaces_1","glTFLoaderUtils_1","babylonjs_1","glTFFileLoader_1","glTFLoaderExtension_1","Tokenizer","toParse","this","_pos","currentToken","UNKNOWN","currentIdentifier","currentString","isLetterOrDigitPattern","_toParse","_maxPos","length","getNextToken","isEnd","END_OF_INPUT","read","test","IDENTIFIER","peek","forward","glTFTransforms","babylonTransforms","glTFAnimationPaths","babylonAnimationPaths","parseObject","parsedObjects","runtimeProperty","gltfRuntime","parsedObject","normalizeUVs","buffer","getAttribute","attributeParameter","semantic","indexOf","channel","Number","split","configureBoneTransformation","node","mat","translation","rotation","scale","Vector3","FromArray","Quaternion","position","Matrix","Compose","matrix","getParentBone","skins","jointName","newSkeleton","bones","nodes","nde","children","child","bone","Bone","id","getNodeToRoot","nodesToRoot","nodeToRoot","j","getJointNode","nodeIsInJoints","jointNames","importSkeleton","mesh","Skeleton","scene","babylonSkeleton","nodesToRootToAdd","push","k","_parent","getNodesToRoot","jointNode","existingBone","getBoneByID","foundBone","parentBone","jointNode_1","joint","Tools","Warn","prepare","importMesh","meshes","newMesh","Mesh","babylonNode","material","subMaterials","vertexData","verticesStarts","Array","verticesCounts","indexStarts","indexCounts","meshIndex","meshID","primitives","tempVertexData","VertexData","primitive","attributes","accessor","accessors","GLTFUtils","GetBufferFromAccessor","normals","Float32Array","set","GLTFFileLoader","HomogeneousCoordinates","positions","uvKind","VertexBuffer","UVKind","uvs","matricesIndices","matricesWeights","colors","indices","Int32Array","merge","material_1","getMaterialByID","GetDefaultMaterial","MultiMaterial","StandardMaterial","Geometry","computeWorldMatrix","subMeshes","index","SubMesh","AddToMesh","configureNode","newNode","scaling","rotationQuaternion","importNode","parent","lastNode","importOnlyMeshes","skin","importMeshesNames","skeleton","getLastSkeletonByID","light","camera","cameras","type","orthoCamera","FreeCamera","Zero","Camera","ORTHOGRAPHIC_CAMERA","attachControl","getEngine","getRenderingCanvas","perspectiveCamera","persCamera","aspectRatio","getRenderWidth","getRenderHeight","znear","zfar","maxZ","minZ","lights","ambienLight","hemiLight","HemisphericLight","color","diffuse","Color3","directionalLight","dirLight","DirectionalLight","pointLight","ptLight","PointLight","spotLight","spLight","SpotLight","fallOfAngle","angle","fallOffExponent","exponent","dummy","decompose","configureNodeFromMatrix","updateCache","traverseNodes","meshIncluded","postLoad","currentScene","thing","scenes","anim","animations","animation","channels","samplers","lastAnimation","sampler","inputData","outputData","parameters","input","output","bufferInput","bufferOutput","targetID","target","targetNode","getNodeByID","getNodeByName","isBone","targetPath","path","targetPathIndex","animationType","Animation","ANIMATIONTYPE_MATRIX","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_VECTOR3","babylonAnimation","keys","arrayOffset","modifyKey","getKeys","ANIMATIONLOOPMODE_CYCLE","getBaseMatrix","frame","setKeys","stopAnimation","beginAnimation","loadAnimations","skeletons","MAX_VALUE","onShaderCompileSuccess","shaderMaterial","technique","unTreatedUniforms","onSuccess","_","materialValues","values","techniqueUniforms","uniforms","unif","uniform","undefined","onLoadTexture","uniformName","texture","setTexture","EParameterType","SAMPLER_2D","GLTFLoaderExtension","LoadTextureAsync","SetUniform","prepareShaderMaterialUniforms","onBind","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","source","SetMatrix","getEffect","textures","babylonTexture","onBindShaderMaterial","parseShaderUniforms","tokenizer","uniformParameter","transformIndex","importMaterials","materials","LoadMaterialAsync","GLTFLoaderBase","CreateRuntime","parsedData","rootUrl","extensions","buffers","bufferViews","images","shaders","programs","techniques","extensionsUsed","buffersCount","shaderscount","loadedBufferCount","loadedBufferViews","loadedShaderCount","dummyNodes","parsedBuffers","buf","parsedBuffer","parseBuffers","parsedShaders","sha","parsedShader","parseShaders","LoadBufferAsync","onError","onProgress","IsBase64","uri","setTimeout","Uint8Array","DecodeBase64","LoadFile","data","request","status","statusText","LoadTextureBufferAsync","CreateTextureAsync","createMipMaps","minFilter","ETextureFilterType","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","samplingMode","Texture","BILINEAR_SAMPLINGMODE","blob","Blob","blobURL","URL","createObjectURL","revokeBlobURL","revokeObjectURL","newTexture","wrapS","wrapU","GetWrapMode","wrapT","wrapV","LoadShaderStringAsync","shader","shaderString","atob","defaultMaterial","diffuseColor","sideOrientation","Material","CounterClockWiseSideOrientation","program","states","vertexShader","Effect","ShadersStore","pixelShader","fragmentShader","newVertexShader","newPixelShader","vertexTokenizer","pixelTokenizer","attr","attribute","name_1","foundAttribute","shaderPath","vertex","fragment","options","needAlphaBlending","enable","ShaderMaterial","effect","error","dispose","onShaderCompileError","onCompiled","functions","cullFace","ECullingType","BACK","backFaceCulling","blendFunc","blendFuncSeparate","EBlendingFunction","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","alphaMode","Engine","ALPHA_COMBINE","ZERO","ALPHA_ONEONE","ALPHA_ADD","ONE_MINUS_SRC_COLOR","ALPHA_SUBTRACT","DST_COLOR","ALPHA_MULTIPLY","ALPHA_MAXIMIZED","GLTFLoaderV1","state","RegisterExtension","extension","Extensions","Error","_importMeshAsync","meshesNames","_this","useRightHandedSystem","LoadRuntimeAsync","_createNodes","AbstractMesh","skl","_loadBuffersAsync","_loadShadersAsync","IncrementalLoading","importMeshAsync","Promise","resolve","reject","particleSystems","animationGroups","message","_loadAsync","LoadRuntimeExtensionsAsync","loadAsync","onload","hasShaders","processShader","ArrayBuffer","EShaderType","VERTEX","onLoad","hasBuffers","processBuffer","bufferView","byteLength","_CreateGLTFLoaderV1","EComponentType","ETextureWrapMode","ETextureFormat","GLTFLoaderCoordinateSystemMode","GLTFLoaderAnimationStartMode","GLTFLoaderState","onParsedObservable","Observable","coordinateSystemMode","AUTO","animationStartMode","FIRST","compileMaterials","useClipPlane","compileShadowGenerators","transparencyAsCoverage","preprocessUrlAsync","url","onMeshLoadedObservable","onTextureLoadedObservable","onMaterialLoadedObservable","onCameraLoadedObservable","onCompleteObservable","onErrorObservable","onDisposeObservable","onExtensionLoadedObservable","validate","onValidatedObservable","_loader",".gltf","isBinary",".glb","_logIndentLevel","_loggingEnabled","_log","_logDisabled","_capturePerformanceCounters","_startPerformanceCounter","_startPerformanceCounterDisabled","_endPerformanceCounter","_endPerformanceCounterDisabled","callback","_onParsedObserver","remove","add","_onMeshLoadedObserver","_onTextureLoadedObserver","_onMaterialLoadedObserver","_onCameraLoadedObserver","_onCompleteObserver","_onErrorObserver","_onDisposeObserver","_onExtensionLoadedObserver","_logEnabled","_startPerformanceCounterEnabled","_endPerformanceCounterEnabled","_onValidatedObserver","_clear","notifyObservers","clear","fileName","_parseAsync","then","loaderData","_getLoader","loadAssetContainerAsync","result","container","AssetContainer","apply","removeAllFromScene","canDirectLoad","createPlugin","whenCompleteAsync","addOnce","reason","unpacked","_unpackBinary","json","bin","_validateAsync","JSON","parse","GLTFValidator","externalResourceFunction","_loadFileAsync","substr","validateString","asset","version","minVersion","generator","_parseVersion","_compareVersion","major","minor","createLoader","1","2","_CreateGLTFLoaderV2","binaryReader","BinaryReader","magic","readUint32","loggingEnabled","_unpackBinaryV1","_unpackBinaryV2","getLength","content","contentLength","contentFormat","_decodeBufferToText","readUint8Array","bytesRemaining","getPosition","ChunkFormat","chunkLength","chunkLength_1","skipBytes","match","parseInt","a","b","String","fromCharCode","_logOpen","_logClose","spaces","_logSpaces","Log","counterName","StartPerformanceCounter","EndPerformanceCounter","arrayBuffer","_arrayBuffer","_dataView","DataView","_byteOffset","getUint32","SceneLoader","RegisterPlugin","glTFLoaderV1_1","_name","loadRuntimeAsync","loadRuntimeExtensionsAsync","loadBufferAsync","loadTextureBufferAsync","createTextureAsync","loadShaderStringAsync","loadMaterialAsync","ApplyExtensions","loaderExtension","func","defaultFunc","extensionName","parameter","getWorldMatrix","getProjectionMatrix","getViewMatrix","Transpose","multiply","invert","getTransformMatrix","setMatrix2x2","GetAsMatrix2x2","setMatrix3x3","GetAsMatrix3x3","setMatrix","FLOAT","setFloat","FLOAT_VEC2","setVector2","Vector2","FLOAT_VEC3","setVector3","FLOAT_VEC4","setVector4","Vector4","CLAMP_TO_EDGE","CLAMP_ADDRESSMODE","MIRRORED_REPEAT","MIRROR_ADDRESSMODE","REPEAT","WRAP_ADDRESSMODE","GetByteStrideFromType","GetTextureFilterMode","LINEAR","TRILINEAR_SAMPLINGMODE","NEAREST","NEAREST_SAMPLINGMODE","GetBufferFromBufferView","byteOffset","componentType","loadedBufferView","BYTE","Int8Array","UNSIGNED_BYTE","SHORT","Int16Array","UNSIGNED_SHORT","Uint16Array","count","DecodeBufferToText","view","_DefaultMaterial","join","setColor4","Color4","__export","Loaders","globalObject","global","loader","BABYLON","g","Function","eval","e","glTFLoaderV1_2","GLTFBinaryExtension","_super","__extends","_bin","sourceExt","binaryExtensionShader","shaderBytes","_1","GLTFMaterialsCommonExtension","ambientLight","ambient","point","directional","spot","fallOffAngle","Math","PI","standardMaterial","disableLighting","doubleSided","alpha","transparency","specularPower","shininess","_loadTexture","ambientColor","emission","emissiveColor","specular","specularColor","propertyPath","ArrayItem","Get","context","array","Assign","GLTFLoaderV2","_completePromises","_disposed","_state","_extensions","_defaultBabylonMaterialData","_requests","UnregisterExtension","_ExtensionFactories","_ExtensionNames","splice","_i","_a","abort","gltf","babylonScene","_rootBabylonMesh","_progressCallback","_rootUrl","_fileName","_loadData","nodeMap_1","map","_getMeshes","_getSkeletons","_getAnimationGroups","resultFunc","_uniqueRootUrl","Date","now","_loadExtensions","_checkExtensions","loadingToReadyCounterName","LOADING","READY","loadingToCompleteCounterName","COMPLETE","_setState","_extensionsOnLoading","promises","loadSceneAsync","_compileMaterialsAsync","_compileShadowGeneratorsAsync","resultPromise","all","_extensionsOnReady","_startAnimations","SetImmediate","_setupData","binaryBuffer","_data","nodeParents","_b","_c","rootNode","_createRootNode","_d","_e","parentIndex","name_2","extensionsRequired","name_3","enabled","log","_babylonMesh","_LoadTransform","FORCE_RIGHT_HANDED","extensionPromise","_extensionsLoadSceneAsync","logOpen","loadNodeAsync","babylonMesh","_loadAnimationsAsync","logClose","_forEachPrimitive","_primitiveBabylonMeshes","nodes_1","skins_1","_babylonSkeleton","animations_1","_babylonAnimationGroup","NONE","babylonAnimationGroups","start","ALL","babylonAnimationGroups_1","assign","_extensionsLoadNodeAsync","setEnabled","_loadMeshAsync","loadCameraAsync","babylonCamera","childNode","this_1","childBabylonMesh","_loadMeshPrimitiveAsync","primitives_1","primitiveBabylonMesh","_loadSkinAsync","_refreshBoundingInfo","_createMorphTargets","_loadVertexDataAsync","babylonGeometry","_loadMorphTargetsAsync","applyToMesh","babylonDrawMode","_GetDrawMode","babylonMaterial","_createDefaultMaterial","_loadMaterialAsync","_extensionsLoadVertexDataAsync","isUnIndexed","_loadIndicesAccessorAsync","setIndices","loadAttribute","kind","_delayInfo","_loadVertexAccessorAsync","babylonVertexBuffer","setVerticesBuffer","PositionKind","NormalKind","TangentKind","UV2Kind","MatricesIndicesKind","MatricesWeightsKind","ColorKind","hasVertexAlpha","targets","_numMorphTargets","morphTargetManager","MorphTargetManager","weight","weights","addTarget","MorphTarget","numTargets","babylonMorphTarget","getTarget","_loadMorphTargetVertexDataAsync","setData","getVertexBuffer","_loadFloatAccessorAsync","forEach","setPositions","setNormals","dataIndex","setTangents","Identity","One","assignSkeleton","_promise","skeletonId","_loadBones","_loadSkinInverseBindMatricesDataAsync","inverseBindMatricesData","_updateBoneMatrices","babylonBones","joints","_loadBone","babylonBone","babylonParentBone","boneIndex","_getNodeMatrix","_babylonBones","inverseBindMatrices","baseMatrix","_index","FromArrayToRef","invertToRef","getParent","multiplyToRef","getInvertedAbsoluteTransform","updateMatrix","_updateDifferenceMatrix","_extensionsLoadCameraAsync","perspective","fov","yfov","orthographic","orthoLeft","xmag","orthoRight","orthoBottom","ymag","orthoTop","loadAnimationAsync","promise","_extensionsLoadAnimationAsync","babylonAnimationGroup","AnimationGroup","_loadAnimationChannelAsync","normalize","animationContext","_loadAnimationSamplerAsync","ANIMATIONTYPE_FLOAT","getNextOutputValue","getNextKey","outputBufferOffset","interpolation","frameIndex","AnimationKeyInterpolation","STEP","inTangent","outTangent","targetIndex","animationName","targetedAnimations","morphTarget","babylonAnimationClone","clone","addTargetedAnimation","babylonAnimationTargets","concat","babylonAnimationTargets_1","inputAccessor","outputAccessor","_loadBufferAsync","loadUriAsync","loadBufferViewAsync","_GetTypedArray","numComponents","_GetNumComponents","sparse","sparse_1","indicesBufferView","valuesBufferView","indicesData","valuesData","valuesIndex","indicesIndex","componentIndex","_loadVertexBufferViewAsync","_babylonBuffer","Buffer","_babylonVertexBuffer","GetTypeByteLength","bufferView_1","babylonBuffer","size","byteStride","normalized","_loadMaterialMetallicRoughnessPropertiesAsync","properties","PBRMaterial","baseColorFactor","albedoColor","White","metallic","metallicFactor","roughness","roughnessFactor","baseColorTexture","loadTextureInfoAsync","albedoTexture","metallicRoughnessTexture","metallicTexture","useMetallnessFromMetallicTextureBlue","useRoughnessFromMetallicTextureGreen","useRoughnessFromMetallicTextureAlpha","_extensionsLoadMaterialAsync","_babylonData","babylonData","createMaterial","loadMaterialPropertiesAsync","ClockWiseSideOrientation","fillMode","enableSpecularAntiAliasing","useRadianceOverAlpha","useSpecularOverAlpha","transparencyMode","PBRMATERIAL_OPAQUE","_extensionsCreateMaterial","_extensionsLoadMaterialPropertiesAsync","loadMaterialBasePropertiesAsync","pbrMetallicRoughness","loadMaterialAlphaProperties","emissiveFactor","twoSidedLighting","normalTexture","bumpTexture","invertNormalMapX","invertNormalMapY","level","occlusionTexture","ambientTexture","useAmbientInGrayScale","strength","ambientTextureStrength","emissiveTexture","PBRMATERIAL_ALPHATEST","alphaCutOff","alphaCutoff","hasAlpha","PBRMATERIAL_ALPHABLEND","useAlphaFromAlbedoTexture","textureInfo","_extensionsLoadTextureInfoAsync","_loadTextureAsync","coordinatesIndex","texCoord","_DefaultSampler","samplerData","_loadSampler","deferred","Deferred","noMipMaps","exception","image","loadImageAsync","dataUrl","updateURL","mimeType","_GetTextureSamplingMode","_GetTextureWrapMode","_extensionsLoadUriAsync","_ValidateUri","request_1","fileData","event","_lengthComputable","lengthComputable","_loaded","loaded","_total","total","_onProgress","offlineProvider","LoadFileError","SceneLoaderProgressEvent","magFilter","LINEAR_NEAREST","LINEAR_LINEAR","LINEAR_NEAREST_MIPNEAREST","LINEAR_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR","NEAREST_NEAREST_MIPNEAREST","NEAREST_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPLINEAR","NEAREST_LINEAR_MIPLINEAR","Uint32Array","PointListDrawMode","LineListDrawMode","LineLoopDrawMode","LineStripDrawMode","TriangleFillMode","TriangleStripDrawMode","TriangleFanDrawMode","forceCompilationAsync","clipPlane","lights_1","getShadowGenerator","_forEachExtensions","action","name_4","_applyExtensions","actionAsync","name_5","loaderProperty","_activeLoaderExtensions","activeLoaderExtensions","onLoading","onReady","_loadUriAsync","LoadExtensionAsync","LoadExtraAsync","extras","extra","startPerformanceCounter","endPerformanceCounter","toto","toto1","GLTF2","Loader","NAME","EXT_lights_image_based","_lights","GLTFLoader","extensionContext","_loadLightAsync","environmentTexture","imageData_1","specularImages","_loop_1","mipmap","faces","_loop_2","face","specularImageContext","RawCubeTexture","specularImageSize","_babylonTexture","intensity","Inverse","FromQuaternionToRef","getReflectionTextureMatrix","sphericalHarmonics","SphericalHarmonics","irradianceCoefficients","convertIrradianceToLambertianRadiance","sphericalPolynomial","SphericalPolynomial","FromHarmonics","lodGenerationScale","Scalar","Log2","updateRGBDAsync","KHR_draco_mesh_compression","DracoCompression","DecoderAvailable","_dracoCompression","uniqueId","_dracoBabylonGeometry","decodeMeshAsync","babylonVertexData","applyToGeometry","catch","LightType","KHR_lights","babylonLight","DIRECTIONAL","Backward","POINT","SPOT","babylonSpotLight","outerConeAngle","innerAngle","innerConeAngle","falloffType","Light","FALLOFF_GLTF","range","KHR_materials_pbrSpecularGlossiness","_loadSpecularGlossinessPropertiesAsync","diffuseFactor","reflectivityColor","specularFactor","microSurface","glossinessFactor","diffuseTexture","specularGlossinessTexture","reflectivityTexture","useMicroSurfaceFromReflectivityMapAlpha","KHR_materials_unlit","_loadUnlitPropertiesAsync","unlit","KHR_texture_transform","offset","uOffset","vOffset","uRotationCenter","vRotationCenter","wAng","uScale","vScale","MSFT_audio_emitter","_clips","_emitters","clips","emitters","emitterIndex","emitter","refDistance","maxDistance","rolloffFactor","distanceModel","outerAngle","_loadEmitterAsync","_babylonSounds","sound","attachToMesh","setLocalDirectionToMesh","Forward","setDirectionalCone","ToDegrees","events","event_1","_loadAnimationEventAsync","_loadClipAsync","clip","_objectURL","clipPromises","options_1","loop","autoplay","volume","clipContext","objectURL","Sound","_positionInEmitterSpace","weightedSound","WeightedSound","directionalConeInnerAngle","directionalConeOuterAngle","_getEventAction","time","startOffset","currentFrame","frameOffset","play","stop","pause","babylonAnimationEvent","AnimationEvent","addEvent","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","MSFT_lod","maxLODsToLoad","onNodeLODsLoadedObservable","onMaterialLODsLoadedObservable","_nodeIndexLOD","_nodeSignalLODs","_nodePromiseLODs","_materialIndexLOD","_materialSignalLODs","_materialPromiseLODs","indexLOD","this_2","firstPromise","nodeLODs","_getLODs","ids","_loop_3","nodeLOD","previousNodeLOD","_disposeUnusedMaterials","materialLODs","_loop_4","materialLOD","previousBabylonDataLOD","previousIndexLOD","materials_1","drawMode","MSFT_minecraftMesh","extraContext","forceDepthWrite","separateCullingPass","MSFT_sRGBFactors","toLinearSpaceToRef","MTLFileLoader","parseMTL","lines","delimiter_pattern","line","trim","charAt","pos","substring","toLowerCase","parseFloat","_getTexture","specularTexture","opacityTexture","lastDelimiter","lastIndexOf","OBJFileLoader","obj","group","mtllib","usemtl","smooth","vertexPattern","normalPattern","uvPattern","facePattern1","facePattern2","facePattern3","facePattern4","facePattern5","_loadMTL","pathOfFile","BaseUrl","console","warn","_parseSolid","handledMesh","meshesFromObj","indicesForBabylon","wrappedPositionForBabylon","wrappedUvsForBabylon","wrappedNormalsForBabylon","tuplePosNorm","curPositionInIndices","hasMeshes","unwrappedPositionsForBabylon","unwrappedNormalsForBabylon","unwrappedUVForBabylon","triangles","materialNameFromObj","fileToLoad","materialsFromMTLFile","increment","isFirstMaterial","indicePositionFromObj","indiceUvsFromObj","indiceNormalFromObj","positionVectorFromOBJ","textureVectorFromOBJ","normalsVectorFromOBJ","OPTIMIZE_WITH_UV","arr","idx","uv","isInArrayUV","isInArray","unwrapData","x","y","z","getTriangles","v","setDataForCurrentFaceWithPattern1","Up","setDataForCurrentFaceWithPattern2","setDataForCurrentFaceWithPattern3","setDataForCurrentFaceWithPattern4","setDataForCurrentFaceWithPattern5","addPreviousObjMesh","reverse","slice","exec","objMesh","materialName","toString","RandomId","babylonMeshesArray","materialToUse","INVERT_Y","mtlPromises","dataLoaded","startIndex","_indices","STLFileLoader","solidPattern","facetsPattern",".stl","matches","parseBinary","array_buffer","str","meshName","parseASCII","load","createDefaultCameraOrLight","loadAssetContainer","reader","fileLength","getUint8","indicesCount","normalX","getFloat32","normalY","normalZ","vertexstart","setVerticesData","solidData","facet","normalMatches","lastIndex","vertexMatch","normal"],"mappings":"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","file":"babylonjs.loaders.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-loaders\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-loaders\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"LOADERS\"] = factory(root[\"BABYLON\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import { IGLTFRuntime, IGLTFTechniqueParameter, IGLTFAnimation, IGLTFAnimationSampler, IGLTFNode, IGLTFSkins, INodeToRoot, IJointNode, IGLTFMesh, IGLTFAccessor, IGLTFLight, IGLTFAmbienLight, IGLTFDirectionalLight, IGLTFPointLight, IGLTFSpotLight, IGLTFCamera, IGLTFCameraPerspective, IGLTFScene, IGLTFTechnique, IGLTFMaterial, EParameterType, IGLTFProgram, IGLTFBuffer, IGLTFTexture, IGLTFImage, IGLTFSampler, ETextureFilterType, IGLTFShader, IGLTFTechniqueStates, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces\";\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport { Nullable, Node, Tools, Bone, Animation, Quaternion, Vector3, Matrix, Skeleton, Mesh, Material, VertexData, VertexBuffer, FloatArray, StandardMaterial, MultiMaterial, Geometry, SubMesh, HemisphericLight, Color3, DirectionalLight, PointLight, SpotLight, FreeCamera, Camera, AbstractMesh, ShaderMaterial, Effect, Texture, Scene, Engine, SceneLoaderProgressEvent, IParticleSystem, AnimationGroup } from \"babylonjs\";\r\nimport { GLTFFileLoader, IGLTFLoader, GLTFLoaderState, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFLoaderExtension } from \"./glTFLoaderExtension\";\r\n\r\n/**\r\n* Tokenizer. Used for shaders compatibility\r\n* Automatically map world, view, projection, worldViewProjection, attributes and so on\r\n*/\r\nenum ETokenType {\r\n    IDENTIFIER = 1,\r\n\r\n    UNKNOWN = 2,\r\n    END_OF_INPUT = 3\r\n}\r\n\r\nclass Tokenizer {\r\n    private _toParse: string;\r\n    private _pos: number = 0;\r\n    private _maxPos: number;\r\n\r\n    public currentToken: ETokenType = ETokenType.UNKNOWN;\r\n    public currentIdentifier: string = \"\";\r\n    public currentString: string = \"\";\r\n    public isLetterOrDigitPattern: RegExp = /^[a-zA-Z0-9]+$/;\r\n\r\n    constructor(toParse: string) {\r\n        this._toParse = toParse;\r\n        this._maxPos = toParse.length;\r\n    }\r\n\r\n    public getNextToken(): ETokenType {\r\n        if (this.isEnd()) { return ETokenType.END_OF_INPUT; }\r\n\r\n        this.currentString = this.read();\r\n        this.currentToken = ETokenType.UNKNOWN;\r\n\r\n        if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\r\n            this.currentToken = ETokenType.IDENTIFIER;\r\n            this.currentIdentifier = this.currentString;\r\n            while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === \"_\")) {\r\n                this.currentIdentifier += this.currentString;\r\n                this.forward();\r\n            }\r\n        }\r\n\r\n        return this.currentToken;\r\n    }\r\n\r\n    public peek(): string {\r\n        return this._toParse[this._pos];\r\n    }\r\n\r\n    public read(): string {\r\n        return this._toParse[this._pos++];\r\n    }\r\n\r\n    public forward(): void {\r\n        this._pos++;\r\n    }\r\n\r\n    public isEnd(): boolean {\r\n        return this._pos >= this._maxPos;\r\n    }\r\n}\r\n\r\n/**\r\n* Values\r\n*/\r\nvar glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\r\nvar babylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\r\n\r\nvar glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\r\nvar babylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\r\n\r\n/**\r\n* Parse\r\n*/\r\nvar parseBuffers = (parsedBuffers: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (var buf in parsedBuffers) {\r\n        var parsedBuffer = parsedBuffers[buf];\r\n        gltfRuntime.buffers[buf] = parsedBuffer;\r\n        gltfRuntime.buffersCount++;\r\n    }\r\n};\r\n\r\nvar parseShaders = (parsedShaders: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (var sha in parsedShaders) {\r\n        var parsedShader = parsedShaders[sha];\r\n        gltfRuntime.shaders[sha] = parsedShader;\r\n        gltfRuntime.shaderscount++;\r\n    }\r\n};\r\n\r\nvar parseObject = (parsedObjects: any, runtimeProperty: string, gltfRuntime: IGLTFRuntime) => {\r\n    for (var object in parsedObjects) {\r\n        var parsedObject = parsedObjects[object];\r\n        (<any>gltfRuntime)[runtimeProperty][object] = parsedObject;\r\n    }\r\n};\r\n\r\n/**\r\n* Utils\r\n*/\r\nvar normalizeUVs = (buffer: any) => {\r\n    if (!buffer) {\r\n        return;\r\n    }\r\n\r\n    for (var i = 0; i < buffer.length / 2; i++) {\r\n        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\r\n    }\r\n};\r\n\r\nvar getAttribute = (attributeParameter: IGLTFTechniqueParameter): Nullable<string> => {\r\n    if (attributeParameter.semantic === \"NORMAL\") {\r\n        return \"normal\";\r\n    } else if (attributeParameter.semantic === \"POSITION\") {\r\n        return \"position\";\r\n    } else if (attributeParameter.semantic === \"JOINT\") {\r\n        return \"matricesIndices\";\r\n    } else if (attributeParameter.semantic === \"WEIGHT\") {\r\n        return \"matricesWeights\";\r\n    } else if (attributeParameter.semantic === \"COLOR\") {\r\n        return \"color\";\r\n    } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n        var channel = Number(attributeParameter.semantic.split(\"_\")[1]);\r\n        return \"uv\" + (channel === 0 ? \"\" : channel + 1);\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Loads and creates animations\r\n*/\r\nvar loadAnimations = (gltfRuntime: IGLTFRuntime) => {\r\n    for (var anim in gltfRuntime.animations) {\r\n        var animation: IGLTFAnimation = gltfRuntime.animations[anim];\r\n\r\n        if (!animation.channels || !animation.samplers) {\r\n            continue;\r\n        }\r\n\r\n        var lastAnimation: Nullable<Animation> = null;\r\n\r\n        for (var i = 0; i < animation.channels.length; i++) {\r\n            // Get parameters and load buffers\r\n            var channel = animation.channels[i];\r\n            var sampler: IGLTFAnimationSampler = animation.samplers[channel.sampler];\r\n\r\n            if (!sampler) {\r\n                continue;\r\n            }\r\n\r\n            var inputData: Nullable<string> = null;\r\n            var outputData: Nullable<string> = null;\r\n\r\n            if (animation.parameters) {\r\n                inputData = animation.parameters[sampler.input];\r\n                outputData = animation.parameters[sampler.output];\r\n            }\r\n            else {\r\n                inputData = sampler.input;\r\n                outputData = sampler.output;\r\n            }\r\n\r\n            var bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\r\n            var bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\r\n\r\n            var targetID = channel.target.id;\r\n            var targetNode: any = gltfRuntime.scene.getNodeByID(targetID);\r\n\r\n            if (targetNode === null) {\r\n                targetNode = gltfRuntime.scene.getNodeByName(targetID);\r\n            }\r\n\r\n            if (targetNode === null) {\r\n                Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetID + \" to attach to\");\r\n                continue;\r\n            }\r\n\r\n            var isBone = targetNode instanceof Bone;\r\n\r\n            // Get target path (position, rotation or scaling)\r\n            var targetPath = channel.target.path;\r\n            var targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\r\n\r\n            if (targetPathIndex !== -1) {\r\n                targetPath = babylonAnimationPaths[targetPathIndex];\r\n            }\r\n\r\n            // Determine animation type\r\n            var animationType = Animation.ANIMATIONTYPE_MATRIX;\r\n\r\n            if (!isBone) {\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    targetNode.rotationQuaternion = new Quaternion();\r\n                }\r\n                else {\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                }\r\n            }\r\n\r\n            // Create animation and key frames\r\n            var babylonAnimation: Nullable<Animation> = null;\r\n            var keys = [];\r\n            var arrayOffset = 0;\r\n            var modifyKey = false;\r\n\r\n            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\r\n                babylonAnimation = lastAnimation;\r\n                modifyKey = true;\r\n            }\r\n\r\n            if (!modifyKey) {\r\n                babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n            }\r\n\r\n            // For each frame\r\n            for (var j = 0; j < bufferInput.length; j++) {\r\n                var value: any = null;\r\n\r\n                if (targetPath === \"rotationQuaternion\") { // VEC4\r\n                    value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\r\n                    arrayOffset += 4;\r\n                }\r\n                else { // Position and scaling are VEC3\r\n                    value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\r\n                    arrayOffset += 3;\r\n                }\r\n\r\n                if (isBone) {\r\n                    var bone = <Bone>targetNode;\r\n                    var translation = Vector3.Zero();\r\n                    var rotationQuaternion = new Quaternion();\r\n                    var scaling = Vector3.Zero();\r\n\r\n                    // Warning on decompose\r\n                    var mat = bone.getBaseMatrix();\r\n\r\n                    if (modifyKey && lastAnimation) {\r\n                        mat = lastAnimation.getKeys()[j].value;\r\n                    }\r\n\r\n                    mat.decompose(scaling, rotationQuaternion, translation);\r\n\r\n                    if (targetPath === \"position\") {\r\n                        translation = value;\r\n                    }\r\n                    else if (targetPath === \"rotationQuaternion\") {\r\n                        rotationQuaternion = value;\r\n                    }\r\n                    else {\r\n                        scaling = value;\r\n                    }\r\n\r\n                    value = Matrix.Compose(scaling, rotationQuaternion, translation);\r\n                }\r\n\r\n                if (!modifyKey) {\r\n                    keys.push({\r\n                        frame: bufferInput[j],\r\n                        value: value\r\n                    });\r\n                }\r\n                else if (lastAnimation) {\r\n                    lastAnimation.getKeys()[j].value = value;\r\n                }\r\n            }\r\n\r\n            // Finish\r\n            if (!modifyKey && babylonAnimation) {\r\n                babylonAnimation.setKeys(keys);\r\n                targetNode.animations.push(babylonAnimation);\r\n            }\r\n\r\n            lastAnimation = babylonAnimation;\r\n\r\n            gltfRuntime.scene.stopAnimation(targetNode);\r\n            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* Returns the bones transformation matrix\r\n*/\r\nvar configureBoneTransformation = (node: IGLTFNode): Matrix => {\r\n    var mat: Nullable<Matrix> = null;\r\n\r\n    if (node.translation || node.rotation || node.scale) {\r\n        var scale = Vector3.FromArray(node.scale || [1, 1, 1]);\r\n        var rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\r\n        var position = Vector3.FromArray(node.translation || [0, 0, 0]);\r\n\r\n        mat = Matrix.Compose(scale, rotation, position);\r\n    }\r\n    else {\r\n        mat = Matrix.FromArray(node.matrix);\r\n    }\r\n\r\n    return mat;\r\n};\r\n\r\n/**\r\n* Returns the parent bone\r\n*/\r\nvar getParentBone = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, jointName: string, newSkeleton: Skeleton): Nullable<Bone> => {\r\n    // Try to find\r\n    for (var i = 0; i < newSkeleton.bones.length; i++) {\r\n        if (newSkeleton.bones[i].name === jointName) {\r\n            return newSkeleton.bones[i];\r\n        }\r\n    }\r\n\r\n    // Not found, search in gltf nodes\r\n    var nodes = gltfRuntime.nodes;\r\n    for (var nde in nodes) {\r\n        var node: IGLTFNode = nodes[nde];\r\n\r\n        if (!node.jointName) {\r\n            continue;\r\n        }\r\n\r\n        var children = node.children;\r\n        for (var i = 0; i < children.length; i++) {\r\n            var child: IGLTFNode = gltfRuntime.nodes[children[i]];\r\n            if (!child.jointName) {\r\n                continue;\r\n            }\r\n\r\n            if (child.jointName === jointName) {\r\n                var mat = configureBoneTransformation(node);\r\n                var bone = new Bone(node.name || \"\", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\r\n                bone.id = nde;\r\n                return bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Returns the appropriate root node\r\n*/\r\nvar getNodeToRoot = (nodesToRoot: INodeToRoot[], id: string): Nullable<Bone> => {\r\n    for (var i = 0; i < nodesToRoot.length; i++) {\r\n        var nodeToRoot = nodesToRoot[i];\r\n\r\n        for (var j = 0; j < nodeToRoot.node.children.length; j++) {\r\n            var child = nodeToRoot.node.children[j];\r\n            if (child === id) {\r\n                return nodeToRoot.bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Returns the node with the joint name\r\n*/\r\nvar getJointNode = (gltfRuntime: IGLTFRuntime, jointName: string): Nullable<IJointNode> => {\r\n    var nodes = gltfRuntime.nodes;\r\n    var node: IGLTFNode = nodes[jointName];\r\n    if (node) {\r\n        return {\r\n            node: node,\r\n            id: jointName\r\n        };\r\n    }\r\n\r\n    for (var nde in nodes) {\r\n        node = nodes[nde];\r\n        if (node.jointName === jointName) {\r\n            return {\r\n                node: node,\r\n                id: nde\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Checks if a nodes is in joints\r\n*/\r\nvar nodeIsInJoints = (skins: IGLTFSkins, id: string): boolean => {\r\n    for (var i = 0; i < skins.jointNames.length; i++) {\r\n        if (skins.jointNames[i] === id) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n* Fills the nodes to root for bones and builds hierarchy\r\n*/\r\nvar getNodesToRoot = (gltfRuntime: IGLTFRuntime, newSkeleton: Skeleton, skins: IGLTFSkins, nodesToRoot: INodeToRoot[]) => {\r\n    // Creates nodes for root\r\n    for (var nde in gltfRuntime.nodes) {\r\n        var node: IGLTFNode = gltfRuntime.nodes[nde];\r\n        var id = nde;\r\n\r\n        if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {\r\n            continue;\r\n        }\r\n\r\n        // Create node to root bone\r\n        var mat = configureBoneTransformation(node);\r\n        var bone = new Bone(node.name || \"\", newSkeleton, null, mat);\r\n        bone.id = id;\r\n        nodesToRoot.push({ bone: bone, node: node, id: id });\r\n    }\r\n\r\n    // Parenting\r\n    for (var i = 0; i < nodesToRoot.length; i++) {\r\n        var nodeToRoot = nodesToRoot[i];\r\n        var children = nodeToRoot.node.children;\r\n\r\n        for (var j = 0; j < children.length; j++) {\r\n            var child: Nullable<INodeToRoot> = null;\r\n\r\n            for (var k = 0; k < nodesToRoot.length; k++) {\r\n                if (nodesToRoot[k].id === children[j]) {\r\n                    child = nodesToRoot[k];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (child) {\r\n                (<any>child.bone)._parent = nodeToRoot.bone;\r\n                nodeToRoot.bone.children.push(child.bone);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* Imports a skeleton\r\n*/\r\nvar importSkeleton = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, mesh: Mesh, newSkeleton: Skeleton | undefined, id: string): Skeleton => {\r\n\r\n    if (!newSkeleton) {\r\n        newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\r\n    }\r\n\r\n    if (!skins.babylonSkeleton) {\r\n        return newSkeleton;\r\n    }\r\n\r\n    // Find the root bones\r\n    var nodesToRoot: INodeToRoot[] = [];\r\n    var nodesToRootToAdd: Bone[] = [];\r\n\r\n    getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\r\n    newSkeleton.bones = [];\r\n\r\n    // Joints\r\n    for (var i = 0; i < skins.jointNames.length; i++) {\r\n        var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        var node = jointNode.node;\r\n\r\n        if (!node) {\r\n            Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\r\n            continue;\r\n        }\r\n\r\n        var id = jointNode.id;\r\n\r\n        // Optimize, if the bone already exists...\r\n        var existingBone = gltfRuntime.scene.getBoneByID(id);\r\n        if (existingBone) {\r\n            newSkeleton.bones.push(existingBone);\r\n            continue;\r\n        }\r\n\r\n        // Search for parent bone\r\n        var foundBone = false;\r\n        var parentBone: Nullable<Bone> = null;\r\n\r\n        for (var j = 0; j < i; j++) {\r\n            let jointNode = getJointNode(gltfRuntime, skins.jointNames[j]);\r\n\r\n            if (!jointNode) {\r\n                continue;\r\n            }\r\n\r\n            var joint: IGLTFNode = jointNode.node;\r\n\r\n            if (!joint) {\r\n                Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\r\n                continue;\r\n            }\r\n\r\n            var children = joint.children;\r\n            if (!children) {\r\n                continue;\r\n            }\r\n            foundBone = false;\r\n\r\n            for (var k = 0; k < children.length; k++) {\r\n                if (children[k] === id) {\r\n                    parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\r\n                    foundBone = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundBone) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create bone\r\n        var mat = configureBoneTransformation(node);\r\n\r\n        if (!parentBone && nodesToRoot.length > 0) {\r\n            parentBone = getNodeToRoot(nodesToRoot, id);\r\n\r\n            if (parentBone) {\r\n                if (nodesToRootToAdd.indexOf(parentBone) === -1) {\r\n                    nodesToRootToAdd.push(parentBone);\r\n                }\r\n            }\r\n        }\r\n\r\n        var bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\r\n        bone.id = id;\r\n    }\r\n\r\n    // Polish\r\n    var bones = newSkeleton.bones;\r\n    newSkeleton.bones = [];\r\n\r\n    for (var i = 0; i < skins.jointNames.length; i++) {\r\n        var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        for (var j = 0; j < bones.length; j++) {\r\n            if (bones[j].id === jointNode.id) {\r\n                newSkeleton.bones.push(bones[j]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    newSkeleton.prepare();\r\n\r\n    // Finish\r\n    for (var i = 0; i < nodesToRootToAdd.length; i++) {\r\n        newSkeleton.bones.push(nodesToRootToAdd[i]);\r\n    }\r\n\r\n    return newSkeleton;\r\n};\r\n\r\n/**\r\n* Imports a mesh and its geometries\r\n*/\r\nvar importMesh = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, meshes: string[], id: string, newMesh: Mesh): Mesh => {\r\n    if (!newMesh) {\r\n        newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n        newMesh.id = id;\r\n    }\r\n\r\n    if (!node.babylonNode) {\r\n        return newMesh;\r\n    }\r\n\r\n    const subMaterials: Material[] = [];\r\n\r\n    var vertexData: Nullable<VertexData> = null;\r\n    var verticesStarts = new Array<number>();\r\n    var verticesCounts = new Array<number>();\r\n    var indexStarts = new Array<number>();\r\n    var indexCounts = new Array<number>();\r\n\r\n    for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        var meshID = meshes[meshIndex];\r\n        var mesh: IGLTFMesh = gltfRuntime.meshes[meshID];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        // Positions, normals and UVs\r\n        for (var i = 0; i < mesh.primitives.length; i++) {\r\n            // Temporary vertex data\r\n            var tempVertexData = new VertexData();\r\n\r\n            var primitive = mesh.primitives[i];\r\n            if (primitive.mode !== 4) {\r\n                // continue;\r\n            }\r\n\r\n            var attributes = primitive.attributes;\r\n            var accessor: Nullable<IGLTFAccessor> = null;\r\n            var buffer: any = null;\r\n\r\n            // Set positions, normal and uvs\r\n            for (var semantic in attributes) {\r\n\r\n                // Link accessor and buffer view\r\n                accessor = gltfRuntime.accessors[attributes[semantic]];\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                if (semantic === \"NORMAL\") {\r\n                    tempVertexData.normals = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.normals).set(buffer);\r\n                }\r\n                else if (semantic === \"POSITION\") {\r\n                    if (GLTFFileLoader.HomogeneousCoordinates) {\r\n                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\r\n\r\n                        for (var j = 0; j < buffer.length; j += 4) {\r\n                            tempVertexData.positions[j] = buffer[j];\r\n                            tempVertexData.positions[j + 1] = buffer[j + 1];\r\n                            tempVertexData.positions[j + 2] = buffer[j + 2];\r\n                        }\r\n                    }\r\n                    else {\r\n                        tempVertexData.positions = new Float32Array(buffer.length);\r\n                        (<Float32Array>tempVertexData.positions).set(buffer);\r\n                    }\r\n\r\n                    verticesCounts.push(tempVertexData.positions.length);\r\n                }\r\n                else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n                    var channel = Number(semantic.split(\"_\")[1]);\r\n                    var uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : (channel + 1));\r\n                    var uvs = new Float32Array(buffer.length);\r\n                    (<Float32Array>uvs).set(buffer);\r\n                    normalizeUVs(uvs);\r\n                    tempVertexData.set(uvs, uvKind);\r\n                }\r\n                else if (semantic === \"JOINT\") {\r\n                    tempVertexData.matricesIndices = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesIndices).set(buffer);\r\n                }\r\n                else if (semantic === \"WEIGHT\") {\r\n                    tempVertexData.matricesWeights = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesWeights).set(buffer);\r\n                }\r\n                else if (semantic === \"COLOR\") {\r\n                    tempVertexData.colors = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.colors).set(buffer);\r\n                }\r\n            }\r\n\r\n            // Indices\r\n            accessor = gltfRuntime.accessors[primitive.indices];\r\n            if (accessor) {\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                tempVertexData.indices = new Int32Array(buffer.length);\r\n                (<Float32Array>tempVertexData.indices).set(buffer);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n            else {\r\n                // Set indices on the fly\r\n                var indices: number[] = [];\r\n                for (var j = 0; j < (<FloatArray>tempVertexData.positions).length / 3; j++) {\r\n                    indices.push(j);\r\n                }\r\n\r\n                tempVertexData.indices = new Int32Array(indices);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n\r\n            if (!vertexData) {\r\n                vertexData = tempVertexData;\r\n            }\r\n            else {\r\n                vertexData.merge(tempVertexData);\r\n            }\r\n\r\n            // Sub material\r\n            let material = gltfRuntime.scene.getMaterialByID(primitive.material);\r\n\r\n            subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\r\n\r\n            // Update vertices start and index start\r\n            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\r\n            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\r\n        }\r\n    }\r\n    let material: StandardMaterial | MultiMaterial;\r\n    if (subMaterials.length > 1) {\r\n        material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n        (material as MultiMaterial).subMaterials = subMaterials;\r\n    }\r\n    else {\r\n        material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n    }\r\n\r\n    if (subMaterials.length === 1) {\r\n        material = (subMaterials[0] as StandardMaterial);\r\n    }\r\n\r\n    if (!newMesh.material) {\r\n        newMesh.material = material;\r\n    }\r\n\r\n    // Apply geometry\r\n    new Geometry(id, gltfRuntime.scene, vertexData!, false, newMesh);\r\n    newMesh.computeWorldMatrix(true);\r\n\r\n    // Apply submeshes\r\n    newMesh.subMeshes = [];\r\n    var index = 0;\r\n    for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        var meshID = meshes[meshIndex];\r\n        var mesh: IGLTFMesh = gltfRuntime.meshes[meshID];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        for (var i = 0; i < mesh.primitives.length; i++) {\r\n            if (mesh.primitives[i].mode !== 4) {\r\n                //continue;\r\n            }\r\n\r\n            SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Finish\r\n    return newMesh;\r\n};\r\n\r\n/**\r\n* Configure node transformation from position, rotation and scaling\r\n*/\r\nvar configureNode = (newNode: any, position: Vector3, rotation: Quaternion, scaling: Vector3) => {\r\n    if (newNode.position) {\r\n        newNode.position = position;\r\n    }\r\n\r\n    if (newNode.rotationQuaternion || newNode.rotation) {\r\n        newNode.rotationQuaternion = rotation;\r\n    }\r\n\r\n    if (newNode.scaling) {\r\n        newNode.scaling = scaling;\r\n    }\r\n};\r\n\r\n/**\r\n* Configures node from transformation matrix\r\n*/\r\nvar configureNodeFromMatrix = (newNode: Mesh, node: IGLTFNode, parent: Nullable<Node>) => {\r\n    if (node.matrix) {\r\n        var position = new Vector3(0, 0, 0);\r\n        var rotation = new Quaternion();\r\n        var scaling = new Vector3(0, 0, 0);\r\n        var mat = Matrix.FromArray(node.matrix);\r\n        mat.decompose(scaling, rotation, position);\r\n\r\n        configureNode(newNode, position, rotation, scaling);\r\n    }\r\n    else if (node.translation && node.rotation && node.scale) {\r\n        configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\r\n    }\r\n\r\n    newNode.computeWorldMatrix(true);\r\n};\r\n\r\n/**\r\n* Imports a node\r\n*/\r\nvar importNode = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, id: string, parent: Nullable<Node>): Nullable<Node> => {\r\n    var lastNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\r\n        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Meshes\r\n    if (node.skin) {\r\n        if (node.meshes) {\r\n            var skin: IGLTFSkins = gltfRuntime.skins[node.skin];\r\n\r\n            var newMesh = importMesh(gltfRuntime, node, node.meshes, id, <Mesh>node.babylonNode);\r\n            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonByID(node.skin);\r\n\r\n            if (newMesh.skeleton === null) {\r\n                newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton, node.skin);\r\n\r\n                if (!skin.babylonSkeleton) {\r\n                    skin.babylonSkeleton = newMesh.skeleton;\r\n                }\r\n            }\r\n\r\n            lastNode = newMesh;\r\n        }\r\n    }\r\n    else if (node.meshes) {\r\n        /**\r\n        * Improve meshes property\r\n        */\r\n        var newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, <Mesh>node.babylonNode);\r\n        lastNode = newMesh;\r\n    }\r\n    // Lights\r\n    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        var light: IGLTFLight = gltfRuntime.lights[node.light];\r\n\r\n        if (light) {\r\n            if (light.type === \"ambient\") {\r\n                var ambienLight: IGLTFAmbienLight = (<any>light)[light.type];\r\n                var hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                hemiLight.name = node.name || \"\";\r\n\r\n                if (ambienLight.color) {\r\n                    hemiLight.diffuse = Color3.FromArray(ambienLight.color);\r\n                }\r\n\r\n                lastNode = hemiLight;\r\n            }\r\n            else if (light.type === \"directional\") {\r\n                var directionalLight: IGLTFDirectionalLight = (<any>light)[light.type];\r\n                var dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                dirLight.name = node.name || \"\";\r\n\r\n                if (directionalLight.color) {\r\n                    dirLight.diffuse = Color3.FromArray(directionalLight.color);\r\n                }\r\n\r\n                lastNode = dirLight;\r\n            }\r\n            else if (light.type === \"point\") {\r\n                var pointLight: IGLTFPointLight = (<any>light)[light.type];\r\n                var ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                ptLight.name = node.name || \"\";\r\n\r\n                if (pointLight.color) {\r\n                    ptLight.diffuse = Color3.FromArray(pointLight.color);\r\n                }\r\n\r\n                lastNode = ptLight;\r\n            }\r\n            else if (light.type === \"spot\") {\r\n                var spotLight: IGLTFSpotLight = (<any>light)[light.type];\r\n                var spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\r\n                spLight.name = node.name || \"\";\r\n\r\n                if (spotLight.color) {\r\n                    spLight.diffuse = Color3.FromArray(spotLight.color);\r\n                }\r\n\r\n                if (spotLight.fallOfAngle) {\r\n                    spLight.angle = spotLight.fallOfAngle;\r\n                }\r\n\r\n                if (spotLight.fallOffExponent) {\r\n                    spLight.exponent = spotLight.fallOffExponent;\r\n                }\r\n\r\n                lastNode = spLight;\r\n            }\r\n        }\r\n    }\r\n    // Cameras\r\n    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        var camera: IGLTFCamera = gltfRuntime.cameras[node.camera];\r\n\r\n        if (camera) {\r\n            if (camera.type === \"orthographic\") {\r\n                var orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                orthoCamera.name = node.name || \"\";\r\n                orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                orthoCamera.attachControl(<HTMLElement>gltfRuntime.scene.getEngine().getRenderingCanvas());\r\n\r\n                lastNode = orthoCamera;\r\n            }\r\n            else if (camera.type === \"perspective\") {\r\n                var perspectiveCamera: IGLTFCameraPerspective = (<any>camera)[camera.type];\r\n                var persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                persCamera.name = node.name || \"\";\r\n                persCamera.attachControl(<HTMLElement>gltfRuntime.scene.getEngine().getRenderingCanvas());\r\n\r\n                if (!perspectiveCamera.aspectRatio) {\r\n                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\r\n                }\r\n\r\n                if (perspectiveCamera.znear && perspectiveCamera.zfar) {\r\n                    persCamera.maxZ = perspectiveCamera.zfar;\r\n                    persCamera.minZ = perspectiveCamera.znear;\r\n                }\r\n\r\n                lastNode = persCamera;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Empty node\r\n    if (!node.jointName) {\r\n        if (node.babylonNode) {\r\n            return node.babylonNode;\r\n        }\r\n        else if (lastNode === null) {\r\n            var dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n            node.babylonNode = dummy;\r\n            lastNode = dummy;\r\n        }\r\n    }\r\n\r\n    if (lastNode !== null) {\r\n        if (node.matrix && lastNode instanceof Mesh) {\r\n            configureNodeFromMatrix(lastNode, node, parent);\r\n        }\r\n        else {\r\n            var translation = node.translation || [0, 0, 0];\r\n            var rotation = node.rotation || [0, 0, 0, 1];\r\n            var scale = node.scale || [1, 1, 1];\r\n            configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\r\n        }\r\n\r\n        lastNode.updateCache(true);\r\n        node.babylonNode = lastNode;\r\n    }\r\n\r\n    return lastNode;\r\n};\r\n\r\n/**\r\n* Traverses nodes and creates them\r\n*/\r\nvar traverseNodes = (gltfRuntime: IGLTFRuntime, id: string, parent: Nullable<Node>, meshIncluded: boolean = false) => {\r\n    var node: IGLTFNode = gltfRuntime.nodes[id];\r\n    var newNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\r\n        if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\r\n            meshIncluded = true;\r\n        }\r\n        else {\r\n            meshIncluded = false;\r\n        }\r\n    }\r\n    else {\r\n        meshIncluded = true;\r\n    }\r\n\r\n    if (!node.jointName && meshIncluded) {\r\n        newNode = importNode(gltfRuntime, node, id, parent);\r\n\r\n        if (newNode !== null) {\r\n            newNode.id = id;\r\n            newNode.parent = parent;\r\n        }\r\n    }\r\n\r\n    if (node.children) {\r\n        for (var i = 0; i < node.children.length; i++) {\r\n            traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\r\n*/\r\nvar postLoad = (gltfRuntime: IGLTFRuntime) => {\r\n    // Nodes\r\n    var currentScene: IGLTFScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n    if (currentScene) {\r\n        for (var i = 0; i < currentScene.nodes.length; i++) {\r\n            traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n        }\r\n    }\r\n    else {\r\n        for (var thing in gltfRuntime.scenes) {\r\n            currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n            for (var i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set animations\r\n    loadAnimations(gltfRuntime);\r\n\r\n    for (var i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\r\n        var skeleton = gltfRuntime.scene.skeletons[i];\r\n        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\r\n    }\r\n};\r\n\r\n/**\r\n* onBind shaderrs callback to set uniforms and matrices\r\n*/\r\nvar onBindShaderMaterial = (mesh: AbstractMesh, gltfRuntime: IGLTFRuntime, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }, shaderMaterial: ShaderMaterial, technique: IGLTFTechnique, material: IGLTFMaterial, onSuccess: (shaderMaterial: ShaderMaterial) => void) => {\r\n    var materialValues = material.values || technique.parameters;\r\n\r\n    for (var unif in unTreatedUniforms) {\r\n        var uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        var type = uniform.type;\r\n\r\n        if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\r\n            if (uniform.semantic && !uniform.source && !uniform.node) {\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            }\r\n            else if (uniform.semantic && (uniform.source || uniform.node)) {\r\n                var source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\r\n                if (source === null) {\r\n                    source = gltfRuntime.scene.getNodeByID(uniform.source || uniform.node || \"\");\r\n                }\r\n                if (source === null) {\r\n                    continue;\r\n                }\r\n\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            }\r\n        }\r\n        else {\r\n            var value = (<any>materialValues)[technique.uniforms[unif]];\r\n            if (!value) {\r\n                continue;\r\n            }\r\n\r\n            if (type === EParameterType.SAMPLER_2D) {\r\n                var texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\r\n\r\n                if (texture === null || texture === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                (<Effect>shaderMaterial.getEffect()).setTexture(unif, texture);\r\n            }\r\n            else {\r\n                GLTFUtils.SetUniform(<Effect>(shaderMaterial.getEffect()), unif, value, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    onSuccess(shaderMaterial);\r\n};\r\n\r\n/**\r\n* Prepare uniforms to send the only one time\r\n* Loads the appropriate textures\r\n*/\r\nvar prepareShaderMaterialUniforms = (gltfRuntime: IGLTFRuntime, shaderMaterial: ShaderMaterial, technique: IGLTFTechnique, material: IGLTFMaterial, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }) => {\r\n    var materialValues = material.values || technique.parameters;\r\n    var techniqueUniforms = technique.uniforms;\r\n\r\n    /**\r\n    * Prepare values here (not matrices)\r\n    */\r\n    for (var unif in unTreatedUniforms) {\r\n        var uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        var type = uniform.type;\r\n        var value = (<any>materialValues)[techniqueUniforms[unif]];\r\n\r\n        if (value === undefined) {\r\n            // In case the value is the same for all materials\r\n            value = <any>uniform.value;\r\n        }\r\n\r\n        if (!value) {\r\n            continue;\r\n        }\r\n\r\n        var onLoadTexture = (uniformName: Nullable<string>) => {\r\n            return (texture: Texture) => {\r\n                if (uniform.value && uniformName) {\r\n                    // Static uniform\r\n                    shaderMaterial.setTexture(uniformName, texture);\r\n                    delete unTreatedUniforms[uniformName];\r\n                }\r\n            };\r\n        };\r\n\r\n        // Texture (sampler2D)\r\n        if (type === EParameterType.SAMPLER_2D) {\r\n            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\r\n        }\r\n        // Others\r\n        else {\r\n            if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\r\n                // Static uniform\r\n                delete unTreatedUniforms[unif];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* Shader compilation failed\r\n*/\r\nvar onShaderCompileError = (program: IGLTFProgram, shaderMaterial: ShaderMaterial, onError: (message: string) => void) => {\r\n    return (effect: Effect, error: string) => {\r\n        shaderMaterial.dispose(true);\r\n        onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\r\n    };\r\n};\r\n\r\n/**\r\n* Shader compilation success\r\n*/\r\nvar onShaderCompileSuccess = (gltfRuntime: IGLTFRuntime, shaderMaterial: ShaderMaterial, technique: IGLTFTechnique, material: IGLTFMaterial, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }, onSuccess: (shaderMaterial: ShaderMaterial) => void) => {\r\n    return (_: Effect) => {\r\n        prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\r\n\r\n        shaderMaterial.onBind = (mesh: AbstractMesh) => {\r\n            onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\r\n        };\r\n    };\r\n};\r\n\r\n/**\r\n* Returns the appropriate uniform if already handled by babylon\r\n*/\r\nvar parseShaderUniforms = (tokenizer: Tokenizer, technique: IGLTFTechnique, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }): string => {\r\n    for (var unif in technique.uniforms) {\r\n        var uniform = technique.uniforms[unif];\r\n        var uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n        if (tokenizer.currentIdentifier === unif) {\r\n            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\r\n                var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n\r\n                if (transformIndex !== -1) {\r\n                    delete unTreatedUniforms[unif];\r\n                    return babylonTransforms[transformIndex];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tokenizer.currentIdentifier;\r\n};\r\n\r\n/**\r\n* All shaders loaded. Create materials one by one\r\n*/\r\nvar importMaterials = (gltfRuntime: IGLTFRuntime) => {\r\n    // Create materials\r\n    for (var mat in gltfRuntime.materials) {\r\n        GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, (material: Material) => { }, () => { });\r\n    }\r\n};\r\n\r\n/**\r\n* Implementation of the base glTF spec\r\n*/\r\nexport class GLTFLoaderBase {\r\n    public static CreateRuntime(parsedData: any, scene: Scene, rootUrl: string): IGLTFRuntime {\r\n        var gltfRuntime: IGLTFRuntime = {\r\n            extensions: {},\r\n            accessors: {},\r\n            buffers: {},\r\n            bufferViews: {},\r\n            meshes: {},\r\n            lights: {},\r\n            cameras: {},\r\n            nodes: {},\r\n            images: {},\r\n            textures: {},\r\n            shaders: {},\r\n            programs: {},\r\n            samplers: {},\r\n            techniques: {},\r\n            materials: {},\r\n            animations: {},\r\n            skins: {},\r\n            extensionsUsed: [],\r\n\r\n            scenes: {},\r\n\r\n            buffersCount: 0,\r\n            shaderscount: 0,\r\n\r\n            scene: scene,\r\n            rootUrl: rootUrl,\r\n\r\n            loadedBufferCount: 0,\r\n            loadedBufferViews: {},\r\n\r\n            loadedShaderCount: 0,\r\n\r\n            importOnlyMeshes: false,\r\n\r\n            dummyNodes: []\r\n        };\r\n\r\n        // Parse\r\n        if (parsedData.extensions) {\r\n            parseObject(parsedData.extensions, \"extensions\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.extensionsUsed) {\r\n            parseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.buffers) {\r\n            parseBuffers(parsedData.buffers, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.bufferViews) {\r\n            parseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.accessors) {\r\n            parseObject(parsedData.accessors, \"accessors\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.meshes) {\r\n            parseObject(parsedData.meshes, \"meshes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.lights) {\r\n            parseObject(parsedData.lights, \"lights\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.cameras) {\r\n            parseObject(parsedData.cameras, \"cameras\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.nodes) {\r\n            parseObject(parsedData.nodes, \"nodes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.images) {\r\n            parseObject(parsedData.images, \"images\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.textures) {\r\n            parseObject(parsedData.textures, \"textures\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.shaders) {\r\n            parseShaders(parsedData.shaders, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.programs) {\r\n            parseObject(parsedData.programs, \"programs\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.samplers) {\r\n            parseObject(parsedData.samplers, \"samplers\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.techniques) {\r\n            parseObject(parsedData.techniques, \"techniques\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.materials) {\r\n            parseObject(parsedData.materials, \"materials\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.animations) {\r\n            parseObject(parsedData.animations, \"animations\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.skins) {\r\n            parseObject(parsedData.skins, \"skins\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.scenes) {\r\n            gltfRuntime.scenes = parsedData.scenes;\r\n        }\r\n\r\n        if (parsedData.scene && parsedData.scenes) {\r\n            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\r\n        }\r\n\r\n        return gltfRuntime;\r\n    }\r\n\r\n    public static LoadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): void {\r\n        var buffer: IGLTFBuffer = gltfRuntime.buffers[id];\r\n\r\n        if (Tools.IsBase64(buffer.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\r\n        }\r\n        else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, (data) => onSuccess(new Uint8Array(data as ArrayBuffer)), onProgress, undefined, true, (request) => {\r\n                if (request) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        var texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (!texture || !texture.source) {\r\n            onError(\"\");\r\n            return;\r\n        }\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(null);\r\n            return;\r\n        }\r\n\r\n        var source: IGLTFImage = gltfRuntime.images[texture.source];\r\n\r\n        if (Tools.IsBase64(source.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\r\n        }\r\n        else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + source.uri, (data) => onSuccess(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, (request) => {\r\n                if (request) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: Nullable<ArrayBufferView>, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        var texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(texture.babylonTexture);\r\n            return;\r\n        }\r\n\r\n        var sampler: IGLTFSampler = gltfRuntime.samplers[texture.sampler];\r\n\r\n        var createMipMaps =\r\n            (sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST) ||\r\n            (sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR) ||\r\n            (sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST) ||\r\n            (sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR);\r\n\r\n        var samplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n\r\n        var blob = buffer == null ? new Blob() : new Blob([buffer]);\r\n        var blobURL = URL.createObjectURL(blob);\r\n        var revokeBlobURL = () => URL.revokeObjectURL(blobURL);\r\n        var newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\r\n        if (sampler.wrapS !== undefined) {\r\n            newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\r\n        }\r\n        if (sampler.wrapT !== undefined) {\r\n            newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\r\n        }\r\n        newTexture.name = id;\r\n\r\n        texture.babylonTexture = newTexture;\r\n        onSuccess(newTexture);\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string | ArrayBuffer) => void, onError?: (message: string) => void): void {\r\n        var shader: IGLTFShader = gltfRuntime.shaders[id];\r\n\r\n        if (Tools.IsBase64(shader.uri)) {\r\n            var shaderString = atob(shader.uri.split(\",\")[1]);\r\n            if (onSuccess) {\r\n                onSuccess(shaderString);\r\n            }\r\n        }\r\n        else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, (request) => {\r\n                if (request && onError) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        var material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material.technique) {\r\n            if (onError) {\r\n                onError(\"No technique found.\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        var technique: IGLTFTechnique = gltfRuntime.techniques[material.technique];\r\n        if (!technique) {\r\n            var defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n            defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n            defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n            onSuccess(defaultMaterial);\r\n            return;\r\n        }\r\n\r\n        var program: IGLTFProgram = gltfRuntime.programs[technique.program];\r\n        var states: IGLTFTechniqueStates = technique.states;\r\n\r\n        var vertexShader: string = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\r\n        var pixelShader: string = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\r\n        var newVertexShader = \"\";\r\n        var newPixelShader = \"\";\r\n\r\n        var vertexTokenizer = new Tokenizer(vertexShader);\r\n        var pixelTokenizer = new Tokenizer(pixelShader);\r\n\r\n        var unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter } = {};\r\n        var uniforms: string[] = [];\r\n        var attributes: string[] = [];\r\n        var samplers: string[] = [];\r\n\r\n        // Fill uniform, sampler2D and attributes\r\n        for (var unif in technique.uniforms) {\r\n            var uniform = technique.uniforms[unif];\r\n            var uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n            unTreatedUniforms[unif] = uniformParameter;\r\n\r\n            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\r\n                var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n                if (transformIndex !== -1) {\r\n                    uniforms.push(babylonTransforms[transformIndex]);\r\n                    delete unTreatedUniforms[unif];\r\n                }\r\n                else {\r\n                    uniforms.push(unif);\r\n                }\r\n            }\r\n            else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\r\n                samplers.push(unif);\r\n            }\r\n            else {\r\n                uniforms.push(unif);\r\n            }\r\n        }\r\n\r\n        for (var attr in technique.attributes) {\r\n            var attribute = technique.attributes[attr];\r\n            var attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n            if (attributeParameter.semantic) {\r\n                let name = getAttribute(attributeParameter);\r\n                if (name) {\r\n                    attributes.push(name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Configure vertex shader\r\n        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\r\n            var tokenType = vertexTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newVertexShader += vertexTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            var foundAttribute = false;\r\n\r\n            for (var attr in technique.attributes) {\r\n                var attribute = technique.attributes[attr];\r\n                var attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\r\n                    newVertexShader += getAttribute(attributeParameter);\r\n                    foundAttribute = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundAttribute) {\r\n                continue;\r\n            }\r\n\r\n            newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Configure pixel shader\r\n        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\r\n            var tokenType = pixelTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newPixelShader += pixelTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Create shader material\r\n        var shaderPath = {\r\n            vertex: program.vertexShader + id,\r\n            fragment: program.fragmentShader + id\r\n        };\r\n\r\n        var options = {\r\n            attributes: attributes,\r\n            uniforms: uniforms,\r\n            samplers: samplers,\r\n            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1\r\n        };\r\n\r\n        Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\r\n        Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\r\n\r\n        var shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\r\n        shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);\r\n        shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\r\n        shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (states && states.functions) {\r\n            var functions = states.functions;\r\n            if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\r\n                shaderMaterial.backFaceCulling = false;\r\n            }\r\n\r\n            var blendFunc = functions.blendFuncSeparate;\r\n            if (blendFunc) {\r\n                if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Engine.ALPHA_COMBINE;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.ONE && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Engine.ALPHA_ONEONE;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Engine.ALPHA_ADD;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.ZERO && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Engine.ALPHA_SUBTRACT;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.DST_COLOR && blendFunc[1] === EBlendingFunction.ZERO && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Engine.ALPHA_MULTIPLY;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Engine.ALPHA_MAXIMIZED;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n* glTF V1 Loader\r\n*/\r\nexport class GLTFLoaderV1 implements IGLTFLoader {\r\n    public static Extensions: { [name: string]: GLTFLoaderExtension } = {};\r\n\r\n    public static RegisterExtension(extension: GLTFLoaderExtension): void {\r\n        if (GLTFLoaderV1.Extensions[extension.name]) {\r\n            Tools.Error(\"Tool with the same name \\\"\" + extension.name + \"\\\" already exists\");\r\n            return;\r\n        }\r\n\r\n        GLTFLoaderV1.Extensions[extension.name] = extension;\r\n    }\r\n\r\n    public state: Nullable<GLTFLoaderState> = null;\r\n\r\n    public dispose(): void {\r\n        // do nothing\r\n    }\r\n\r\n    private _importMeshAsync(meshesNames: any, scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: (meshes: AbstractMesh[], skeletons: Skeleton[]) => void, onProgress?: (event: SceneLoaderProgressEvent) => void, onError?: (message: string) => void): boolean {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {\r\n            gltfRuntime.importOnlyMeshes = true;\r\n\r\n            if (meshesNames === \"\") {\r\n                gltfRuntime.importMeshesNames = [];\r\n            }\r\n            else if (typeof meshesNames === \"string\") {\r\n                gltfRuntime.importMeshesNames = [meshesNames];\r\n            }\r\n            else if (meshesNames && !(meshesNames instanceof Array)) {\r\n                gltfRuntime.importMeshesNames = [meshesNames];\r\n            }\r\n            else {\r\n                gltfRuntime.importMeshesNames = [];\r\n                Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\r\n            }\r\n\r\n            // Create nodes\r\n            this._createNodes(gltfRuntime);\r\n\r\n            var meshes = new Array<AbstractMesh>();\r\n            var skeletons = new Array<Skeleton>();\r\n\r\n            // Fill arrays of meshes and skeletons\r\n            for (var nde in gltfRuntime.nodes) {\r\n                var node: IGLTFNode = gltfRuntime.nodes[nde];\r\n\r\n                if (node.babylonNode instanceof AbstractMesh) {\r\n                    meshes.push(<AbstractMesh>node.babylonNode);\r\n                }\r\n            }\r\n\r\n            for (var skl in gltfRuntime.skins) {\r\n                var skin: IGLTFSkins = gltfRuntime.skins[skl];\r\n\r\n                if (skin.babylonSkeleton instanceof Skeleton) {\r\n                    skeletons.push(skin.babylonSkeleton);\r\n                }\r\n            }\r\n\r\n            // Load buffers, shaders, materials, etc.\r\n            this._loadBuffersAsync(gltfRuntime, () => {\r\n                this._loadShadersAsync(gltfRuntime, () => {\r\n                    importMaterials(gltfRuntime);\r\n                    postLoad(gltfRuntime);\r\n\r\n                    if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                        onSuccess(meshes, skeletons);\r\n                    }\r\n                });\r\n            }, onProgress);\r\n\r\n            if (GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                onSuccess(meshes, skeletons);\r\n            }\r\n        }, onError);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Imports one or more meshes from a loaded gltf file and adds them to the scene\r\n    * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n    * @param scene the scene the meshes should be added to\r\n    * @param data gltf data containing information of the meshes in a loaded file\r\n    * @param rootUrl root url to load from\r\n    * @param onProgress event that fires when loading progress has occured\r\n    * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n    */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void): Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }> {\r\n        return new Promise((resolve, reject) => {\r\n            this._importMeshAsync(meshesNames, scene, data, rootUrl, (meshes, skeletons) => {\r\n                resolve({\r\n                    meshes: meshes,\r\n                    particleSystems: [],\r\n                    skeletons: skeletons,\r\n                    animationGroups: []\r\n                });\r\n            }, onProgress, (message) => {\r\n                reject(new Error(message));\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: () => void, onProgress?: (event: SceneLoaderProgressEvent) => void, onError?: (message: string) => void): void {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {\r\n            // Load runtime extensios\r\n            GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, () => {\r\n                // Create nodes\r\n                this._createNodes(gltfRuntime);\r\n\r\n                // Load buffers, shaders, materials, etc.\r\n                this._loadBuffersAsync(gltfRuntime, () => {\r\n                    this._loadShadersAsync(gltfRuntime, () => {\r\n                        importMaterials(gltfRuntime);\r\n                        postLoad(gltfRuntime);\r\n\r\n                        if (!GLTFFileLoader.IncrementalLoading) {\r\n                            onSuccess();\r\n                        }\r\n                    });\r\n                });\r\n\r\n                if (GLTFFileLoader.IncrementalLoading) {\r\n                    onSuccess();\r\n                }\r\n            }, onError);\r\n        }, onError);\r\n    }\r\n\r\n    /**\r\n    * Imports all objects from a loaded gltf file and adds them to the scene\r\n    * @param scene the scene the objects should be added to\r\n    * @param data gltf data containing information of the meshes in a loaded file\r\n    * @param rootUrl root url to load from\r\n    * @param onProgress event that fires when loading progress has occured\r\n    * @returns a promise which completes when objects have been loaded to the scene\r\n    */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this._loadAsync(scene, data, rootUrl, () => {\r\n                resolve();\r\n            }, onProgress, (message) => {\r\n                reject(new Error(message));\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadShadersAsync(gltfRuntime: IGLTFRuntime, onload: () => void): void {\r\n        var hasShaders = false;\r\n\r\n        var processShader = (sha: string, shader: IGLTFShader) => {\r\n            GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, (shaderString) => {\r\n                if (shaderString instanceof ArrayBuffer) {\r\n                    return;\r\n                }\r\n\r\n                gltfRuntime.loadedShaderCount++;\r\n\r\n                if (shaderString) {\r\n                    Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\r\n                }\r\n\r\n                if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\r\n                    onload();\r\n                }\r\n            }, () => {\r\n                Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\r\n            });\r\n        };\r\n\r\n        for (var sha in gltfRuntime.shaders) {\r\n            hasShaders = true;\r\n\r\n            var shader: IGLTFShader = gltfRuntime.shaders[sha];\r\n            if (shader) {\r\n                processShader.bind(this, sha, shader)();\r\n            }\r\n            else {\r\n                Tools.Error(\"No shader named: \" + sha);\r\n            }\r\n        }\r\n\r\n        if (!hasShaders) {\r\n            onload();\r\n        }\r\n    }\r\n\r\n    private _loadBuffersAsync(gltfRuntime: IGLTFRuntime, onLoad: () => void, onProgress?: (event: SceneLoaderProgressEvent) => void): void {\r\n        var hasBuffers = false;\r\n\r\n        var processBuffer = (buf: string, buffer: IGLTFBuffer) => {\r\n            GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, (bufferView) => {\r\n                gltfRuntime.loadedBufferCount++;\r\n\r\n                if (bufferView) {\r\n                    if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\r\n                        Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\r\n                    }\r\n\r\n                    gltfRuntime.loadedBufferViews[buf] = bufferView;\r\n                }\r\n\r\n                if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\r\n                    onLoad();\r\n                }\r\n            }, () => {\r\n                Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\r\n            });\r\n        };\r\n\r\n        for (var buf in gltfRuntime.buffers) {\r\n            hasBuffers = true;\r\n\r\n            var buffer: IGLTFBuffer = gltfRuntime.buffers[buf];\r\n            if (buffer) {\r\n                processBuffer.bind(this, buf, buffer)();\r\n            }\r\n            else {\r\n                Tools.Error(\"No buffer named: \" + buf);\r\n            }\r\n        }\r\n\r\n        if (!hasBuffers) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    private _createNodes(gltfRuntime: IGLTFRuntime): void {\r\n        var currentScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n        if (currentScene) {\r\n            // Only one scene even if multiple scenes are defined\r\n            for (var i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n        else {\r\n            // Load all scenes\r\n            for (var thing in gltfRuntime.scenes) {\r\n                currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n                for (var i = 0; i < currentScene.nodes.length; i++) {\r\n                    traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTFLoaderV1 = () => new GLTFLoaderV1();\r\n","import { Texture, Skeleton, Scene, Bone, Node } from \"babylonjs\";\r\n\r\n/**\r\n* Enums\r\n*/\r\nexport enum EComponentType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    FLOAT = 5126\r\n}\r\n\r\nexport enum EShaderType {\r\n    FRAGMENT = 35632,\r\n    VERTEX = 35633\r\n}\r\n\r\nexport enum EParameterType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    INT = 5124,\r\n    UNSIGNED_INT = 5125,\r\n    FLOAT = 5126,\r\n    FLOAT_VEC2 = 35664,\r\n    FLOAT_VEC3 = 35665,\r\n    FLOAT_VEC4 = 35666,\r\n    INT_VEC2 = 35667,\r\n    INT_VEC3 = 35668,\r\n    INT_VEC4 = 35669,\r\n    BOOL = 35670,\r\n    BOOL_VEC2 = 35671,\r\n    BOOL_VEC3 = 35672,\r\n    BOOL_VEC4 = 35673,\r\n    FLOAT_MAT2 = 35674,\r\n    FLOAT_MAT3 = 35675,\r\n    FLOAT_MAT4 = 35676,\r\n    SAMPLER_2D = 35678\r\n}\r\n\r\nexport enum ETextureWrapMode {\r\n    CLAMP_TO_EDGE = 33071,\r\n    MIRRORED_REPEAT = 33648,\r\n    REPEAT = 10497\r\n}\r\n\r\nexport enum ETextureFilterType {\r\n    NEAREST = 9728,\r\n    LINEAR = 9728,\r\n    NEAREST_MIPMAP_NEAREST = 9984,\r\n    LINEAR_MIPMAP_NEAREST = 9985,\r\n    NEAREST_MIPMAP_LINEAR = 9986,\r\n    LINEAR_MIPMAP_LINEAR = 9987\r\n}\r\n\r\nexport enum ETextureFormat {\r\n    ALPHA = 6406,\r\n    RGB = 6407,\r\n    RGBA = 6408,\r\n    LUMINANCE = 6409,\r\n    LUMINANCE_ALPHA = 6410\r\n}\r\n\r\nexport enum ECullingType {\r\n    FRONT = 1028,\r\n    BACK = 1029,\r\n    FRONT_AND_BACK = 1032\r\n}\r\n\r\nexport enum EBlendingFunction {\r\n    ZERO = 0,\r\n    ONE = 1,\r\n    SRC_COLOR = 768,\r\n    ONE_MINUS_SRC_COLOR = 769,\r\n    DST_COLOR = 774,\r\n    ONE_MINUS_DST_COLOR = 775,\r\n    SRC_ALPHA = 770,\r\n    ONE_MINUS_SRC_ALPHA = 771,\r\n    DST_ALPHA = 772,\r\n    ONE_MINUS_DST_ALPHA = 773,\r\n    CONSTANT_COLOR = 32769,\r\n    ONE_MINUS_CONSTANT_COLOR = 32770,\r\n    CONSTANT_ALPHA = 32771,\r\n    ONE_MINUS_CONSTANT_ALPHA = 32772,\r\n    SRC_ALPHA_SATURATE = 776\r\n}\r\n\r\n/**\r\n* Interfaces\r\n*/\r\nexport interface IGLTFProperty {\r\n    extensions?: {[key: string]: any};\r\n    extras?: Object;\r\n}\r\n\r\nexport interface IGLTFChildRootProperty extends IGLTFProperty {\r\n    name?: string;\r\n}\r\n\r\nexport interface IGLTFAccessor extends IGLTFChildRootProperty {\r\n    bufferView: string;\r\n    byteOffset: number;\r\n    byteStride: number;\r\n    count: number;\r\n    type: string;\r\n    componentType: EComponentType;\r\n\r\n    max?: number[];\r\n    min?: number[];\r\n    name?: string;\r\n}\r\n\r\nexport interface IGLTFBufferView extends IGLTFChildRootProperty {\r\n    buffer: string;\r\n    byteOffset: number;\r\n    byteLength: number;\r\n    byteStride: number;\r\n\r\n    target?: number;\r\n}\r\n\r\nexport interface IGLTFBuffer extends IGLTFChildRootProperty {\r\n    uri: string;\r\n\r\n    byteLength?: number;\r\n    type?: string;\r\n}\r\n\r\nexport interface IGLTFShader extends IGLTFChildRootProperty {\r\n    uri: string;\r\n    type: EShaderType;\r\n}\r\n\r\nexport interface IGLTFProgram extends IGLTFChildRootProperty {\r\n    attributes: string[];\r\n    fragmentShader: string;\r\n    vertexShader: string;\r\n}\r\n\r\nexport interface IGLTFTechniqueParameter {\r\n    type: number;\r\n\r\n    count?: number;\r\n    semantic?: string;\r\n    node?: string;\r\n    value?: number | boolean | string | Array<any>;\r\n    source?: string;\r\n\r\n    babylonValue?: any;\r\n}\r\n\r\nexport interface IGLTFTechniqueCommonProfile {\r\n    lightingModel: string;\r\n    texcoordBindings: Object;\r\n\r\n    parameters?: Array<any>;\r\n}\r\n\r\nexport interface IGLTFTechniqueStatesFunctions {\r\n    blendColor?: number[];\r\n    blendEquationSeparate?: number[];\r\n    blendFuncSeparate?: number[];\r\n    colorMask: boolean[];\r\n    cullFace: number[];\r\n}\r\n\r\nexport interface IGLTFTechniqueStates {\r\n    enable: number[];\r\n    functions: IGLTFTechniqueStatesFunctions;\r\n}\r\n\r\nexport interface IGLTFTechnique extends IGLTFChildRootProperty {\r\n    parameters: {[key: string]: IGLTFTechniqueParameter};\r\n    program: string;\r\n\r\n    attributes: {[key: string]: string};\r\n    uniforms: {[key: string]: string};\r\n    states: IGLTFTechniqueStates;\r\n}\r\n\r\nexport interface IGLTFMaterial extends IGLTFChildRootProperty {\r\n    technique?: string;\r\n    values: string[];\r\n}\r\n\r\nexport interface IGLTFMeshPrimitive extends IGLTFProperty {\r\n    attributes: {[key: string]: string};\r\n    indices: string;\r\n    material: string;\r\n\r\n    mode?: number;\r\n}\r\n\r\nexport interface IGLTFMesh extends IGLTFChildRootProperty {\r\n    primitives: IGLTFMeshPrimitive[];\r\n}\r\n\r\nexport interface IGLTFImage extends IGLTFChildRootProperty {\r\n    uri: string;\r\n}\r\n\r\nexport interface IGLTFSampler extends IGLTFChildRootProperty {\r\n    magFilter?: number;\r\n    minFilter?: number;\r\n    wrapS?: number;\r\n    wrapT?: number;\r\n}\r\n\r\nexport interface IGLTFTexture extends IGLTFChildRootProperty {\r\n    sampler: string;\r\n    source: string;\r\n\r\n    format?: ETextureFormat;\r\n    internalFormat?: ETextureFormat;\r\n    target?: number;\r\n    type?: number;\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonTexture?: Texture;\r\n}\r\n\r\nexport interface IGLTFAmbienLight {\r\n    color?: number[];\r\n}\r\n\r\nexport interface IGLTFDirectionalLight {\r\n    color?: number[];\r\n}\r\n\r\nexport interface IGLTFPointLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\nexport interface IGLTFSpotLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    fallOfAngle?: number;\r\n    fallOffExponent?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\nexport interface IGLTFLight extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\nexport interface IGLTFCameraOrthographic {\r\n    xmag: number;\r\n    ymag: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\nexport interface IGLTFCameraPerspective {\r\n    aspectRatio: number;\r\n    yfov: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\nexport interface IGLTFCamera extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\nexport interface IGLTFAnimationChannelTarget {\r\n    id: string;\r\n    path: string;\r\n}\r\n\r\nexport interface IGLTFAnimationChannel {\r\n    sampler: string;\r\n    target: IGLTFAnimationChannelTarget;\r\n}\r\n\r\nexport interface IGLTFAnimationSampler {\r\n    input: string;\r\n    output: string;\r\n\r\n    interpolation?: string;\r\n}\r\n\r\nexport interface IGLTFAnimation extends IGLTFChildRootProperty {\r\n    channels?: IGLTFAnimationChannel[];\r\n    parameters?:  {[key: string]: string};\r\n    samplers?: {[key: string]: IGLTFAnimationSampler};\r\n}\r\n\r\nexport interface IGLTFNodeInstanceSkin {\r\n    skeletons: string[];\r\n    skin: string;\r\n    meshes: string[];\r\n}\r\n\r\nexport interface IGLTFSkins extends IGLTFChildRootProperty {\r\n    bindShapeMatrix: number[];\r\n    inverseBindMatrices: string;\r\n    jointNames: string[];\r\n\r\n    babylonSkeleton?: Skeleton;\r\n}\r\n\r\nexport interface IGLTFNode extends IGLTFChildRootProperty {\r\n    camera?: string;\r\n    children: string[];\r\n    skin?: string;\r\n    jointName?: string;\r\n    light?: string;\r\n    matrix: number[];\r\n    mesh?: string;\r\n    meshes?: string[];\r\n    rotation?: number[];\r\n    scale?: number[];\r\n    translation?: number[];\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonNode?: Node;\r\n}\r\n\r\nexport interface IGLTFScene extends IGLTFChildRootProperty {\r\n    nodes: string[];\r\n}\r\n\r\n/**\r\n* Runtime\r\n*/\r\nexport interface IGLTFRuntime {\r\n    extensions: {[key: string]: any};\r\n    accessors: {[key: string]: IGLTFAccessor};\r\n    buffers: {[key: string]: IGLTFBuffer};\r\n    bufferViews: {[key: string]: IGLTFBufferView};\r\n    meshes: {[key: string]: IGLTFMesh};\r\n    lights: {[key: string]: IGLTFLight};\r\n    cameras: {[key: string]: IGLTFCamera};\r\n    nodes: {[key: string]: IGLTFNode};\r\n    images: {[key: string]: IGLTFImage};\r\n    textures: {[key: string]: IGLTFTexture};\r\n    shaders: {[key: string]: IGLTFShader};\r\n    programs: {[key: string]: IGLTFProgram};\r\n    samplers: {[key: string]: IGLTFSampler};\r\n    techniques: {[key: string]: IGLTFTechnique};\r\n    materials: {[key: string]: IGLTFMaterial};\r\n    animations: {[key: string]: IGLTFAnimation};\r\n    skins: {[key: string]: IGLTFSkins};\r\n\r\n    currentScene?: Object;\r\n    scenes: {[key: string]: IGLTFScene}; // v1.1\r\n\r\n    extensionsUsed: string[];\r\n    extensionsRequired?: string[]; // v1.1\r\n\r\n    buffersCount: number;\r\n    shaderscount: number;\r\n\r\n    scene: Scene;\r\n    rootUrl: string;\r\n\r\n    loadedBufferCount: number;\r\n    loadedBufferViews: { [name: string]: ArrayBufferView };\r\n\r\n    loadedShaderCount: number;\r\n\r\n    importOnlyMeshes: boolean;\r\n    importMeshesNames?: string[];\r\n\r\n    dummyNodes: Node[];\r\n}\r\n\r\n/**\r\n* Bones\r\n*/\r\nexport interface INodeToRoot {\r\n    bone: Bone;\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n\r\nexport interface IJointNode {\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n","import { IDisposable, Nullable, Scene, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, Observable, Observer, SceneLoaderProgressEvent, AbstractMesh, IParticleSystem, Skeleton, AnimationGroup, BaseTexture, Material, Camera, ISceneLoaderPluginExtensions, ISceneLoaderPlugin, AssetContainer, Tools, SceneLoader } from \"babylonjs\";\r\nimport { IGLTFValidationResults, IGLTFValidationOptions } from \"babylonjs-gltf2interface\";\r\n\r\n/**\r\n * glTF validator object\r\n */\r\ndeclare var GLTFValidator: {\r\n    validateString: (json: string, options?: IGLTFValidationOptions) => Promise<IGLTFValidationResults>;\r\n};\r\n\r\n/**\r\n * Mode that determines the coordinate system to use.\r\n */\r\nexport enum GLTFLoaderCoordinateSystemMode {\r\n    /**\r\n     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.\r\n     */\r\n    AUTO,\r\n\r\n    /**\r\n     * Sets the useRightHandedSystem flag on the scene.\r\n     */\r\n    FORCE_RIGHT_HANDED,\r\n}\r\n\r\n/**\r\n * Mode that determines what animations will start.\r\n */\r\nexport enum GLTFLoaderAnimationStartMode {\r\n    /**\r\n     * No animation will start.\r\n     */\r\n    NONE,\r\n\r\n    /**\r\n     * The first animation will start.\r\n     */\r\n    FIRST,\r\n\r\n    /**\r\n     * All animations will start.\r\n     */\r\n    ALL,\r\n}\r\n\r\n/**\r\n * Interface that contains the data for the glTF asset.\r\n */\r\nexport interface IGLTFLoaderData {\r\n    /**\r\n     * Object that represents the glTF JSON.\r\n     */\r\n    json: Object;\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    bin: Nullable<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * Interface for extending the loader.\r\n */\r\nexport interface IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    enabled: boolean;\r\n}\r\n\r\n/**\r\n * Loader state.\r\n */\r\nexport enum GLTFLoaderState {\r\n    /**\r\n     * The asset is loading.\r\n     */\r\n    LOADING,\r\n\r\n    /**\r\n     * The asset is ready for rendering.\r\n     */\r\n    READY,\r\n\r\n    /**\r\n     * The asset is completely loaded.\r\n     */\r\n    COMPLETE\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFLoader extends IDisposable {\r\n    readonly state: Nullable<GLTFLoaderState>;\r\n    importMeshAsync: (meshesNames: any, scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string) => Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }>;\r\n    loadAsync: (scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string) => Promise<void>;\r\n}\r\n\r\n/**\r\n * File loader for loading glTF files into a scene.\r\n */\r\nexport class GLTFFileLoader implements IDisposable, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /** @hidden */\r\n    public static _CreateGLTFLoaderV1: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /** @hidden */\r\n    public static _CreateGLTFLoaderV2: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    // --------------\r\n    // Common options\r\n    // --------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public onParsedObservable = new Observable<IGLTFLoaderData>();\r\n\r\n    private _onParsedObserver: Nullable<Observer<IGLTFLoaderData>>;\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public set onParsed(callback: (loaderData: IGLTFLoaderData) => void) {\r\n        if (this._onParsedObserver) {\r\n            this.onParsedObservable.remove(this._onParsedObserver);\r\n        }\r\n        this._onParsedObserver = this.onParsedObservable.add(callback);\r\n    }\r\n\r\n    // ----------\r\n    // V1 options\r\n    // ----------\r\n\r\n    /**\r\n     * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.\r\n     * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.\r\n     * Defaults to true.\r\n     * @hidden\r\n     */\r\n    public static IncrementalLoading = true;\r\n\r\n    /**\r\n     * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.\r\n     * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.\r\n     * @hidden\r\n     */\r\n    public static HomogeneousCoordinates = false;\r\n\r\n    // ----------\r\n    // V2 options\r\n    // ----------\r\n\r\n    /**\r\n     * The coordinate system mode. Defaults to AUTO.\r\n     */\r\n    public coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;\r\n\r\n    /**\r\n    * The animation start mode. Defaults to FIRST.\r\n    */\r\n    public animationStartMode = GLTFLoaderAnimationStartMode.FIRST;\r\n\r\n    /**\r\n     * Defines if the loader should compile materials before raising the success callback. Defaults to false.\r\n     */\r\n    public compileMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should also compile materials with clip planes. Defaults to false.\r\n     */\r\n    public useClipPlane = false;\r\n\r\n    /**\r\n     * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.\r\n     */\r\n    public compileShadowGenerators = false;\r\n\r\n    /**\r\n     * Defines if the Alpha blended materials are only applied as coverage.\r\n     * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.\r\n     * If true, no extra effects are applied to transparent pixels.\r\n     */\r\n    public transparencyAsCoverage = false;\r\n\r\n    /**\r\n     * Function called before loading a url referenced by the asset.\r\n     */\r\n    public preprocessUrlAsync = (url: string) => Promise.resolve(url);\r\n\r\n    /**\r\n     * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     */\r\n    public readonly onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n\r\n    private _onMeshLoadedObserver: Nullable<Observer<AbstractMesh>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     */\r\n    public set onMeshLoaded(callback: (mesh: AbstractMesh) => void) {\r\n        if (this._onMeshLoadedObserver) {\r\n            this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);\r\n        }\r\n        this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public readonly onTextureLoadedObservable = new Observable<BaseTexture>();\r\n\r\n    private _onTextureLoadedObserver: Nullable<Observer<BaseTexture>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public set onTextureLoaded(callback: (texture: BaseTexture) => void) {\r\n        if (this._onTextureLoadedObserver) {\r\n            this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);\r\n        }\r\n        this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public readonly onMaterialLoadedObservable = new Observable<Material>();\r\n\r\n    private _onMaterialLoadedObserver: Nullable<Observer<Material>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public set onMaterialLoaded(callback: (material: Material) => void) {\r\n        if (this._onMaterialLoadedObserver) {\r\n            this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);\r\n        }\r\n        this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public readonly onCameraLoadedObservable = new Observable<Camera>();\r\n\r\n    private _onCameraLoadedObserver: Nullable<Observer<Camera>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public set onCameraLoaded(callback: (camera: Camera) => void) {\r\n        if (this._onCameraLoadedObserver) {\r\n            this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);\r\n        }\r\n        this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public readonly onCompleteObservable = new Observable<void>();\r\n\r\n    private _onCompleteObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public set onComplete(callback: () => void) {\r\n        if (this._onCompleteObserver) {\r\n            this.onCompleteObservable.remove(this._onCompleteObserver);\r\n        }\r\n        this._onCompleteObserver = this.onCompleteObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when an error occurs.\r\n     */\r\n    public readonly onErrorObservable = new Observable<any>();\r\n\r\n    private _onErrorObserver: Nullable<Observer<any>>;\r\n\r\n    /**\r\n     * Callback raised when an error occurs.\r\n     */\r\n    public set onError(callback: (reason: any) => void) {\r\n        if (this._onErrorObserver) {\r\n            this.onErrorObservable.remove(this._onErrorObserver);\r\n        }\r\n        this._onErrorObserver = this.onErrorObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after the loader is disposed.\r\n     */\r\n    public readonly onDisposeObservable = new Observable<void>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised after the loader is disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after a loader extension is created.\r\n     * Set additional options for a loader extension in this event.\r\n     */\r\n    public readonly onExtensionLoadedObservable = new Observable<IGLTFLoaderExtension>();\r\n\r\n    private _onExtensionLoadedObserver: Nullable<Observer<IGLTFLoaderExtension>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onExtensionLoaded(callback: (extension: IGLTFLoaderExtension) => void) {\r\n        if (this._onExtensionLoadedObserver) {\r\n            this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);\r\n        }\r\n        this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader logging is enabled.\r\n     */\r\n    public get loggingEnabled(): boolean {\r\n        return this._loggingEnabled;\r\n    }\r\n\r\n    public set loggingEnabled(value: boolean) {\r\n        if (this._loggingEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._loggingEnabled = value;\r\n\r\n        if (this._loggingEnabled) {\r\n            this._log = this._logEnabled;\r\n        }\r\n        else {\r\n            this._log = this._logDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public get capturePerformanceCounters(): boolean {\r\n        return this._capturePerformanceCounters;\r\n    }\r\n\r\n    public set capturePerformanceCounters(value: boolean) {\r\n        if (this._capturePerformanceCounters === value) {\r\n            return;\r\n        }\r\n\r\n        this._capturePerformanceCounters = value;\r\n\r\n        if (this._capturePerformanceCounters) {\r\n            this._startPerformanceCounter = this._startPerformanceCounterEnabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterEnabled;\r\n        }\r\n        else {\r\n            this._startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should validate the asset.\r\n     */\r\n    public validate = false;\r\n\r\n    /**\r\n     * Observable raised after validation when validate is set to true. The event data is the result of the validation.\r\n     */\r\n    public readonly onValidatedObservable = new Observable<IGLTFValidationResults>();\r\n\r\n    private _onValidatedObserver: Nullable<Observer<IGLTFValidationResults>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onValidated(callback: (results: IGLTFValidationResults) => void) {\r\n        if (this._onValidatedObserver) {\r\n            this.onValidatedObservable.remove(this._onValidatedObserver);\r\n        }\r\n        this._onValidatedObserver = this.onValidatedObservable.add(callback);\r\n    }\r\n\r\n    private _loader: Nullable<IGLTFLoader> = null;\r\n\r\n    /**\r\n     * Name of the loader (\"gltf\")\r\n     */\r\n    public name = \"gltf\";\r\n\r\n    /**\r\n     * Supported file extensions of the loader (.gltf, .glb)\r\n     */\r\n    public extensions: ISceneLoaderPluginExtensions = {\r\n        \".gltf\": { isBinary: false },\r\n        \".glb\": { isBinary: true }\r\n    };\r\n\r\n    /**\r\n     * Disposes the loader, releases resources during load, and cancels any outstanding requests.\r\n     */\r\n    public dispose(): void {\r\n        if (this._loader) {\r\n            this._loader.dispose();\r\n            this._loader = null;\r\n        }\r\n\r\n        this._clear();\r\n\r\n        this.onDisposeObservable.notifyObservers(undefined);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _clear(): void {\r\n        this.preprocessUrlAsync = (url) => Promise.resolve(url);\r\n\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onTextureLoadedObservable.clear();\r\n        this.onMaterialLoadedObservable.clear();\r\n        this.onCameraLoadedObservable.clear();\r\n        this.onCompleteObservable.clear();\r\n        this.onExtensionLoadedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from the loaded glTF data and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param data the glTF data to load\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }> {\r\n        return this._parseAsync(scene, data, rootUrl, fileName).then((loaderData) => {\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(loaderData);\r\n            return this._loader.importMeshAsync(meshesNames, scene, loaderData, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from the loaded glTF data and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data the glTF data to load\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public loadAsync(scene: Scene, data: string | ArrayBuffer, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\r\n        return this._parseAsync(scene, data, rootUrl, fileName).then((loaderData) => {\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(loaderData);\r\n            return this._loader.loadAsync(scene, loaderData, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded asset container\r\n     */\r\n    public loadAssetContainerAsync(scene: Scene, data: string | ArrayBuffer, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer> {\r\n        return this._parseAsync(scene, data, rootUrl, fileName).then((loaderData) => {\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(loaderData);\r\n            return this._loader.importMeshAsync(null, scene, loaderData, rootUrl, onProgress, fileName).then((result) => {\r\n                const container = new AssetContainer(scene);\r\n                Array.prototype.push.apply(container.meshes, result.meshes);\r\n                Array.prototype.push.apply(container.particleSystems, result.particleSystems);\r\n                Array.prototype.push.apply(container.skeletons, result.skeletons);\r\n                Array.prototype.push.apply(container.animationGroups, result.animationGroups);\r\n                container.removeAllFromScene();\r\n                return container;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * If the data string can be loaded directly.\r\n     * @param data string contianing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    public canDirectLoad(data: string): boolean {\r\n        return ((data.indexOf(\"scene\") !== -1) && (data.indexOf(\"node\") !== -1));\r\n    }\r\n\r\n    /**\r\n     * Rewrites a url by combining a root url and response url.\r\n     */\r\n    public rewriteRootURL: (rootUrl: string, responseURL?: string) => string;\r\n\r\n    /**\r\n     * Instantiates a glTF file loader plugin.\r\n     * @returns the created plugin\r\n     */\r\n    public createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync {\r\n        return new GLTFFileLoader();\r\n    }\r\n\r\n    /**\r\n     * The loader state or null if the loader is not active.\r\n     */\r\n    public get loaderState(): Nullable<GLTFLoaderState> {\r\n        return this._loader ? this._loader.state : null;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when the asset is completely loaded.\r\n     * @returns a promise that resolves when the asset is completely loaded.\r\n     */\r\n    public whenCompleteAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.onCompleteObservable.addOnce(() => {\r\n                resolve();\r\n            });\r\n            this.onErrorObservable.addOnce((reason) => {\r\n                reject(reason);\r\n            });\r\n        });\r\n    }\r\n\r\n    private _parseAsync(scene: Scene, data: string | ArrayBuffer, rootUrl: string, fileName?: string): Promise<IGLTFLoaderData> {\r\n        return Promise.resolve().then(() => {\r\n            const unpacked = (data instanceof ArrayBuffer) ? this._unpackBinary(data) : { json: data, bin: null };\r\n\r\n            return this._validateAsync(scene, unpacked.json, rootUrl, fileName).then(() => {\r\n                this._startPerformanceCounter(\"Parse JSON\");\r\n                this._log(`JSON length: ${unpacked.json.length}`);\r\n\r\n                const loaderData: IGLTFLoaderData = {\r\n                    json: JSON.parse(unpacked.json),\r\n                    bin: unpacked.bin\r\n                };\r\n\r\n                this._endPerformanceCounter(\"Parse JSON\");\r\n\r\n                this.onParsedObservable.notifyObservers(loaderData);\r\n                this.onParsedObservable.clear();\r\n\r\n                return loaderData;\r\n            });\r\n        });\r\n    }\r\n\r\n    private _validateAsync(scene: Scene, json: string, rootUrl: string, fileName?: string): Promise<void> {\r\n        if (!this.validate || typeof GLTFValidator === \"undefined\") {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        this._startPerformanceCounter(\"Validate JSON\");\r\n\r\n        const options: IGLTFValidationOptions = {\r\n            externalResourceFunction: (uri) => {\r\n                return this.preprocessUrlAsync(rootUrl + uri)\r\n                    .then((url) => scene._loadFileAsync(url, true, true))\r\n                    .then((data) => new Uint8Array(data as ArrayBuffer));\r\n            }\r\n        };\r\n\r\n        if (fileName && fileName.substr(0, 5) !== \"data:\") {\r\n            options.uri = (rootUrl === \"file:\" ? fileName : `${rootUrl}${fileName}`);\r\n        }\r\n\r\n        return GLTFValidator.validateString(json, options).then((result) => {\r\n            this._endPerformanceCounter(\"Validate JSON\");\r\n\r\n            this.onValidatedObservable.notifyObservers(result);\r\n            this.onValidatedObservable.clear();\r\n        });\r\n    }\r\n\r\n    private _getLoader(loaderData: IGLTFLoaderData): IGLTFLoader {\r\n        const asset = (<any>loaderData.json).asset || {};\r\n\r\n        this._log(`Asset version: ${asset.version}`);\r\n        asset.minVersion && this._log(`Asset minimum version: ${asset.minVersion}`);\r\n        asset.generator && this._log(`Asset generator: ${asset.generator}`);\r\n\r\n        const version = GLTFFileLoader._parseVersion(asset.version);\r\n        if (!version) {\r\n            throw new Error(\"Invalid version: \" + asset.version);\r\n        }\r\n\r\n        if (asset.minVersion !== undefined) {\r\n            const minVersion = GLTFFileLoader._parseVersion(asset.minVersion);\r\n            if (!minVersion) {\r\n                throw new Error(\"Invalid minimum version: \" + asset.minVersion);\r\n            }\r\n\r\n            if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {\r\n                throw new Error(\"Incompatible minimum version: \" + asset.minVersion);\r\n            }\r\n        }\r\n\r\n        const createLoaders: { [key: number]: (parent: GLTFFileLoader) => IGLTFLoader } = {\r\n            1: GLTFFileLoader._CreateGLTFLoaderV1,\r\n            2: GLTFFileLoader._CreateGLTFLoaderV2\r\n        };\r\n\r\n        const createLoader = createLoaders[version.major];\r\n        if (!createLoader) {\r\n            throw new Error(\"Unsupported version: \" + asset.version);\r\n        }\r\n\r\n        return createLoader(this);\r\n    }\r\n\r\n    private _unpackBinary(data: ArrayBuffer): { json: string, bin: Nullable<ArrayBufferView> } {\r\n        this._startPerformanceCounter(\"Unpack binary\");\r\n        this._log(`Binary length: ${data.byteLength}`);\r\n\r\n        const Binary = {\r\n            Magic: 0x46546C67\r\n        };\r\n\r\n        const binaryReader = new BinaryReader(data);\r\n\r\n        const magic = binaryReader.readUint32();\r\n        if (magic !== Binary.Magic) {\r\n            throw new Error(\"Unexpected magic: \" + magic);\r\n        }\r\n\r\n        const version = binaryReader.readUint32();\r\n\r\n        if (this.loggingEnabled) {\r\n            this._log(`Binary version: ${version}`);\r\n        }\r\n\r\n        let unpacked: { json: string, bin: Nullable<ArrayBufferView> };\r\n        switch (version) {\r\n            case 1: {\r\n                unpacked = this._unpackBinaryV1(binaryReader);\r\n                break;\r\n            }\r\n            case 2: {\r\n                unpacked = this._unpackBinaryV2(binaryReader);\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(\"Unsupported version: \" + version);\r\n            }\r\n        }\r\n\r\n        this._endPerformanceCounter(\"Unpack binary\");\r\n        return unpacked;\r\n    }\r\n\r\n    private _unpackBinaryV1(binaryReader: BinaryReader): { json: string, bin: Nullable<ArrayBufferView> } {\r\n        const ContentFormat = {\r\n            JSON: 0\r\n        };\r\n\r\n        const length = binaryReader.readUint32();\r\n        if (length != binaryReader.getLength()) {\r\n            throw new Error(\"Length in header does not match actual data length: \" + length + \" != \" + binaryReader.getLength());\r\n        }\r\n\r\n        const contentLength = binaryReader.readUint32();\r\n        const contentFormat = binaryReader.readUint32();\r\n\r\n        let content: string;\r\n        switch (contentFormat) {\r\n            case ContentFormat.JSON: {\r\n                content = GLTFFileLoader._decodeBufferToText(binaryReader.readUint8Array(contentLength));\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(\"Unexpected content format: \" + contentFormat);\r\n            }\r\n        }\r\n\r\n        const bytesRemaining = binaryReader.getLength() - binaryReader.getPosition();\r\n        const body = binaryReader.readUint8Array(bytesRemaining);\r\n\r\n        return {\r\n            json: content,\r\n            bin: body\r\n        };\r\n    }\r\n\r\n    private _unpackBinaryV2(binaryReader: BinaryReader): { json: string, bin: Nullable<ArrayBufferView> } {\r\n        const ChunkFormat = {\r\n            JSON: 0x4E4F534A,\r\n            BIN: 0x004E4942\r\n        };\r\n\r\n        const length = binaryReader.readUint32();\r\n        if (length !== binaryReader.getLength()) {\r\n            throw new Error(\"Length in header does not match actual data length: \" + length + \" != \" + binaryReader.getLength());\r\n        }\r\n\r\n        // JSON chunk\r\n        const chunkLength = binaryReader.readUint32();\r\n        const chunkFormat = binaryReader.readUint32();\r\n        if (chunkFormat !== ChunkFormat.JSON) {\r\n            throw new Error(\"First chunk format is not JSON\");\r\n        }\r\n        const json = GLTFFileLoader._decodeBufferToText(binaryReader.readUint8Array(chunkLength));\r\n\r\n        // Look for BIN chunk\r\n        let bin: Nullable<Uint8Array> = null;\r\n        while (binaryReader.getPosition() < binaryReader.getLength()) {\r\n            const chunkLength = binaryReader.readUint32();\r\n            const chunkFormat = binaryReader.readUint32();\r\n            switch (chunkFormat) {\r\n                case ChunkFormat.JSON: {\r\n                    throw new Error(\"Unexpected JSON chunk\");\r\n                }\r\n                case ChunkFormat.BIN: {\r\n                    bin = binaryReader.readUint8Array(chunkLength);\r\n                    break;\r\n                }\r\n                default: {\r\n                    // ignore unrecognized chunkFormat\r\n                    binaryReader.skipBytes(chunkLength);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            json: json,\r\n            bin: bin\r\n        };\r\n    }\r\n\r\n    private static _parseVersion(version: string): Nullable<{ major: number, minor: number }> {\r\n        if (version === \"1.0\" || version === \"1.0.1\") {\r\n            return {\r\n                major: 1,\r\n                minor: 0\r\n            };\r\n        }\r\n\r\n        const match = (version + \"\").match(/^(\\d+)\\.(\\d+)/);\r\n        if (!match) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            major: parseInt(match[1]),\r\n            minor: parseInt(match[2])\r\n        };\r\n    }\r\n\r\n    private static _compareVersion(a: { major: number, minor: number }, b: { major: number, minor: number }): number {\r\n        if (a.major > b.major) { return 1; }\r\n        if (a.major < b.major) { return -1; }\r\n        if (a.minor > b.minor) { return 1; }\r\n        if (a.minor < b.minor) { return -1; }\r\n        return 0;\r\n    }\r\n\r\n    private static _decodeBufferToText(buffer: Uint8Array): string {\r\n        let result = \"\";\r\n        const length = buffer.byteLength;\r\n\r\n        for (let i = 0; i < length; i++) {\r\n            result += String.fromCharCode(buffer[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private static readonly _logSpaces = \"                                \";\r\n    private _logIndentLevel = 0;\r\n    private _loggingEnabled = false;\r\n\r\n    /** @hidden */\r\n    public _log = this._logDisabled;\r\n\r\n    /** @hidden */\r\n    public _logOpen(message: string): void {\r\n        this._log(message);\r\n        this._logIndentLevel++;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _logClose(): void {\r\n        --this._logIndentLevel;\r\n    }\r\n\r\n    private _logEnabled(message: string): void {\r\n        const spaces = GLTFFileLoader._logSpaces.substr(0, this._logIndentLevel * 2);\r\n        Tools.Log(`${spaces}${message}`);\r\n    }\r\n\r\n    private _logDisabled(message: string): void {\r\n    }\r\n\r\n    private _capturePerformanceCounters = false;\r\n\r\n    /** @hidden */\r\n    public _startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n\r\n    /** @hidden */\r\n    public _endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n\r\n    private _startPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.StartPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _startPerformanceCounterDisabled(counterName: string): void {\r\n    }\r\n\r\n    private _endPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.EndPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _endPerformanceCounterDisabled(counterName: string): void {\r\n    }\r\n}\r\n\r\nclass BinaryReader {\r\n    private _arrayBuffer: ArrayBuffer;\r\n    private _dataView: DataView;\r\n    private _byteOffset: number;\r\n\r\n    constructor(arrayBuffer: ArrayBuffer) {\r\n        this._arrayBuffer = arrayBuffer;\r\n        this._dataView = new DataView(arrayBuffer);\r\n        this._byteOffset = 0;\r\n    }\r\n\r\n    public getPosition(): number {\r\n        return this._byteOffset;\r\n    }\r\n\r\n    public getLength(): number {\r\n        return this._arrayBuffer.byteLength;\r\n    }\r\n\r\n    public readUint32(): number {\r\n        const value = this._dataView.getUint32(this._byteOffset, true);\r\n        this._byteOffset += 4;\r\n        return value;\r\n    }\r\n\r\n    public readUint8Array(length: number): Uint8Array {\r\n        const value = new Uint8Array(this._arrayBuffer, this._byteOffset, length);\r\n        this._byteOffset += length;\r\n        return value;\r\n    }\r\n\r\n    public skipBytes(length: number): void {\r\n        this._byteOffset += length;\r\n    }\r\n}\r\n\r\nif (SceneLoader) {\r\n    SceneLoader.RegisterPlugin(new GLTFFileLoader());\r\n}\r\n","import { Scene, Texture, Material, Nullable } from \"babylonjs\";\r\nimport { IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { IGLTFRuntime } from \"./glTFLoaderInterfaces\";\r\nimport { GLTFLoaderV1, GLTFLoaderBase } from \"./glTFLoaderV1\";\r\n\r\nexport abstract class GLTFLoaderExtension {\r\n        private _name: string;\r\n\r\n        public constructor(name: string) {\r\n            this._name = name;\r\n        }\r\n\r\n        public get name(): string {\r\n            return this._name;\r\n        }\r\n\r\n        /**\r\n        * Defines an override for loading the runtime\r\n        * Return true to stop further extensions from loading the runtime\r\n        */\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an onverride for creating gltf runtime\r\n     * Return true to stop further extensions from creating the runtime\r\n     */\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading buffers\r\n    * Return true to stop further extensions from loading this buffer\r\n    */\r\n    public loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading texture buffers\r\n    * Return true to stop further extensions from loading this texture data\r\n    */\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for creating textures\r\n    * Return true to stop further extensions from loading this texture\r\n    */\r\n    public createTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading shader strings\r\n    * Return true to stop further extensions from loading this shader data\r\n    */\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading materials\r\n    * Return true to stop further extensions from loading this material\r\n    */\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ---------\r\n    // Utilities\r\n    // ---------\r\n\r\n    public static LoadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\r\n        }, () => {\r\n            setTimeout(() => {\r\n                if (!onSuccess) {\r\n                    return;\r\n                }\r\n                onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n            });\r\n        });\r\n    }\r\n\r\n    public static LoadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\r\n        }, () => {\r\n            setTimeout(() => {\r\n                onSuccess();\r\n            });\r\n        });\r\n    }\r\n\r\n    public static LoadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (bufferView: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n        });\r\n    }\r\n\r\n    public static LoadTextureAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.LoadTextureBufferAsync(gltfRuntime, id,\r\n            (buffer) => {\r\n                if (buffer) {\r\n                    GLTFLoaderExtension.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n                }\r\n            }, onError);\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderData: string | ArrayBuffer) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    private static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    private static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    private static ApplyExtensions(func: (loaderExtension: GLTFLoaderExtension) => boolean, defaultFunc: () => void): void {\r\n        for (var extensionName in GLTFLoaderV1.Extensions) {\r\n            var loaderExtension = GLTFLoaderV1.Extensions[extensionName];\r\n            if (func(loaderExtension)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        defaultFunc();\r\n    }\r\n}","import { Scene, ShaderMaterial, Effect, Nullable, Matrix, Vector2, Vector3, Vector4, Texture, Color4, Node } from \"babylonjs\";\r\nimport { IGLTFTechniqueParameter, EParameterType, ETextureWrapMode, IGLTFAccessor, ETextureFilterType, IGLTFRuntime, IGLTFBufferView, EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\n/**\r\n* Utils functions for GLTF\r\n*/\r\nexport class GLTFUtils {\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param scene: the Scene object\r\n     * @param source: the source node where to pick the matrix\r\n     * @param parameter: the GLTF technique parameter\r\n     * @param uniformName: the name of the shader's uniform\r\n     * @param shaderMaterial: the shader material\r\n     */\r\n    public static SetMatrix(scene: Scene, source: Node, parameter: IGLTFTechniqueParameter, uniformName: string, shaderMaterial: ShaderMaterial | Effect): void {\r\n        var mat: Nullable<Matrix> = null;\r\n\r\n        if (parameter.semantic === \"MODEL\") {\r\n            mat = source.getWorldMatrix();\r\n        }\r\n        else if (parameter.semantic === \"PROJECTION\") {\r\n            mat = scene.getProjectionMatrix();\r\n        }\r\n        else if (parameter.semantic === \"VIEW\") {\r\n            mat = scene.getViewMatrix();\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEW\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\r\n        }\r\n        else if (parameter.semantic === \"MODELINVERSE\") {\r\n            mat = source.getWorldMatrix().invert();\r\n        }\r\n        else if (parameter.semantic === \"VIEWINVERSE\") {\r\n            mat = scene.getViewMatrix().invert();\r\n        }\r\n        else if (parameter.semantic === \"PROJECTIONINVERSE\") {\r\n            mat = scene.getProjectionMatrix().invert();\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEWINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\r\n        }\r\n        else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().invert());\r\n        }\r\n        else {\r\n            debugger;\r\n        }\r\n\r\n        if (mat) {\r\n            switch (parameter.type) {\r\n                case EParameterType.FLOAT_MAT2: shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat)); break;\r\n                case EParameterType.FLOAT_MAT3: shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat)); break;\r\n                case EParameterType.FLOAT_MAT4: shaderMaterial.setMatrix(uniformName, mat); break;\r\n                default: break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param shaderMaterial: the shader material\r\n     * @param uniform: the name of the shader's uniform\r\n     * @param value: the value of the uniform\r\n     * @param type: the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\r\n     */\r\n    public static SetUniform(shaderMaterial: ShaderMaterial | Effect, uniform: string, value: any, type: number): boolean {\r\n        switch (type) {\r\n            case EParameterType.FLOAT: shaderMaterial.setFloat(uniform, value); return true;\r\n            case EParameterType.FLOAT_VEC2: shaderMaterial.setVector2(uniform, Vector2.FromArray(value)); return true;\r\n            case EParameterType.FLOAT_VEC3: shaderMaterial.setVector3(uniform, Vector3.FromArray(value)); return true;\r\n            case EParameterType.FLOAT_VEC4: shaderMaterial.setVector4(uniform, Vector4.FromArray(value)); return true;\r\n            default: return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Returns the wrap mode of the texture\r\n    * @param mode: the mode value\r\n    */\r\n    public static GetWrapMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureWrapMode.CLAMP_TO_EDGE: return Texture.CLAMP_ADDRESSMODE;\r\n            case ETextureWrapMode.MIRRORED_REPEAT: return Texture.MIRROR_ADDRESSMODE;\r\n            case ETextureWrapMode.REPEAT: return Texture.WRAP_ADDRESSMODE;\r\n            default: return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the byte stride giving an accessor\r\n     * @param accessor: the GLTF accessor objet\r\n     */\r\n    public static GetByteStrideFromType(accessor: IGLTFAccessor): number {\r\n        // Needs this function since \"byteStride\" isn't requiered in glTF format\r\n        var type = accessor.type;\r\n\r\n        switch (type) {\r\n            case \"VEC2\": return 2;\r\n            case \"VEC3\": return 3;\r\n            case \"VEC4\": return 4;\r\n            case \"MAT2\": return 4;\r\n            case \"MAT3\": return 9;\r\n            case \"MAT4\": return 16;\r\n            default: return 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture filter mode giving a mode value\r\n     * @param mode: the filter mode value\r\n     */\r\n    public static GetTextureFilterMode(mode: number): ETextureFilterType {\r\n        switch (mode) {\r\n            case ETextureFilterType.LINEAR:\r\n            case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\r\n            case ETextureFilterType.LINEAR_MIPMAP_LINEAR: return Texture.TRILINEAR_SAMPLINGMODE;\r\n            case ETextureFilterType.NEAREST:\r\n            case ETextureFilterType.NEAREST_MIPMAP_NEAREST: return Texture.NEAREST_SAMPLINGMODE;\r\n            default: return Texture.BILINEAR_SAMPLINGMODE;\r\n        }\r\n    }\r\n\r\n    public static GetBufferFromBufferView(gltfRuntime: IGLTFRuntime, bufferView: IGLTFBufferView, byteOffset: number, byteLength: number, componentType: EComponentType): ArrayBufferView {\r\n        var byteOffset = bufferView.byteOffset + byteOffset;\r\n\r\n        var loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\r\n        if (byteOffset + byteLength > loadedBufferView.byteLength) {\r\n            throw new Error(\"Buffer access is out of range\");\r\n        }\r\n\r\n        var buffer = loadedBufferView.buffer;\r\n        byteOffset += loadedBufferView.byteOffset;\r\n\r\n        switch (componentType) {\r\n            case EComponentType.BYTE: return new Int8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_BYTE: return new Uint8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.SHORT: return new Int16Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_SHORT: return new Uint16Array(buffer, byteOffset, byteLength);\r\n            default: return new Float32Array(buffer, byteOffset, byteLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a buffer from its accessor\r\n     * @param gltfRuntime: the GLTF runtime\r\n     * @param accessor: the GLTF accessor\r\n     */\r\n    public static GetBufferFromAccessor(gltfRuntime: IGLTFRuntime, accessor: IGLTFAccessor): any {\r\n        var bufferView: IGLTFBufferView = gltfRuntime.bufferViews[accessor.bufferView];\r\n        var byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\r\n        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\r\n    }\r\n\r\n    /**\r\n     * Decodes a buffer view into a string\r\n     * @param view: the buffer view\r\n     */\r\n    public static DecodeBufferToText(view: ArrayBufferView): string {\r\n        var result = \"\";\r\n        var length = view.byteLength;\r\n\r\n        for (var i = 0; i < length; ++i) {\r\n            result += String.fromCharCode((<any>view)[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the default material of gltf. Related to\r\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\r\n     * @param scene: the Babylon.js scene\r\n     */\r\n    public static GetDefaultMaterial(scene: Scene): ShaderMaterial {\r\n        if (!GLTFUtils._DefaultMaterial) {\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform mat4 worldView;\",\r\n                \"uniform mat4 projection;\",\r\n                \"\",\r\n                \"attribute vec3 position;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_Position = projection * worldView * vec4(position, 1.0);\",\r\n                \"}\"\r\n            ].join(\"\\n\");\r\n\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform vec4 u_emission;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_FragColor = u_emission;\",\r\n                \"}\"\r\n            ].join(\"\\n\");\r\n\r\n            var shaderPath = {\r\n                vertex: \"GLTFDefaultMaterial\",\r\n                fragment: \"GLTFDefaultMaterial\"\r\n            };\r\n\r\n            var options = {\r\n                attributes: [\"position\"],\r\n                uniforms: [\"worldView\", \"projection\", \"u_emission\"],\r\n                samplers: new Array<string>(),\r\n                needAlphaBlending: false\r\n            };\r\n\r\n            GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\r\n            GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\r\n        }\r\n\r\n        return GLTFUtils._DefaultMaterial;\r\n    }\r\n\r\n    // The GLTF default material\r\n    private static _DefaultMaterial: Nullable<ShaderMaterial> = null;\r\n}","export * from \"./glTF\";\r\nexport * from \"./OBJ\";\r\nexport * from \"./STL\";","export * from \"./glTFBinaryExtension\";\r\nexport * from \"./glTFLoaderV1\";\r\nexport * from \"./glTFLoaderExtension\";\r\nexport * from \"./glTFLoaderInterfaces\";\r\nexport * from \"./glTFLoaderUtils\";\r\nexport * from \"./glTFMaterialsCommonExtension\";","import * as Loaders from \"./index\";\r\n\r\n/**\r\n * Legacy support, defining window.BABYLON.OBJLoader... (global variable).\r\n *\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    (<any>globalObject).BABYLON = (<any>globalObject).BABYLON || {};\r\n    for (var loader in Loaders) {\r\n        if (Loaders.hasOwnProperty(loader)) {\r\n            (<any>globalObject).BABYLON[loader] = (<any>Loaders)[loader];\r\n        }\r\n    }\r\n}\r\n\r\nexport * from \"./index\";","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","export * from \"./glTFFileLoader\";\r\nexport * from \"./1.0\";\r\nexport * from \"./2.0\";","import { GLTFLoaderExtension } from \"./glTFLoaderExtension\";\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport { GLTFLoaderBase } from \"./glTFLoaderV1\";\r\nimport { Scene } from \"babylonjs\";\r\nimport { IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { IGLTFRuntime, IGLTFTexture, IGLTFImage, IGLTFBufferView, EComponentType, IGLTFShader } from \"./glTFLoaderInterfaces\";\r\n\r\nimport { GLTFLoaderV1 } from \"./glTFLoaderV1\";\r\n\r\nconst BinaryExtensionBufferName = \"binary_glTF\";\r\n\r\ninterface IGLTFBinaryExtensionShader {\r\n    bufferView: string;\r\n}\r\n\r\ninterface IGLTFBinaryExtensionImage {\r\n    bufferView: string;\r\n    mimeType: string;\r\n    height: number;\r\n    width: number;\r\n}\r\n\r\nexport class GLTFBinaryExtension extends GLTFLoaderExtension {\r\n    private _bin : ArrayBufferView;\r\n\r\n    public constructor() {\r\n        super(\"KHR_binary_glTF\");\r\n    }\r\n\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: (gltfRuntime: IGLTFRuntime) => void, onError: (message: string) => void): boolean {\r\n        var extensionsUsed = (<any>data.json).extensionsUsed;\r\n        if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {\r\n            return false;\r\n        }\r\n\r\n        this._bin = data.bin;\r\n        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n        return true;\r\n    }\r\n\r\n    public loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (id !== BinaryExtensionBufferName) {\r\n            return false;\r\n        }\r\n\r\n        onSuccess(this._bin);\r\n        return true;\r\n    }\r\n\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        var texture: IGLTFTexture = gltfRuntime.textures[id];\r\n        var source: IGLTFImage = gltfRuntime.images[texture.source];\r\n        if (!source.extensions || !(this.name in source.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        var sourceExt: IGLTFBinaryExtensionImage = source.extensions[this.name];\r\n        var bufferView: IGLTFBufferView = gltfRuntime.bufferViews[sourceExt.bufferView];\r\n        var buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n        onSuccess(buffer);\r\n        return true;\r\n    }\r\n\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        var shader: IGLTFShader = gltfRuntime.shaders[id];\r\n        if (!shader.extensions || !(this.name in shader.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        var binaryExtensionShader: IGLTFBinaryExtensionShader = shader.extensions[this.name];\r\n        var bufferView: IGLTFBufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];\r\n        var shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n\r\n        setTimeout(() => {\r\n            var shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);\r\n            onSuccess(shaderString);\r\n        });\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nGLTFLoaderV1.RegisterExtension(new GLTFBinaryExtension());","import { GLTFLoaderExtension, GLTFLoaderBase } from \".\";\n\nimport { IGLTFRuntime, IGLTFMaterial } from \"./glTFLoaderInterfaces\";\n\nimport { HemisphericLight, Vector3, Color3, PointLight, DirectionalLight, SpotLight, Tools, Material, StandardMaterial } from \"babylonjs\";\n\nimport { GLTFLoaderV1 } from \"./glTFLoaderV1\";\n\ninterface IGLTFMaterialsCommonExtensionValues {\n    ambient?: number[] | string;\n    diffuse?: number[] | string;\n    emission?: number[] | string;\n    specular?: number[] | string;\n    shininess?: number;\n    transparency?: number;\n}\n\ninterface IGLTFMaterialsCommonExtension {\n    technique: string;\n    transparent?: number;\n    doubleSided?: boolean;\n    values: IGLTFMaterialsCommonExtensionValues;\n}\n\ninterface IGLTFRuntimeCommonExtension {\n    lights: {[key: string]: IGLTFLightCommonExtension};\n}\n\ninterface IGLTFLightCommonExtension {\n    name: string;\n    type: string;\n\n    ambient?: IGLTFAmbientLightCommonExtension;\n    point?: IGLTFPointLightCommonExtension;\n    directional?: IGLTFDirectionalLightCommonExtension;\n    spot?: IGLTFSpotLightCommonExtension;\n}\n\ninterface IGLTFPointLightCommonExtension {\n    color: number[];\n    constantAttenuation: number;\n    linearAttenuation: number;\n    quadraticAttenuation: number;\n}\n\ninterface IGLTFAmbientLightCommonExtension {\n    color: number[];\n}\n\ninterface IGLTFDirectionalLightCommonExtension {\n    color: number[];\n}\n\ninterface IGLTFSpotLightCommonExtension {\n    color: number[];\n    constantAttenuation: number;\n    fallOffAngle: number;\n    fallOffExponent: number;\n    linearAttenuation: number;\n    quadraticAttenuation: number;\n}\n\nexport class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {\n\n    constructor() {\n        super(\"KHR_materials_common\");\n    }\n\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError: (message: string) => void): boolean {\n        if (!gltfRuntime.extensions) { return false; }\n\n        var extension: IGLTFRuntimeCommonExtension = gltfRuntime.extensions[this.name];\n        if (!extension) { return false; }\n\n        // Create lights\n        var lights = extension.lights;\n        if (lights) {\n            for (var thing in lights) {\n                var light: IGLTFLightCommonExtension = lights[thing];\n\n                switch (light.type) {\n                    case \"ambient\":\n                        var ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\n                        var ambient = light.ambient;\n                        if (ambient) {\n                            ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\n                        }\n                        break;\n                    case \"point\":\n                        var pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\n                        var point = light.point;\n                        if (point) {\n                            pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\n                        }\n                        break;\n                    case \"directional\":\n                        var dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\n                        var directional = light.directional;\n                        if (directional) {\n                            dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\n                        }\n                        break;\n                    case \"spot\":\n                        var spot = light.spot;\n                        if (spot) {\n                            var spotLight = new SpotLight(light.name, new Vector3(0, 10, 0), new Vector3(0, -1, 0),\n                                                        spot.fallOffAngle || Math.PI,\n                                                        spot.fallOffExponent || 0.0,\n                                                        gltfRuntime.scene);\n                            spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\n                        }\n                        break;\n                    default: Tools.Warn(\"GLTF Material Common extension: light type \\\"\" + light.type + \"\\” not supported\"); break;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\n        var material: IGLTFMaterial = gltfRuntime.materials[id];\n        if (!material || !material.extensions) { return false; }\n\n        var extension: IGLTFMaterialsCommonExtension = material.extensions[this.name];\n        if (!extension) { return false; }\n\n        var standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\n        standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n\n        if (extension.technique === \"CONSTANT\") {\n            standardMaterial.disableLighting = true;\n        }\n\n        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\n        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\n        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;\n\n        // Ambient\n        if (typeof extension.values.ambient === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\n        }\n        else {\n            standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\n        }\n\n        // Diffuse\n        if (typeof extension.values.diffuse === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\n        }\n        else {\n            standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\n        }\n\n        // Emission\n        if (typeof extension.values.emission === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\n        }\n        else {\n            standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\n        }\n\n        // Specular\n        if (typeof extension.values.specular === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\n        }\n        else {\n            standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\n        }\n\n        return true;\n    }\n\n    private _loadTexture(gltfRuntime: IGLTFRuntime, id: string, material: StandardMaterial, propertyPath: string, onError: (message: string) => void): void {\n        // Create buffer from texture url\n        GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, (buffer) => {\n            // Create texture from buffer\n            GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => (<any>material)[propertyPath] = texture, onError);\n        }, onError);\n    }\n}\n\nGLTFLoaderV1.RegisterExtension(new GLTFMaterialsCommonExtension());\n","export * from \"./glTFLoader\";\r\nexport * from \"./glTFLoaderExtension\";\r\nexport * from \"./glTFLoaderInterfaces\";\r\nexport * from \"./Extensions\";","import { IFileRequest, Buffer, Animation, Scene, Nullable, Mesh, Material, SceneLoaderProgressEvent, Tools, AbstractMesh, IParticleSystem, Skeleton, AnimationGroup, Geometry, VertexBuffer, MorphTargetManager, MorphTarget, TransformNode, Vector3, Quaternion, Matrix, Bone, Camera, FreeCamera, IAnimationKey, AnimationKeyInterpolation, IndicesArray, PBRMaterial, Color3, BaseTexture, Deferred, Texture, LoadFileError } from \"babylonjs\";\r\nimport { IProperty, AccessorType, CameraType, AnimationChannelTargetPath, AnimationSamplerInterpolation, AccessorComponentType, MaterialAlphaMode, TextureMinFilter, TextureWrapMode, TextureMagFilter, MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\r\nimport { _IAnimationSamplerDataV2, IGLTFV2, ISamplerV2, INodeV2, ISceneV2, IMeshV2,  IAccessorV2, ISkinV2, ICameraV2, IAnimationV2, IAnimationChannelV2, IAnimationSamplerV2, IBufferV2, IBufferViewV2, IMaterialPbrMetallicRoughnessV2, IMaterialV2, ITextureInfoV2, ITextureV2, IImageV2, IMeshPrimitiveV2, IArrayItemV2, _ISamplerDataV2 } from \"./glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtensionV2 } from \"./glTFLoaderExtension\";\r\nimport { IGLTFLoader, GLTFFileLoader, GLTFLoaderState, IGLTFLoaderData, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader\";\r\n\r\ninterface IFileRequestInfo extends IFileRequest {\r\n    _lengthComputable?: boolean;\r\n    _loaded?: number;\r\n    _total?: number;\r\n}\r\n\r\ninterface ILoaderProperty extends IProperty {\r\n    _activeLoaderExtensions: any;\r\n}\r\n\r\n/**\r\n * Helper class for working with arrays when loading the glTF asset\r\n */\r\nexport class ArrayItem {\r\n    /**\r\n     * Gets an item from the given array.\r\n     * @param context The context when loading the asset\r\n     * @param array The array to get the item from\r\n     * @param index The index to the array\r\n     * @returns The array item\r\n     */\r\n    public static Get<T>(context: string, array: ArrayLike<T> | undefined, index: number | undefined): T {\r\n        if (!array || index == undefined || !array[index]) {\r\n            throw new Error(`${context}: Failed to find index (${index})`);\r\n        }\r\n\r\n        return array[index];\r\n    }\r\n\r\n    /**\r\n     * Assign an `index` field to each item of the given array.\r\n     * @param array The array of items\r\n     */\r\n    public static Assign(array?: IArrayItemV2[]): void {\r\n        if (array) {\r\n            for (let index = 0; index < array.length; index++) {\r\n                array[index].index = index;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The glTF 2.0 loader\r\n */\r\nexport class GLTFLoaderV2 implements IGLTFLoader {\r\n    /** The glTF object parsed from the JSON. */\r\n    public gltf: IGLTFV2;\r\n\r\n    /** The Babylon scene when loading the asset. */\r\n    public babylonScene: Scene;\r\n\r\n    /** @hidden */\r\n    public _completePromises = new Array<Promise<any>>();\r\n\r\n    private _disposed = false;\r\n    private _parent: GLTFFileLoader;\r\n    private _state: Nullable<GLTFLoaderState> = null;\r\n    private _extensions: { [name: string]: IGLTFLoaderExtensionV2 } = {};\r\n    private _rootUrl: string;\r\n    private _fileName: string;\r\n    private _uniqueRootUrl: string;\r\n    private _rootBabylonMesh: Mesh;\r\n    private _defaultBabylonMaterialData: { [drawMode: number]: Material } = {};\r\n    private _progressCallback?: (event: SceneLoaderProgressEvent) => void;\r\n    private _requests = new Array<IFileRequestInfo>();\r\n\r\n    private static readonly _DefaultSampler: ISamplerV2 = { index: -1 };\r\n\r\n    private static _ExtensionNames = new Array<string>();\r\n    private static _ExtensionFactories: { [name: string]: (loader: GLTFLoaderV2) => IGLTFLoaderExtensionV2 } = {};\r\n\r\n    /**\r\n     * Registers a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @param factory The factory function that creates the loader extension.\r\n     */\r\n    public static RegisterExtension(name: string, factory: (loader: GLTFLoaderV2) => IGLTFLoaderExtensionV2): void {\r\n        if (GLTFLoaderV2.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name '${name}' already exists`);\r\n        }\r\n\r\n        GLTFLoaderV2._ExtensionFactories[name] = factory;\r\n\r\n        // Keep the order of registration so that extensions registered first are called first.\r\n        GLTFLoaderV2._ExtensionNames.push(name);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a loader extension.\r\n     * @param name The name of the loader extenion.\r\n     * @returns A boolean indicating whether the extension has been unregistered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!GLTFLoaderV2._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n\r\n        delete GLTFLoaderV2._ExtensionFactories[name];\r\n\r\n        const index = GLTFLoaderV2._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            GLTFLoaderV2._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the loader state.\r\n     */\r\n    public get state(): Nullable<GLTFLoaderState> {\r\n        return this._state;\r\n    }\r\n\r\n    /** @hidden */\r\n    constructor(parent: GLTFFileLoader) {\r\n        this._parent = parent;\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n\r\n        this._disposed = true;\r\n\r\n        for (const request of this._requests) {\r\n            request.abort();\r\n        }\r\n\r\n        this._requests.length = 0;\r\n\r\n        delete this.gltf;\r\n        delete this.babylonScene;\r\n        this._completePromises.length = 0;\r\n\r\n        for (const name in this._extensions) {\r\n            const extension = this._extensions[name];\r\n            if (extension.dispose) {\r\n                this._extensions[name].dispose();\r\n            }\r\n        }\r\n\r\n        this._extensions = {};\r\n\r\n        delete this._rootBabylonMesh;\r\n        delete this._progressCallback;\r\n\r\n        this._parent._clear();\r\n    }\r\n\r\n    /** @hidden */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }> {\r\n        return Promise.resolve().then(() => {\r\n            this.babylonScene = scene;\r\n            this._rootUrl = rootUrl;\r\n            this._fileName = fileName || \"scene\";\r\n            this._progressCallback = onProgress;\r\n            this._loadData(data);\r\n\r\n            let nodes: Nullable<Array<number>> = null;\r\n\r\n            if (meshesNames) {\r\n                const nodeMap: { [name: string]: number } = {};\r\n                if (this.gltf.nodes) {\r\n                    for (const node of this.gltf.nodes) {\r\n                        if (node.name) {\r\n                            nodeMap[node.name] = node.index;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const names = (meshesNames instanceof Array) ? meshesNames : [meshesNames];\r\n                nodes = names.map((name) => {\r\n                    const node = nodeMap[name];\r\n                    if (node === undefined) {\r\n                        throw new Error(`Failed to find node '${name}'`);\r\n                    }\r\n\r\n                    return node;\r\n                });\r\n            }\r\n\r\n            return this._loadAsync(nodes, () => {\r\n                return {\r\n                    meshes: this._getMeshes(),\r\n                    particleSystems: [],\r\n                    skeletons: this._getSkeletons(),\r\n                    animationGroups: this._getAnimationGroups()\r\n                };\r\n            });\r\n        });\r\n    }\r\n\r\n    /** @hidden */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            this.babylonScene = scene;\r\n            this._rootUrl = rootUrl;\r\n            this._fileName = fileName || \"scene\";\r\n            this._progressCallback = onProgress;\r\n            this._loadData(data);\r\n            return this._loadAsync(null, () => undefined);\r\n        });\r\n    }\r\n\r\n    private _loadAsync<T>(nodes: Nullable<Array<number>>, resultFunc: () => T): Promise<T> {\r\n        return Promise.resolve().then(() => {\r\n            this._uniqueRootUrl = (this._rootUrl.indexOf(\"file:\") === -1 && this._fileName) ? this._rootUrl : `${this._rootUrl}${Date.now()}/`;\r\n\r\n            this._loadExtensions();\r\n            this._checkExtensions();\r\n\r\n            const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;\r\n            const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;\r\n\r\n            this._parent._startPerformanceCounter(loadingToReadyCounterName);\r\n            this._parent._startPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n            this._setState(GLTFLoaderState.LOADING);\r\n            this._extensionsOnLoading();\r\n\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            if (nodes) {\r\n                promises.push(this.loadSceneAsync(\"#/nodes\", { nodes: nodes, index: -1 }));\r\n            }\r\n            else {\r\n                const scene = ArrayItem.Get(`#/scene`, this.gltf.scenes, this.gltf.scene || 0);\r\n                promises.push(this.loadSceneAsync(`#/scenes/${scene.index}`, scene));\r\n            }\r\n\r\n            if (this._parent.compileMaterials) {\r\n                promises.push(this._compileMaterialsAsync());\r\n            }\r\n\r\n            if (this._parent.compileShadowGenerators) {\r\n                promises.push(this._compileShadowGeneratorsAsync());\r\n            }\r\n\r\n            const resultPromise = Promise.all(promises).then(() => {\r\n                this._setState(GLTFLoaderState.READY);\r\n                this._extensionsOnReady();\r\n\r\n                this._startAnimations();\r\n\r\n                return resultFunc();\r\n            });\r\n\r\n            resultPromise.then(() => {\r\n                this._parent._endPerformanceCounter(loadingToReadyCounterName);\r\n\r\n                Tools.SetImmediate(() => {\r\n                    if (!this._disposed) {\r\n                        Promise.all(this._completePromises).then(() => {\r\n                            this._parent._endPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                            this._setState(GLTFLoaderState.COMPLETE);\r\n\r\n                            this._parent.onCompleteObservable.notifyObservers(undefined);\r\n                            this._parent.onCompleteObservable.clear();\r\n\r\n                            this.dispose();\r\n                        }, (error) => {\r\n                            this._parent.onErrorObservable.notifyObservers(error);\r\n                            this._parent.onErrorObservable.clear();\r\n\r\n                            this.dispose();\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n\r\n            return resultPromise;\r\n        }, (error) => {\r\n            if (!this._disposed) {\r\n                this._parent.onErrorObservable.notifyObservers(error);\r\n                this._parent.onErrorObservable.clear();\r\n\r\n                this.dispose();\r\n            }\r\n\r\n            throw error;\r\n        });\r\n    }\r\n\r\n    private _loadData(data: IGLTFLoaderData): void {\r\n        this.gltf = data.json as IGLTFV2;\r\n        this._setupData();\r\n\r\n        if (data.bin) {\r\n            const buffers = this.gltf.buffers;\r\n            if (buffers && buffers[0] && !buffers[0].uri) {\r\n                const binaryBuffer = buffers[0];\r\n                if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\r\n                    Tools.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);\r\n                }\r\n\r\n                binaryBuffer._data = Promise.resolve(data.bin);\r\n            }\r\n            else {\r\n                Tools.Warn(\"Unexpected BIN chunk\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setupData(): void {\r\n        ArrayItem.Assign(this.gltf.accessors);\r\n        ArrayItem.Assign(this.gltf.animations);\r\n        ArrayItem.Assign(this.gltf.buffers);\r\n        ArrayItem.Assign(this.gltf.bufferViews);\r\n        ArrayItem.Assign(this.gltf.cameras);\r\n        ArrayItem.Assign(this.gltf.images);\r\n        ArrayItem.Assign(this.gltf.materials);\r\n        ArrayItem.Assign(this.gltf.meshes);\r\n        ArrayItem.Assign(this.gltf.nodes);\r\n        ArrayItem.Assign(this.gltf.samplers);\r\n        ArrayItem.Assign(this.gltf.scenes);\r\n        ArrayItem.Assign(this.gltf.skins);\r\n        ArrayItem.Assign(this.gltf.textures);\r\n\r\n        if (this.gltf.nodes) {\r\n            const nodeParents: { [index: number]: number } = {};\r\n            for (const node of this.gltf.nodes) {\r\n                if (node.children) {\r\n                    for (const index of node.children) {\r\n                        nodeParents[index] = node.index;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const rootNode = this._createRootNode();\r\n            for (const node of this.gltf.nodes) {\r\n                const parentIndex = nodeParents[node.index];\r\n                node.parent = parentIndex === undefined ? rootNode : this.gltf.nodes[parentIndex];\r\n            }\r\n        }\r\n    }\r\n\r\n    private _loadExtensions(): void {\r\n        for (const name of GLTFLoaderV2._ExtensionNames) {\r\n            const extension = GLTFLoaderV2._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n\r\n            this._parent.onExtensionLoadedObservable.notifyObservers(extension);\r\n        }\r\n\r\n        this._parent.onExtensionLoadedObservable.clear();\r\n    }\r\n\r\n    private _checkExtensions(): void {\r\n        if (this.gltf.extensionsRequired) {\r\n            for (const name of this.gltf.extensionsRequired) {\r\n                const extension = this._extensions[name];\r\n                if (!extension || !extension.enabled) {\r\n                    throw new Error(`Require extension ${name} is not available`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setState(state: GLTFLoaderState): void {\r\n        this._state = state;\r\n        this.log(GLTFLoaderState[this._state]);\r\n    }\r\n\r\n    private _createRootNode(): INodeV2 {\r\n        this._rootBabylonMesh = new Mesh(\"__root__\", this.babylonScene);\r\n\r\n        const rootNode: INodeV2 = {\r\n            _babylonMesh: this._rootBabylonMesh,\r\n            index: -1\r\n        };\r\n\r\n        switch (this._parent.coordinateSystemMode) {\r\n            case GLTFLoaderCoordinateSystemMode.AUTO: {\r\n                if (!this.babylonScene.useRightHandedSystem) {\r\n                    rootNode.rotation = [0, 1, 0, 0];\r\n                    rootNode.scale = [1, 1, -1];\r\n                    GLTFLoaderV2._LoadTransform(rootNode, this._rootBabylonMesh);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {\r\n                this.babylonScene.useRightHandedSystem = true;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);\r\n            }\r\n        }\r\n\r\n        this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF scene.\r\n     * @param context The context when loading the asset\r\n     * @param scene The glTF scene property\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadSceneAsync(context: string, scene: ISceneV2): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadSceneAsync(context, scene);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${scene.name || \"\"}`);\r\n\r\n        if (scene.nodes) {\r\n            for (let index of scene.nodes) {\r\n                const node = ArrayItem.Get(`${context}/nodes/${index}`, this.gltf.nodes, index);\r\n                promises.push(this.loadNodeAsync(`#/nodes/${node.index}`, node, (babylonMesh) => {\r\n                    babylonMesh.parent = this._rootBabylonMesh;\r\n                }));\r\n            }\r\n        }\r\n\r\n        promises.push(this._loadAnimationsAsync());\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    private _forEachPrimitive(node: INodeV2, callback: (babylonMesh: Mesh) => void): void {\r\n        if (node._primitiveBabylonMeshes) {\r\n            for (const babylonMesh of node._primitiveBabylonMeshes) {\r\n                callback(babylonMesh);\r\n            }\r\n        }\r\n        else {\r\n            callback(node._babylonMesh!);\r\n        }\r\n    }\r\n\r\n    private _getMeshes(): Mesh[] {\r\n        const meshes = new Array<Mesh>();\r\n\r\n        // Root mesh is always first.\r\n        meshes.push(this._rootBabylonMesh);\r\n\r\n        const nodes = this.gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                if (node._babylonMesh) {\r\n                    meshes.push(node._babylonMesh);\r\n                }\r\n\r\n                if (node._primitiveBabylonMeshes) {\r\n                    for (const babylonMesh of node._primitiveBabylonMeshes) {\r\n                        meshes.push(babylonMesh);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return meshes;\r\n    }\r\n\r\n    private _getSkeletons(): Skeleton[] {\r\n        const skeletons = new Array<Skeleton>();\r\n\r\n        const skins = this.gltf.skins;\r\n        if (skins) {\r\n            for (const skin of skins) {\r\n                if (skin._babylonSkeleton) {\r\n                    skeletons.push(skin._babylonSkeleton);\r\n                }\r\n            }\r\n        }\r\n\r\n        return skeletons;\r\n    }\r\n\r\n    private _getAnimationGroups(): AnimationGroup[] {\r\n        const animationGroups = new Array<AnimationGroup>();\r\n\r\n        const animations = this.gltf.animations;\r\n        if (animations) {\r\n            for (const animation of animations) {\r\n                if (animation._babylonAnimationGroup) {\r\n                    animationGroups.push(animation._babylonAnimationGroup);\r\n                }\r\n            }\r\n        }\r\n\r\n        return animationGroups;\r\n    }\r\n\r\n    private _startAnimations(): void {\r\n        switch (this._parent.animationStartMode) {\r\n            case GLTFLoaderAnimationStartMode.NONE: {\r\n                // do nothing\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.FIRST: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                if (babylonAnimationGroups.length !== 0) {\r\n                    babylonAnimationGroups[0].start(true);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.ALL: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                for (const babylonAnimationGroup of babylonAnimationGroups) {\r\n                    babylonAnimationGroup.start(true);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF node.\r\n     * @param context The context when loading the asset\r\n     * @param node The glTF node property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\r\n     */\r\n    public loadNodeAsync(context: string, node: INodeV2, assign: (babylonMesh: Mesh) => void = () => { }): Promise<Mesh> {\r\n        const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (node._babylonMesh) {\r\n            throw new Error(`${context}: Invalid recursive node hierarchy`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${node.name || \"\"}`);\r\n\r\n        const babylonMesh = new Mesh(node.name || `node${node.index}`, this.babylonScene);\r\n        node._babylonMesh = babylonMesh;\r\n\r\n        babylonMesh.setEnabled(false);\r\n        GLTFLoaderV2._LoadTransform(node, babylonMesh);\r\n\r\n        if (node.mesh != undefined) {\r\n            const mesh = ArrayItem.Get(`${context}/mesh`, this.gltf.meshes, node.mesh);\r\n            promises.push(this._loadMeshAsync(`#/meshes/${mesh.index}`, node, mesh, babylonMesh));\r\n        }\r\n\r\n        if (node.camera != undefined) {\r\n            const camera = ArrayItem.Get(`${context}/camera`, this.gltf.cameras, node.camera);\r\n            promises.push(this.loadCameraAsync(`#/cameras/${camera.index}`, camera, (babylonCamera) => {\r\n                babylonCamera.parent = babylonMesh;\r\n            }));\r\n        }\r\n\r\n        if (node.children) {\r\n            for (const index of node.children) {\r\n                const childNode = ArrayItem.Get(`${context}/children/${index}`, this.gltf.nodes, index);\r\n                promises.push(this.loadNodeAsync(`#/nodes/${node.index}`, childNode, (childBabylonMesh) => {\r\n                    // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n                    if (childNode.skin != undefined) {\r\n                        childBabylonMesh.parent = this._rootBabylonMesh;\r\n                        return;\r\n                    }\r\n\r\n                    childBabylonMesh.parent = babylonMesh;\r\n                }));\r\n            }\r\n        }\r\n\r\n        assign(babylonMesh);\r\n        this._parent.onMeshLoadedObservable.notifyObservers(babylonMesh);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            babylonMesh.setEnabled(true);\r\n            return babylonMesh;\r\n        });\r\n    }\r\n\r\n    private _loadMeshAsync(context: string, node: INodeV2, mesh: IMeshV2, babylonMesh: Mesh): Promise<void> {\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${mesh.name || \"\"}`);\r\n\r\n        const primitives = mesh.primitives;\r\n        if (!primitives || primitives.length === 0) {\r\n            throw new Error(`${context}: Primitives are missing`);\r\n        }\r\n\r\n        ArrayItem.Assign(primitives);\r\n        if (primitives.length === 1) {\r\n            const primitive = primitives[0];\r\n            promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, node, mesh, primitive, babylonMesh));\r\n        }\r\n        else {\r\n            node._primitiveBabylonMeshes = [];\r\n            for (const primitive of primitives) {\r\n                const primitiveBabylonMesh = new Mesh(`${mesh.name || babylonMesh.name}_${primitive.index}`, this.babylonScene, babylonMesh);\r\n                node._primitiveBabylonMeshes.push(primitiveBabylonMesh);\r\n                promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, node, mesh, primitive, primitiveBabylonMesh));\r\n                this._parent.onMeshLoadedObservable.notifyObservers(babylonMesh);\r\n            }\r\n        }\r\n\r\n        if (node.skin != undefined) {\r\n            const skin = ArrayItem.Get(`${context}/skin`, this.gltf.skins, node.skin);\r\n            promises.push(this._loadSkinAsync(`#/skins/${skin.index}`, node, skin));\r\n        }\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._forEachPrimitive(node, (babylonMesh) => {\r\n                babylonMesh._refreshBoundingInfo(true);\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadMeshPrimitiveAsync(context: string, node: INodeV2, mesh: IMeshV2, primitive: IMeshPrimitiveV2, babylonMesh: Mesh): Promise<void> {\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        this._createMorphTargets(context, node, mesh, primitive, babylonMesh);\r\n        promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh).then((babylonGeometry) => {\r\n            return this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {\r\n                babylonGeometry.applyToMesh(babylonMesh);\r\n            });\r\n        }));\r\n\r\n        const babylonDrawMode = GLTFLoaderV2._GetDrawMode(context, primitive.mode);\r\n        if (primitive.material == undefined) {\r\n            let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\r\n            if (!babylonMaterial) {\r\n                babylonMaterial = this._createDefaultMaterial(\"__gltf_default\", babylonDrawMode);\r\n                this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n                this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\r\n            }\r\n            babylonMesh.material = babylonMaterial;\r\n        }\r\n        else {\r\n            const material = ArrayItem.Get(`${context}/material`, this.gltf.materials, primitive.material);\r\n            promises.push(this._loadMaterialAsync(`#/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                babylonMesh.material = babylonMaterial;\r\n            }));\r\n        }\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    private _loadVertexDataAsync(context: string, primitive: IMeshPrimitiveV2, babylonMesh: Mesh): Promise<Geometry> {\r\n        const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const attributes = primitive.attributes;\r\n        if (!attributes) {\r\n            throw new Error(`${context}: Attributes are missing`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const babylonGeometry = new Geometry(babylonMesh.name, this.babylonScene);\r\n\r\n        if (primitive.indices == undefined) {\r\n            babylonMesh.isUnIndexed = true;\r\n        }\r\n        else {\r\n            const accessor = ArrayItem.Get(`${context}/indices`, this.gltf.accessors, primitive.indices);\r\n            promises.push(this._loadIndicesAccessorAsync(`#/accessors/${accessor.index}`, accessor).then((data) => {\r\n                babylonGeometry.setIndices(data);\r\n            }));\r\n        }\r\n\r\n        const loadAttribute = (attribute: string, kind: string, callback?: (accessor: IAccessorV2) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n            if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                babylonMesh._delayInfo.push(kind);\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/attributes/${attribute}`, this.gltf.accessors, attributes[attribute]);\r\n            promises.push(this._loadVertexAccessorAsync(`#/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {\r\n                babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\r\n            }));\r\n\r\n            if (callback) {\r\n                callback(accessor);\r\n            }\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n        loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n        loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (accessor) => {\r\n            if (accessor.type === AccessorType.VEC4) {\r\n                babylonMesh.hasVertexAlpha = true;\r\n            }\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonGeometry;\r\n        });\r\n    }\r\n\r\n    private _createMorphTargets(context: string, node: INodeV2, mesh: IMeshV2, primitive: IMeshPrimitiveV2, babylonMesh: Mesh): void {\r\n        if (!primitive.targets) {\r\n            return;\r\n        }\r\n\r\n        if (node._numMorphTargets == undefined) {\r\n            node._numMorphTargets = primitive.targets.length;\r\n        }\r\n        else if (primitive.targets.length !== node._numMorphTargets) {\r\n            throw new Error(`${context}: Primitives do not have the same number of targets`);\r\n        }\r\n\r\n        babylonMesh.morphTargetManager = new MorphTargetManager();\r\n        for (let index = 0; index < primitive.targets.length; index++) {\r\n            const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\r\n            babylonMesh.morphTargetManager.addTarget(new MorphTarget(`morphTarget${index}`, weight));\r\n            // TODO: tell the target whether it has positions, normals, tangents\r\n        }\r\n    }\r\n\r\n    private _loadMorphTargetsAsync(context: string, primitive: IMeshPrimitiveV2, babylonMesh: Mesh, babylonGeometry: Geometry): Promise<void> {\r\n        if (!primitive.targets) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const morphTargetManager = babylonMesh.morphTargetManager!;\r\n        for (let index = 0; index < morphTargetManager.numTargets; index++) {\r\n            const babylonMorphTarget = morphTargetManager.getTarget(index);\r\n            promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    private _loadMorphTargetVertexDataAsync(context: string, babylonGeometry: Geometry, attributes: { [name: string]: number }, babylonMorphTarget: MorphTarget): Promise<void> {\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const loadAttribute = (attribute: string, kind: string, setData: (babylonVertexBuffer: VertexBuffer, data: Float32Array) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\r\n            if (!babylonVertexBuffer) {\r\n                return;\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/${attribute}`, this.gltf.accessors, attributes[attribute]);\r\n            promises.push(this._loadFloatAccessorAsync(`#/accessors/${accessor.index}`, accessor).then((data) => {\r\n                setData(babylonVertexBuffer, data);\r\n            }));\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                data[index] += value;\r\n            });\r\n\r\n            babylonMorphTarget.setPositions(data);\r\n        });\r\n\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                data[index] += value;\r\n            });\r\n\r\n            babylonMorphTarget.setNormals(data);\r\n        });\r\n\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {\r\n            let dataIndex = 0;\r\n            babylonVertexBuffer.forEach(data.length / 3 * 4, (value, index) => {\r\n                // Tangent data for morph targets is stored as xyz delta.\r\n                // The vertexData.tangent is stored as xyzw.\r\n                // So we need to skip every fourth vertexData.tangent.\r\n                if (((index + 1) % 4) !== 0) {\r\n                    data[dataIndex++] += value;\r\n                }\r\n            });\r\n            babylonMorphTarget.setTangents(data);\r\n        });\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    private static _LoadTransform(node: INodeV2, babylonNode: TransformNode): void {\r\n        let position = Vector3.Zero();\r\n        let rotation = Quaternion.Identity();\r\n        let scaling = Vector3.One();\r\n\r\n        if (node.matrix) {\r\n            const matrix = Matrix.FromArray(node.matrix);\r\n            matrix.decompose(scaling, rotation, position);\r\n        }\r\n        else {\r\n            if (node.translation) { position = Vector3.FromArray(node.translation); }\r\n            if (node.rotation) { rotation = Quaternion.FromArray(node.rotation); }\r\n            if (node.scale) { scaling = Vector3.FromArray(node.scale); }\r\n        }\r\n\r\n        babylonNode.position = position;\r\n        babylonNode.rotationQuaternion = rotation;\r\n        babylonNode.scaling = scaling;\r\n    }\r\n\r\n    private _loadSkinAsync(context: string, node: INodeV2, skin: ISkinV2): Promise<void> {\r\n        const assignSkeleton = (skeleton: Skeleton) => {\r\n            this._forEachPrimitive(node, (babylonMesh) => {\r\n                babylonMesh.skeleton = skeleton;\r\n            });\r\n\r\n            // Ignore the TRS of skinned nodes.\r\n            // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n            node._babylonMesh!.position = Vector3.Zero();\r\n            node._babylonMesh!.rotationQuaternion = Quaternion.Identity();\r\n            node._babylonMesh!.scaling = Vector3.One();\r\n        };\r\n\r\n        if (skin._promise) {\r\n            return skin._promise.then(() => {\r\n                assignSkeleton(skin._babylonSkeleton!);\r\n            });\r\n        }\r\n\r\n        const skeletonId = `skeleton${skin.index}`;\r\n        const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this.babylonScene);\r\n        skin._babylonSkeleton = babylonSkeleton;\r\n        this._loadBones(context, skin);\r\n        assignSkeleton(babylonSkeleton);\r\n\r\n        return (skin._promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {\r\n            this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\r\n        }));\r\n    }\r\n\r\n    private _loadBones(context: string, skin: ISkinV2): void {\r\n        const babylonBones: { [index: number]: Bone } = {};\r\n        for (const index of skin.joints) {\r\n            const node = ArrayItem.Get(`${context}/joints/${index}`, this.gltf.nodes, index);\r\n            this._loadBone(node, skin, babylonBones);\r\n        }\r\n    }\r\n\r\n    private _loadBone(node: INodeV2, skin: ISkinV2, babylonBones: { [index: number]: Bone }): Bone {\r\n        let babylonBone = babylonBones[node.index];\r\n        if (babylonBone) {\r\n            return babylonBone;\r\n        }\r\n\r\n        let babylonParentBone: Nullable<Bone> = null;\r\n        if (node.parent && node.parent._babylonMesh !== this._rootBabylonMesh) {\r\n            babylonParentBone = this._loadBone(node.parent, skin, babylonBones);\r\n        }\r\n\r\n        const boneIndex = skin.joints.indexOf(node.index);\r\n\r\n        babylonBone = new Bone(node.name || `joint${node.index}`, skin._babylonSkeleton!, babylonParentBone, this._getNodeMatrix(node), null, null, boneIndex);\r\n        babylonBones[node.index] = babylonBone;\r\n\r\n        node._babylonBones = node._babylonBones || [];\r\n        node._babylonBones.push(babylonBone);\r\n\r\n        return babylonBone;\r\n    }\r\n\r\n    private _loadSkinInverseBindMatricesDataAsync(context: string, skin: ISkinV2): Promise<Nullable<Float32Array>> {\r\n        if (skin.inverseBindMatrices == undefined) {\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this.gltf.accessors, skin.inverseBindMatrices);\r\n        return this._loadFloatAccessorAsync(`#/accessors/${accessor.index}`, accessor);\r\n    }\r\n\r\n    private _updateBoneMatrices(babylonSkeleton: Skeleton, inverseBindMatricesData: Nullable<Float32Array>): void {\r\n        for (const babylonBone of babylonSkeleton.bones) {\r\n            let baseMatrix = Matrix.Identity();\r\n            const boneIndex = babylonBone._index!;\r\n            if (inverseBindMatricesData && boneIndex !== -1) {\r\n                Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\r\n                baseMatrix.invertToRef(baseMatrix);\r\n            }\r\n\r\n            const babylonParentBone = babylonBone.getParent();\r\n            if (babylonParentBone) {\r\n                baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);\r\n            }\r\n\r\n            babylonBone.updateMatrix(baseMatrix, false, false);\r\n            babylonBone._updateDifferenceMatrix(undefined, false);\r\n        }\r\n    }\r\n\r\n    private _getNodeMatrix(node: INodeV2): Matrix {\r\n        return node.matrix ?\r\n            Matrix.FromArray(node.matrix) :\r\n            Matrix.Compose(\r\n                node.scale ? Vector3.FromArray(node.scale) : Vector3.One(),\r\n                node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(),\r\n                node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF camera.\r\n     * @param context The context when loading the asset\r\n     * @param camera The glTF camera property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete\r\n     */\r\n    public loadCameraAsync(context: string, camera: ICameraV2, assign: (babylonCamera: Camera) => void = () => { }): Promise<Camera> {\r\n        const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${camera.name || \"\"}`);\r\n\r\n        const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this.babylonScene, false);\r\n        babylonCamera.rotation = new Vector3(0, Math.PI, 0);\r\n\r\n        switch (camera.type) {\r\n            case CameraType.PERSPECTIVE: {\r\n                const perspective = camera.perspective;\r\n                if (!perspective) {\r\n                    throw new Error(`${context}: Camera perspective properties are missing`);\r\n                }\r\n\r\n                babylonCamera.fov = perspective.yfov;\r\n                babylonCamera.minZ = perspective.znear;\r\n                babylonCamera.maxZ = perspective.zfar || Number.MAX_VALUE;\r\n                break;\r\n            }\r\n            case CameraType.ORTHOGRAPHIC: {\r\n                if (!camera.orthographic) {\r\n                    throw new Error(`${context}: Camera orthographic properties are missing`);\r\n                }\r\n\r\n                babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                babylonCamera.orthoLeft = -camera.orthographic.xmag;\r\n                babylonCamera.orthoRight = camera.orthographic.xmag;\r\n                babylonCamera.orthoBottom = -camera.orthographic.ymag;\r\n                babylonCamera.orthoTop = camera.orthographic.ymag;\r\n                babylonCamera.minZ = camera.orthographic.znear;\r\n                babylonCamera.maxZ = camera.orthographic.zfar;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Invalid camera type (${camera.type})`);\r\n            }\r\n        }\r\n\r\n        assign(babylonCamera);\r\n        this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonCamera;\r\n        });\r\n    }\r\n\r\n    private _loadAnimationsAsync(): Promise<void> {\r\n        const animations = this.gltf.animations;\r\n        if (!animations) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n            promises.push(this.loadAnimationAsync(`#/animations/${animation.index}`, animation));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF animation.\r\n     * @param context The context when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\r\n     */\r\n    public loadAnimationAsync(context: string, animation: IAnimationV2): Promise<AnimationGroup> {\r\n        const promise = this._extensionsLoadAnimationAsync(context, animation);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this.babylonScene);\r\n        animation._babylonAnimationGroup = babylonAnimationGroup;\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        ArrayItem.Assign(animation.channels);\r\n        ArrayItem.Assign(animation.samplers);\r\n\r\n        for (const channel of animation.channels) {\r\n            promises.push(this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, babylonAnimationGroup));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            babylonAnimationGroup.normalize(0);\r\n            return babylonAnimationGroup;\r\n        });\r\n    }\r\n\r\n    private _loadAnimationChannelAsync(context: string, animationContext: string, animation: IAnimationV2, channel: IAnimationChannelV2, babylonAnimationGroup: AnimationGroup): Promise<void> {\r\n        const targetNode = ArrayItem.Get(`${context}/target/node`, this.gltf.nodes, channel.target.node);\r\n\r\n        // Ignore animations that have no animation targets.\r\n        if ((channel.target.path === AnimationChannelTargetPath.WEIGHTS && !targetNode._numMorphTargets) ||\r\n            (channel.target.path !== AnimationChannelTargetPath.WEIGHTS && !targetNode._babylonMesh)) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // Ignore animations targeting TRS of skinned nodes.\r\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n        if (targetNode.skin != undefined && channel.target.path !== AnimationChannelTargetPath.WEIGHTS) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\r\n        return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {\r\n            let targetPath: string;\r\n            let animationType: number;\r\n            switch (channel.target.path) {\r\n                case AnimationChannelTargetPath.TRANSLATION: {\r\n                    targetPath = \"position\";\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.ROTATION: {\r\n                    targetPath = \"rotationQuaternion\";\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.SCALE: {\r\n                    targetPath = \"scaling\";\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.WEIGHTS: {\r\n                    targetPath = \"influence\";\r\n                    animationType = Animation.ANIMATIONTYPE_FLOAT;\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\r\n                }\r\n            }\r\n\r\n            let outputBufferOffset = 0;\r\n            let getNextOutputValue: () => Vector3 | Quaternion | Array<number>;\r\n            switch (targetPath) {\r\n                case \"position\": {\r\n                    getNextOutputValue = () => {\r\n                        const value = Vector3.FromArray(data.output, outputBufferOffset);\r\n                        outputBufferOffset += 3;\r\n                        return value;\r\n                    };\r\n                    break;\r\n                }\r\n                case \"rotationQuaternion\": {\r\n                    getNextOutputValue = () => {\r\n                        const value = Quaternion.FromArray(data.output, outputBufferOffset);\r\n                        outputBufferOffset += 4;\r\n                        return value;\r\n                    };\r\n                    break;\r\n                }\r\n                case \"scaling\": {\r\n                    getNextOutputValue = () => {\r\n                        const value = Vector3.FromArray(data.output, outputBufferOffset);\r\n                        outputBufferOffset += 3;\r\n                        return value;\r\n                    };\r\n                    break;\r\n                }\r\n                case \"influence\": {\r\n                    getNextOutputValue = () => {\r\n                        const value = new Array<number>(targetNode._numMorphTargets!);\r\n                        for (let i = 0; i < targetNode._numMorphTargets!; i++) {\r\n                            value[i] = data.output[outputBufferOffset++];\r\n                        }\r\n                        return value;\r\n                    };\r\n                    break;\r\n                }\r\n            }\r\n\r\n            let getNextKey: (frameIndex: number) => IAnimationKey;\r\n            switch (data.interpolation) {\r\n                case AnimationSamplerInterpolation.STEP: {\r\n                    getNextKey = (frameIndex) => ({\r\n                        frame: data.input[frameIndex],\r\n                        value: getNextOutputValue(),\r\n                        interpolation: AnimationKeyInterpolation.STEP\r\n                    });\r\n                    break;\r\n                }\r\n                case AnimationSamplerInterpolation.LINEAR: {\r\n                    getNextKey = (frameIndex) => ({\r\n                        frame: data.input[frameIndex],\r\n                        value: getNextOutputValue()\r\n                    });\r\n                    break;\r\n                }\r\n                case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                    getNextKey = (frameIndex) => ({\r\n                        frame: data.input[frameIndex],\r\n                        inTangent: getNextOutputValue(),\r\n                        value: getNextOutputValue(),\r\n                        outTangent: getNextOutputValue()\r\n                    });\r\n                    break;\r\n                }\r\n            }\r\n\r\n            const keys = new Array(data.input.length);\r\n            for (let frameIndex = 0; frameIndex < data.input.length; frameIndex++) {\r\n                keys[frameIndex] = getNextKey!(frameIndex);\r\n            }\r\n\r\n            if (targetPath === \"influence\") {\r\n                for (let targetIndex = 0; targetIndex < targetNode._numMorphTargets!; targetIndex++) {\r\n                    const animationName = `${babylonAnimationGroup.name}_channel${babylonAnimationGroup.targetedAnimations.length}`;\r\n                    const babylonAnimation = new Animation(animationName, targetPath, 1, animationType);\r\n                    babylonAnimation.setKeys(keys.map((key) => ({\r\n                        frame: key.frame,\r\n                        inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\r\n                        value: key.value[targetIndex],\r\n                        outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined\r\n                    })));\r\n\r\n                    this._forEachPrimitive(targetNode, (babylonMesh) => {\r\n                        const morphTarget = babylonMesh.morphTargetManager!.getTarget(targetIndex);\r\n                        const babylonAnimationClone = babylonAnimation.clone();\r\n                        morphTarget.animations.push(babylonAnimationClone);\r\n                        babylonAnimationGroup.addTargetedAnimation(babylonAnimationClone, morphTarget);\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                const animationName = `${babylonAnimationGroup.name}_channel${babylonAnimationGroup.targetedAnimations.length}`;\r\n                const babylonAnimation = new Animation(animationName, targetPath, 1, animationType);\r\n                babylonAnimation.setKeys(keys);\r\n\r\n                if (targetNode._babylonBones) {\r\n                    const babylonAnimationTargets = [targetNode._babylonMesh!, ...targetNode._babylonBones];\r\n                    for (const babylonAnimationTarget of babylonAnimationTargets) {\r\n                        babylonAnimationTarget.animations.push(babylonAnimation);\r\n                    }\r\n                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonAnimationTargets);\r\n                }\r\n                else {\r\n                    targetNode._babylonMesh!.animations.push(babylonAnimation);\r\n                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, targetNode._babylonMesh);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadAnimationSamplerAsync(context: string, sampler: IAnimationSamplerV2): Promise<_IAnimationSamplerDataV2> {\r\n        if (sampler._data) {\r\n            return sampler._data;\r\n        }\r\n\r\n        const interpolation = sampler.interpolation || AnimationSamplerInterpolation.LINEAR;\r\n        switch (interpolation) {\r\n            case AnimationSamplerInterpolation.STEP:\r\n            case AnimationSamplerInterpolation.LINEAR:\r\n            case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\r\n            }\r\n        }\r\n\r\n        const inputAccessor = ArrayItem.Get(`${context}/input`, this.gltf.accessors, sampler.input);\r\n        const outputAccessor = ArrayItem.Get(`${context}/output`, this.gltf.accessors, sampler.output);\r\n        sampler._data = Promise.all([\r\n            this._loadFloatAccessorAsync(`#/accessors/${inputAccessor.index}`, inputAccessor),\r\n            this._loadFloatAccessorAsync(`#/accessors/${outputAccessor.index}`, outputAccessor)\r\n        ]).then(([inputData, outputData]) => {\r\n            return {\r\n                input: inputData,\r\n                interpolation: interpolation,\r\n                output: outputData,\r\n            };\r\n        });\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    private _loadBufferAsync(context: string, buffer: IBufferV2): Promise<ArrayBufferView> {\r\n        if (buffer._data) {\r\n            return buffer._data;\r\n        }\r\n\r\n        if (!buffer.uri) {\r\n            throw new Error(`${context}/uri: Value is missing`);\r\n        }\r\n\r\n        buffer._data = this.loadUriAsync(`${context}/uri`, buffer.uri);\r\n\r\n        return buffer._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer view.\r\n     * @param context The context when loading the asset\r\n     * @param bufferView The glTF buffer view property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferViewAsync(context: string, bufferView: IBufferViewV2): Promise<ArrayBufferView> {\r\n        if (bufferView._data) {\r\n            return bufferView._data;\r\n        }\r\n\r\n        const buffer = ArrayItem.Get(`${context}/buffer`, this.gltf.buffers, bufferView.buffer);\r\n        bufferView._data = this._loadBufferAsync(`#/buffers/${buffer.index}`, buffer).then((data) => {\r\n            try {\r\n                return new Uint8Array(data.buffer, data.byteOffset + (bufferView.byteOffset || 0), bufferView.byteLength);\r\n            }\r\n            catch (e) {\r\n                throw new Error(`${context}: ${e.message}`);\r\n            }\r\n        });\r\n\r\n        return bufferView._data;\r\n    }\r\n\r\n    private _loadIndicesAccessorAsync(context: string, accessor: IAccessorV2): Promise<IndicesArray> {\r\n        if (accessor.type !== AccessorType.SCALAR) {\r\n            throw new Error(`${context}/type: Invalid value ${accessor.type}`);\r\n        }\r\n\r\n        if (accessor.componentType !== AccessorComponentType.UNSIGNED_BYTE &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_SHORT &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_INT) {\r\n            throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);\r\n        }\r\n\r\n        if (accessor._data) {\r\n            return accessor._data as Promise<IndicesArray>;\r\n        }\r\n\r\n        const bufferView = ArrayItem.Get(`${context}/bufferView`, this.gltf.bufferViews, accessor.bufferView);\r\n        accessor._data = this.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n            return GLTFLoaderV2._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\r\n        });\r\n\r\n        return accessor._data as Promise<IndicesArray>;\r\n    }\r\n\r\n    private _loadFloatAccessorAsync(context: string, accessor: IAccessorV2): Promise<Float32Array> {\r\n        // TODO: support normalized and stride\r\n\r\n        if (accessor.componentType !== AccessorComponentType.FLOAT) {\r\n            throw new Error(`Invalid component type ${accessor.componentType}`);\r\n        }\r\n\r\n        if (accessor._data) {\r\n            return accessor._data as Promise<Float32Array>;\r\n        }\r\n\r\n        const numComponents = GLTFLoaderV2._GetNumComponents(context, accessor.type);\r\n        const length = numComponents * accessor.count;\r\n\r\n        if (accessor.bufferView == undefined) {\r\n            accessor._data = Promise.resolve(new Float32Array(length));\r\n        }\r\n        else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this.gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                return GLTFLoaderV2._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\r\n            });\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const sparse = accessor.sparse;\r\n            accessor._data = accessor._data.then((data: Float32Array) => {\r\n                const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this.gltf.bufferViews, sparse.indices.bufferView);\r\n                const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this.gltf.bufferViews, sparse.values.bufferView);\r\n                return Promise.all([\r\n                    this.loadBufferViewAsync(`#/bufferViews/${indicesBufferView.index}`, indicesBufferView),\r\n                    this.loadBufferViewAsync(`#/bufferViews/${valuesBufferView.index}`, valuesBufferView)\r\n                ]).then(([indicesData, valuesData]) => {\r\n                    const indices = GLTFLoaderV2._GetTypedArray(`${context}/sparse/indices`, sparse.indices.componentType, indicesData, sparse.indices.byteOffset, sparse.count) as IndicesArray;\r\n                    const values = GLTFLoaderV2._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, numComponents * sparse.count) as Float32Array;\r\n\r\n                    let valuesIndex = 0;\r\n                    for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\r\n                        let dataIndex = indices[indicesIndex] * numComponents;\r\n                        for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {\r\n                            data[dataIndex++] = values[valuesIndex++];\r\n                        }\r\n                    }\r\n\r\n                    return data;\r\n                });\r\n            });\r\n        }\r\n\r\n        return accessor._data as Promise<Float32Array>;\r\n    }\r\n\r\n    private _loadVertexBufferViewAsync(bufferView: IBufferViewV2, kind: string): Promise<Buffer> {\r\n        if (bufferView._babylonBuffer) {\r\n            return bufferView._babylonBuffer;\r\n        }\r\n\r\n        bufferView._babylonBuffer = this.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n            return new Buffer(this.babylonScene.getEngine(), data, false);\r\n        });\r\n\r\n        return bufferView._babylonBuffer;\r\n    }\r\n\r\n    private _loadVertexAccessorAsync(context: string, accessor: IAccessorV2, kind: string): Promise<VertexBuffer> {\r\n        if (accessor._babylonVertexBuffer) {\r\n            return accessor._babylonVertexBuffer;\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(`#/accessors/${accessor.index}`, accessor).then((data) => {\r\n                return new VertexBuffer(this.babylonScene.getEngine(), data, kind, false);\r\n            });\r\n        }\r\n        // HACK: If byte offset is not a multiple of component type byte length then load as a float array instead of using Babylon buffers.\r\n        else if (accessor.byteOffset && accessor.byteOffset % VertexBuffer.GetTypeByteLength(accessor.componentType) !== 0) {\r\n            Tools.Warn(\"Accessor byte offset is not a multiple of component type byte length\");\r\n            accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(`#/accessors/${accessor.index}`, accessor).then((data) => {\r\n                return new VertexBuffer(this.babylonScene.getEngine(), data, kind, false);\r\n            });\r\n        }\r\n        else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this.gltf.bufferViews, accessor.bufferView);\r\n            accessor._babylonVertexBuffer = this._loadVertexBufferViewAsync(bufferView, kind).then((babylonBuffer) => {\r\n                const size = GLTFLoaderV2._GetNumComponents(context, accessor.type);\r\n                return new VertexBuffer(this.babylonScene.getEngine(), babylonBuffer, kind, false, false, bufferView.byteStride,\r\n                    false, accessor.byteOffset, size, accessor.componentType, accessor.normalized, true);\r\n            });\r\n        }\r\n\r\n        return accessor._babylonVertexBuffer;\r\n    }\r\n\r\n    private _loadMaterialMetallicRoughnessPropertiesAsync(context: string, properties: IMaterialPbrMetallicRoughnessV2, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (properties) {\r\n            if (properties.baseColorFactor) {\r\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\r\n                babylonMaterial.alpha = properties.baseColorFactor[3];\r\n            }\r\n            else {\r\n                babylonMaterial.albedoColor = Color3.White();\r\n            }\r\n\r\n            babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\r\n            babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                    babylonMaterial.albedoTexture = texture;\r\n                }));\r\n            }\r\n\r\n            if (properties.metallicRoughnessTexture) {\r\n                promises.push(this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {\r\n                    babylonMaterial.metallicTexture = texture;\r\n                }));\r\n\r\n                babylonMaterial.useMetallnessFromMetallicTextureBlue = true;\r\n                babylonMaterial.useRoughnessFromMetallicTextureGreen = true;\r\n                babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    /** @hidden */\r\n    public _loadMaterialAsync(context: string, material: IMaterialV2, babylonMesh: Mesh, babylonDrawMode: number, assign: (babylonMaterial: Material) => void = () => { }): Promise<Material> {\r\n        const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        material._babylonData = material._babylonData || {};\r\n        let babylonData = material._babylonData[babylonDrawMode];\r\n        if (!babylonData) {\r\n            this.logOpen(`${context} ${material.name || \"\"}`);\r\n\r\n            const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\r\n\r\n            babylonData = {\r\n                material: babylonMaterial,\r\n                meshes: [],\r\n                promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial)\r\n            };\r\n\r\n            material._babylonData[babylonDrawMode] = babylonData;\r\n\r\n            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        babylonData.meshes.push(babylonMesh);\r\n\r\n        babylonMesh.onDisposeObservable.addOnce(() => {\r\n            const index = babylonData.meshes.indexOf(babylonMesh);\r\n            if (index !== -1) {\r\n                babylonData.meshes.splice(index, 1);\r\n            }\r\n        });\r\n\r\n        assign(babylonData.material);\r\n\r\n        return babylonData.promise.then(() => {\r\n            return babylonData.material;\r\n        });\r\n    }\r\n\r\n    private _createDefaultMaterial(name: string, babylonDrawMode: number): Material {\r\n        const babylonMaterial = new PBRMaterial(name, this.babylonScene);\r\n        babylonMaterial.sideOrientation = this.babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        babylonMaterial.fillMode = babylonDrawMode;\r\n        babylonMaterial.enableSpecularAntiAliasing = true;\r\n        babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;\r\n        babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;\r\n        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\r\n        babylonMaterial.metallic = 1;\r\n        babylonMaterial.roughness = 1;\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a Babylon material from a glTF material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonDrawMode The draw mode for the Babylon material\r\n     * @returns The Babylon material\r\n     */\r\n    public createMaterial(context: string, material: IMaterialV2, babylonDrawMode: number): Material {\r\n        const extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const name = material.name || `material${material.index}`;\r\n        return this._createDefaultMaterial(name, babylonDrawMode);\r\n    }\r\n\r\n    /**\r\n     * Loads properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterialV2, babylonMaterial: Material): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n\r\n        if (material.pbrMetallicRoughness) {\r\n            promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));\r\n        }\r\n\r\n        this.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    /**\r\n     * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialBasePropertiesAsync(context: string, material: IMaterialV2, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\r\n        if (material.doubleSided) {\r\n            babylonMaterial.backFaceCulling = false;\r\n            babylonMaterial.twoSidedLighting = true;\r\n        }\r\n\r\n        if (material.normalTexture) {\r\n            promises.push(this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {\r\n                babylonMaterial.bumpTexture = texture;\r\n            }));\r\n\r\n            babylonMaterial.invertNormalMapX = !this.babylonScene.useRightHandedSystem;\r\n            babylonMaterial.invertNormalMapY = this.babylonScene.useRightHandedSystem;\r\n            if (material.normalTexture.scale != undefined) {\r\n                babylonMaterial.bumpTexture.level = material.normalTexture.scale;\r\n            }\r\n        }\r\n\r\n        if (material.occlusionTexture) {\r\n            promises.push(this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {\r\n                babylonMaterial.ambientTexture = texture;\r\n            }));\r\n\r\n            babylonMaterial.useAmbientInGrayScale = true;\r\n            if (material.occlusionTexture.strength != undefined) {\r\n                babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;\r\n            }\r\n        }\r\n\r\n        if (material.emissiveTexture) {\r\n            promises.push(this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {\r\n                babylonMaterial.emissiveTexture = texture;\r\n            }));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    /**\r\n     * Loads the alpha properties from a glTF material into a Babylon material.\r\n     * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     */\r\n    public loadMaterialAlphaProperties(context: string, material: IMaterialV2, babylonMaterial: Material): void {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const alphaMode = material.alphaMode || MaterialAlphaMode.OPAQUE;\r\n        switch (alphaMode) {\r\n            case MaterialAlphaMode.OPAQUE: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.MASK: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;\r\n                babylonMaterial.alphaCutOff = (material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff);\r\n                if (babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoTexture.hasAlpha = true;\r\n                }\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.BLEND: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;\r\n                if (babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoTexture.hasAlpha = true;\r\n                    babylonMaterial.useAlphaFromAlbedoTexture = true;\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF texture info.\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete\r\n     */\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfoV2, assign: (babylonTexture: BaseTexture) => void = () => { }): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        const texture = ArrayItem.Get(`${context}/index`, this.gltf.textures, textureInfo.index);\r\n        const promise = this._loadTextureAsync(`#/textures/${textureInfo.index}`, texture, (babylonTexture) => {\r\n            babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\r\n            assign(babylonTexture);\r\n        });\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    private _loadTextureAsync(context: string, texture: ITextureV2, assign: (babylonTexture: BaseTexture) => void = () => { }): Promise<BaseTexture> {\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${texture.name || \"\"}`);\r\n\r\n        const sampler = (texture.sampler == undefined ? GLTFLoaderV2._DefaultSampler : ArrayItem.Get(`${context}/sampler`, this.gltf.samplers, texture.sampler));\r\n        const samplerData = this._loadSampler(`#/samplers/${sampler.index}`, sampler);\r\n\r\n        const deferred = new Deferred<void>();\r\n        const babylonTexture = new Texture(null, this.babylonScene, samplerData.noMipMaps, false, samplerData.samplingMode, () => {\r\n            if (!this._disposed) {\r\n                deferred.resolve();\r\n            }\r\n        }, (message, exception) => {\r\n            if (!this._disposed) {\r\n                deferred.reject(new Error(`${context}: ${(exception && exception.message) ? exception.message : message || \"Failed to load texture\"}`));\r\n            }\r\n        });\r\n        promises.push(deferred.promise);\r\n\r\n        babylonTexture.name = texture.name || `texture${texture.index}`;\r\n        babylonTexture.wrapU = samplerData.wrapU;\r\n        babylonTexture.wrapV = samplerData.wrapV;\r\n\r\n        const image = ArrayItem.Get(`${context}/source`, this.gltf.images, texture.source);\r\n        promises.push(this.loadImageAsync(`#/images/${image.index}`, image).then((data) => {\r\n            const name = image.uri || `${this._fileName}#image${image.index}`;\r\n            const dataUrl = `data:${this._uniqueRootUrl}${name}`;\r\n            babylonTexture.updateURL(dataUrl, new Blob([data], { type: image.mimeType }));\r\n        }));\r\n\r\n        assign(babylonTexture);\r\n        this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonTexture;\r\n        });\r\n    }\r\n\r\n    private _loadSampler(context: string, sampler: ISamplerV2): _ISamplerDataV2 {\r\n        if (!sampler._data) {\r\n            sampler._data = {\r\n                noMipMaps: (sampler.minFilter === TextureMinFilter.NEAREST || sampler.minFilter === TextureMinFilter.LINEAR),\r\n                samplingMode: GLTFLoaderV2._GetTextureSamplingMode(context, sampler),\r\n                wrapU: GLTFLoaderV2._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),\r\n                wrapV: GLTFLoaderV2._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT)\r\n            };\r\n        }\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF image.\r\n     * @param context The context when loading the asset\r\n     * @param image The glTF image property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadImageAsync(context: string, image: IImageV2): Promise<ArrayBufferView> {\r\n        if (!image._data) {\r\n            this.logOpen(`${context} ${image.name || \"\"}`);\r\n\r\n            if (image.uri) {\r\n                image._data = this.loadUriAsync(`${context}/uri`, image.uri);\r\n            }\r\n            else {\r\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this.gltf.bufferViews, image.bufferView);\r\n                image._data = this.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView);\r\n            }\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        return image._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF uri.\r\n     * @param context The context when loading the asset\r\n     * @param uri The base64 or relative uri\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadUriAsync(context: string, uri: string): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadUriAsync(context, uri);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!GLTFLoaderV2._ValidateUri(uri)) {\r\n            throw new Error(`${context}: '${uri}' is invalid`);\r\n        }\r\n\r\n        if (Tools.IsBase64(uri)) {\r\n            const data = new Uint8Array(Tools.DecodeBase64(uri));\r\n            this.log(`Decoded ${uri.substr(0, 64)}... (${data.length} bytes)`);\r\n            return Promise.resolve(data);\r\n        }\r\n\r\n        this.log(`Loading ${uri}`);\r\n\r\n        return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {\r\n            return new Promise<ArrayBufferView>((resolve, reject) => {\r\n                if (!this._disposed) {\r\n                    const request = Tools.LoadFile(url, (fileData) => {\r\n                        if (!this._disposed) {\r\n                            const data = new Uint8Array(fileData as ArrayBuffer);\r\n                            this.log(`Loaded ${uri} (${data.length} bytes)`);\r\n                            resolve(data);\r\n                        }\r\n                    }, (event) => {\r\n                        if (!this._disposed) {\r\n                            if (request) {\r\n                                request._lengthComputable = event.lengthComputable;\r\n                                request._loaded = event.loaded;\r\n                                request._total = event.total;\r\n                            }\r\n\r\n                            if (this._state === GLTFLoaderState.LOADING) {\r\n                                try {\r\n                                    this._onProgress();\r\n                                }\r\n                                catch (e) {\r\n                                    reject(e);\r\n                                }\r\n                            }\r\n                        }\r\n                    }, this.babylonScene.offlineProvider, true, (request, exception) => {\r\n                        if (!this._disposed) {\r\n                            reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? \": \" + request.status + \" \" + request.statusText : \"\"}`, request));\r\n                        }\r\n                    }) as IFileRequestInfo;\r\n\r\n                    this._requests.push(request);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private _onProgress(): void {\r\n        if (!this._progressCallback) {\r\n            return;\r\n        }\r\n\r\n        let lengthComputable = true;\r\n        let loaded = 0;\r\n        let total = 0;\r\n        for (let request of this._requests) {\r\n            if (request._lengthComputable === undefined || request._loaded === undefined || request._total === undefined) {\r\n                return;\r\n            }\r\n\r\n            lengthComputable = lengthComputable && request._lengthComputable;\r\n            loaded += request._loaded;\r\n            total += request._total;\r\n        }\r\n\r\n        this._progressCallback(new SceneLoaderProgressEvent(lengthComputable, loaded, lengthComputable ? total : 0));\r\n    }\r\n\r\n    private static _GetTextureWrapMode(context: string, mode: TextureWrapMode | undefined): number {\r\n        // Set defaults if undefined\r\n        mode = mode == undefined ? TextureWrapMode.REPEAT : mode;\r\n\r\n        switch (mode) {\r\n            case TextureWrapMode.CLAMP_TO_EDGE: return Texture.CLAMP_ADDRESSMODE;\r\n            case TextureWrapMode.MIRRORED_REPEAT: return Texture.MIRROR_ADDRESSMODE;\r\n            case TextureWrapMode.REPEAT: return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                Tools.Warn(`${context}: Invalid value (${mode})`);\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    private static _GetTextureSamplingMode(context: string, sampler: ISamplerV2): number {\r\n        // Set defaults if undefined\r\n        const magFilter = sampler.magFilter == undefined ? TextureMagFilter.LINEAR : sampler.magFilter;\r\n        const minFilter = sampler.minFilter == undefined ? TextureMinFilter.LINEAR_MIPMAP_LINEAR : sampler.minFilter;\r\n\r\n        if (magFilter === TextureMagFilter.LINEAR) {\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST: return Texture.LINEAR_NEAREST;\r\n                case TextureMinFilter.LINEAR: return Texture.LINEAR_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST: return Texture.LINEAR_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST: return Texture.LINEAR_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR: return Texture.LINEAR_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR: return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Tools.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n            }\r\n        }\r\n        else {\r\n            if (magFilter !== TextureMagFilter.NEAREST) {\r\n                Tools.Warn(`${context}/magFilter: Invalid value (${magFilter})`);\r\n            }\r\n\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST: return Texture.NEAREST_NEAREST;\r\n                case TextureMinFilter.LINEAR: return Texture.NEAREST_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST: return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST: return Texture.NEAREST_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR: return Texture.NEAREST_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR: return Texture.NEAREST_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Tools.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArray(context: string, componentType: AccessorComponentType, bufferView: ArrayBufferView, byteOffset: number | undefined, length: number): ArrayBufferView {\r\n        const buffer = bufferView.buffer;\r\n        byteOffset = bufferView.byteOffset + (byteOffset || 0);\r\n\r\n        try {\r\n            switch (componentType) {\r\n                case AccessorComponentType.BYTE: return new Int8Array(buffer, byteOffset, length);\r\n                case AccessorComponentType.UNSIGNED_BYTE: return new Uint8Array(buffer, byteOffset, length);\r\n                case AccessorComponentType.SHORT: return new Int16Array(buffer, byteOffset, length);\r\n                case AccessorComponentType.UNSIGNED_SHORT: return new Uint16Array(buffer, byteOffset, length);\r\n                case AccessorComponentType.UNSIGNED_INT: return new Uint32Array(buffer, byteOffset, length);\r\n                case AccessorComponentType.FLOAT: return new Float32Array(buffer, byteOffset, length);\r\n                default: throw new Error(`Invalid component type ${componentType}`);\r\n            }\r\n        }\r\n        catch (e) {\r\n            throw new Error(`${context}: ${e}`);\r\n        }\r\n    }\r\n\r\n    private static _GetNumComponents(context: string, type: string): number {\r\n        switch (type) {\r\n            case \"SCALAR\": return 1;\r\n            case \"VEC2\": return 2;\r\n            case \"VEC3\": return 3;\r\n            case \"VEC4\": return 4;\r\n            case \"MAT2\": return 4;\r\n            case \"MAT3\": return 9;\r\n            case \"MAT4\": return 16;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid type (${type})`);\r\n    }\r\n\r\n    private static _ValidateUri(uri: string): boolean {\r\n        return (Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1);\r\n    }\r\n\r\n    private static _GetDrawMode(context: string, mode: number | undefined): number {\r\n        if (mode == undefined) {\r\n            mode = MeshPrimitiveMode.TRIANGLES;\r\n        }\r\n\r\n        switch (mode) {\r\n            case MeshPrimitiveMode.POINTS: return Material.PointListDrawMode;\r\n            case MeshPrimitiveMode.LINES: return Material.LineListDrawMode;\r\n            case MeshPrimitiveMode.LINE_LOOP: return Material.LineLoopDrawMode;\r\n            case MeshPrimitiveMode.LINE_STRIP: return Material.LineStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLES: return Material.TriangleFillMode;\r\n            case MeshPrimitiveMode.TRIANGLE_STRIP: return Material.TriangleStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLE_FAN: return Material.TriangleFanDrawMode;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);\r\n    }\r\n\r\n    private _compileMaterialsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile materials\");\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (this.gltf.materials) {\r\n            for (const material of this.gltf.materials) {\r\n                if (material._babylonData) {\r\n                    for (const babylonDrawMode in material._babylonData) {\r\n                        const babylonData = material._babylonData[babylonDrawMode];\r\n                        for (const babylonMesh of babylonData.meshes) {\r\n                            // Ensure nonUniformScaling is set if necessary.\r\n                            babylonMesh.computeWorldMatrix(true);\r\n\r\n                            const babylonMaterial = babylonData.material;\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\r\n                            if (this._parent.useClipPlane) {\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile materials\");\r\n        });\r\n    }\r\n\r\n    private _compileShadowGeneratorsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const lights = this.babylonScene.lights;\r\n        for (let light of lights) {\r\n            let generator = light.getShadowGenerator();\r\n            if (generator) {\r\n                promises.push(generator.forceCompilationAsync());\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile shadow generators\");\r\n        });\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFLoaderExtensionV2) => void): void {\r\n        for (const name of GLTFLoaderV2._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _applyExtensions<T>(property: IProperty, actionAsync: (extension: IGLTFLoaderExtensionV2) => Nullable<T> | undefined): Nullable<T> {\r\n        for (const name of GLTFLoaderV2._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                const loaderProperty = property as ILoaderProperty;\r\n                loaderProperty._activeLoaderExtensions = loaderProperty._activeLoaderExtensions || {};\r\n                const activeLoaderExtensions = loaderProperty._activeLoaderExtensions;\r\n                if (!activeLoaderExtensions[name]) {\r\n                    activeLoaderExtensions[name] = true;\r\n\r\n                    try {\r\n                        const result = actionAsync(extension);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    }\r\n                    finally {\r\n                        delete activeLoaderExtensions[name];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _extensionsOnLoading(): void {\r\n        this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());\r\n    }\r\n\r\n    private _extensionsOnReady(): void {\r\n        this._forEachExtensions((extension) => extension.onReady && extension.onReady());\r\n    }\r\n\r\n    private _extensionsLoadSceneAsync(context: string, scene: ISceneV2): Nullable<Promise<void>> {\r\n        return this._applyExtensions(scene, (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));\r\n    }\r\n\r\n    private _extensionsLoadNodeAsync(context: string, node: INodeV2, assign: (babylonMesh: Mesh) => void): Nullable<Promise<Mesh>> {\r\n        return this._applyExtensions(node, (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));\r\n    }\r\n\r\n    private _extensionsLoadCameraAsync(context: string, camera: ICameraV2, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\r\n        return this._applyExtensions(camera, (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));\r\n    }\r\n\r\n    private _extensionsLoadVertexDataAsync(context: string, primitive: IMeshPrimitiveV2, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return this._applyExtensions(primitive, (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));\r\n    }\r\n\r\n    private _extensionsLoadMaterialAsync(context: string, material: IMaterialV2, babylonMesh: Mesh, babylonDrawMode: number, assign: (babylonMaterial: Material) => void): Nullable<Promise<Material>> {\r\n        return this._applyExtensions(material, (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign));\r\n    }\r\n\r\n    private _extensionsCreateMaterial(context: string, material: IMaterialV2, babylonDrawMode: number): Nullable<Material> {\r\n        return this._applyExtensions({}, (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));\r\n    }\r\n\r\n    private _extensionsLoadMaterialPropertiesAsync(context: string, material: IMaterialV2, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return this._applyExtensions(material, (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n    }\r\n\r\n    private _extensionsLoadTextureInfoAsync(context: string, textureInfo: ITextureInfoV2, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(textureInfo, (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));\r\n    }\r\n\r\n    private _extensionsLoadAnimationAsync(context: string, animation: IAnimationV2): Nullable<Promise<AnimationGroup>> {\r\n        return this._applyExtensions(animation, (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));\r\n    }\r\n\r\n    private _extensionsLoadUriAsync(context: string, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions({}, (extension) => extension._loadUriAsync && extension._loadUriAsync(context, uri));\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load an glTF extension.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extension from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extension does not exist\r\n     */\r\n    public static LoadExtensionAsync<TExtension = any, TResult = void>(context: string, property: IProperty, extensionName: string, actionAsync: (extensionContext: string, extension: TExtension) => Nullable<Promise<TResult>>): Nullable<Promise<TResult>> {\r\n        if (!property.extensions) {\r\n            return null;\r\n        }\r\n\r\n        const extensions = property.extensions;\r\n\r\n        const extension = extensions[extensionName] as TExtension;\r\n        if (!extension) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extensions/${extensionName}`, extension);\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load a glTF extra.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extra from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extra does not exist\r\n     */\r\n    public static LoadExtraAsync<TExtra = any, TResult = void>(context: string, property: IProperty, extensionName: string, actionAsync: (extraContext: string, extra: TExtra) => Nullable<Promise<TResult>>): Nullable<Promise<TResult>> {\r\n        if (!property.extras) {\r\n            return null;\r\n        }\r\n\r\n        const extras = property.extras;\r\n\r\n        const extra = extras[extensionName] as TExtra;\r\n        if (!extra) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extras/${extensionName}`, extra);\r\n    }\r\n\r\n    /**\r\n     * Increments the indentation level and logs a message.\r\n     * @param message The message to log\r\n     */\r\n    public logOpen(message: string): void {\r\n        this._parent._logOpen(message);\r\n    }\r\n\r\n    /**\r\n     * Decrements the indentation level.\r\n     */\r\n    public logClose(): void {\r\n        this._parent._logClose();\r\n    }\r\n\r\n    /**\r\n     * Logs a message\r\n     * @param message The message to log\r\n     */\r\n    public log(message: string): void {\r\n        this._parent._log(message);\r\n    }\r\n\r\n    /**\r\n     * Starts a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public startPerformanceCounter(counterName: string): void {\r\n        this._parent._startPerformanceCounter(counterName);\r\n    }\r\n\r\n    /**\r\n     * Ends a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public endPerformanceCounter(counterName: string): void {\r\n        this._parent._endPerformanceCounter(counterName);\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTFLoaderV2 = (parent) => new GLTFLoaderV2(parent);\r\n","import { IDisposable, Nullable, Mesh, Camera, Geometry, Material, BaseTexture, AnimationGroup } from \"babylonjs\";\r\nimport { ISceneV2, INodeV2, ICameraV2, IMeshPrimitiveV2, IMaterialV2, ITextureInfoV2, IAnimationV2 } from \"./glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtension } from \"../glTFFileLoader\";\r\n\r\nexport var toto = 0;\r\n\r\n/**\r\n * Interface for a glTF loader extension.\r\n */\r\nexport interface IGLTFLoaderExtensionV2 extends IGLTFLoaderExtension, IDisposable {\r\n    /**\r\n     * Called after the loader state changes to LOADING.\r\n     */\r\n    onLoading?(): void;\r\n\r\n    /**\r\n     * Called after the loader state changes to READY.\r\n     */\r\n    onReady?(): void;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading scenes.\r\n     * @param context The context when loading the asset\r\n     * @param scene The glTF scene property\r\n     * @returns A promise that resolves when the load is complete or null if not handled\r\n     */\r\n    loadSceneAsync?(context: string, scene: ISceneV2): Nullable<Promise<void>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading nodes.\r\n     * @param context The context when loading the asset\r\n     * @param node The glTF node property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete or null if not handled\r\n     */\r\n    loadNodeAsync?(context: string, node: INodeV2, assign: (babylonMesh: Mesh) => void): Nullable<Promise<Mesh>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading cameras.\r\n     * @param context The context when loading the asset\r\n     * @param camera The glTF camera property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete or null if not handled\r\n     */\r\n    loadCameraAsync?(context: string, camera: ICameraV2, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>>;\r\n\r\n    /**\r\n     * @hidden Define this method to modify the default behavior when loading vertex data for mesh primitives.\r\n     * @param context The context when loading the asset\r\n     * @param primitive The glTF mesh primitive property\r\n     * @returns A promise that resolves with the loaded geometry when the load is complete or null if not handled\r\n     */\r\n    _loadVertexDataAsync?(context: string, primitive: IMeshPrimitiveV2, babylonMesh: Mesh): Nullable<Promise<Geometry>>;\r\n\r\n    /**\r\n     * @hidden Define this method to modify the default behavior when loading materials. Load material creates the material and then loads material properties.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon material when the load is complete or null if not handled\r\n     */\r\n    _loadMaterialAsync?(context: string, material: IMaterialV2, babylonMesh: Mesh, babylonDrawMode: number, assign: (babylonMaterial: Material) => void): Nullable<Promise<Material>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when creating materials.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonDrawMode The draw mode for the Babylon material\r\n     * @returns The Babylon material or null if not handled\r\n     */\r\n    createMaterial?(context: string, material: IMaterialV2, babylonDrawMode: number): Nullable<Material>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading material properties.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete or null if not handled\r\n     */\r\n    loadMaterialPropertiesAsync?(context: string, material: IMaterialV2, babylonMaterial: Material): Nullable<Promise<void>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading texture infos.\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete or null if not handled\r\n     */\r\n    loadTextureInfoAsync?(context: string, textureInfo: ITextureInfoV2, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading animations.\r\n     * @param context The context when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete or null if not handled\r\n     */\r\n    loadAnimationAsync?(context: string, animation: IAnimationV2): Nullable<Promise<AnimationGroup>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading uris.\r\n     * @param context The context when loading the asset\r\n     * @param uri The uri to load\r\n     * @returns A promise that resolves with the loaded data when the load is complete or null if not handled\r\n     */\r\n    _loadUriAsync?(context: string, uri: string): Nullable<Promise<ArrayBufferView>>;\r\n}","import { VertexBuffer, Buffer, AnimationGroup, Material, AbstractMesh, Mesh, Bone, Skeleton } from \"babylonjs\";\r\nimport { AnimationSamplerInterpolation, ITexture, ITextureInfo, IGLTF, ISampler, IScene, ISkin, IMesh, IMeshPrimitive, INode, IAccessor, IAnimationChannel, IAnimationSampler, IAnimation, IBuffer, IBufferView, ICamera, IImage, IMaterialNormalTextureInfo, IMaterialOcclusionTextureInfo, IMaterialPbrMetallicRoughness, IMaterial } from \"babylonjs-gltf2interface\";\r\n\r\nexport var toto1 = 0;\r\n\r\n/**\r\n * Loader interface with an index field.\r\n */\r\nexport interface IArrayItemV2 {\r\n    /**\r\n     * The index of this item in the array.\r\n     */\r\n    index: number;\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IAccessorV2 extends IAccessor, IArrayItemV2 {\r\n    /** @hidden */\r\n    _data?: Promise<ArrayBufferView>;\r\n\r\n    /** @hidden */\r\n    _babylonVertexBuffer?: Promise<VertexBuffer>;\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IAnimationChannelV2 extends IAnimationChannel, IArrayItemV2 {\r\n}\r\n\r\n/** @hidden */\r\nexport interface _IAnimationSamplerDataV2 {\r\n    input: Float32Array;\r\n    interpolation: AnimationSamplerInterpolation;\r\n    output: Float32Array;\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IAnimationSamplerV2 extends IAnimationSampler, IArrayItemV2 {\r\n    /** @hidden */\r\n    _data?: Promise<_IAnimationSamplerDataV2>;\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IAnimationV2 extends IAnimation, IArrayItemV2 {\r\n    channels: IAnimationChannelV2[];\r\n    samplers: IAnimationSamplerV2[];\r\n\r\n    /** @hidden */\r\n    _babylonAnimationGroup?: AnimationGroup;\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IBufferV2 extends IBuffer, IArrayItemV2 {\r\n    /** @hidden */\r\n    _data?: Promise<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IBufferViewV2 extends IBufferView, IArrayItemV2 {\r\n    /** @hidden */\r\n    _data?: Promise<ArrayBufferView>;\r\n\r\n    /** @hidden */\r\n    _babylonBuffer?: Promise<Buffer>;\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface ICameraV2 extends ICamera, IArrayItemV2 {\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IImageV2 extends IImage, IArrayItemV2 {\r\n    /** @hidden */\r\n    _data?: Promise<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IMaterialNormalTextureInfoV2 extends IMaterialNormalTextureInfo, ITextureInfo {\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IMaterialOcclusionTextureInfoV2 extends IMaterialOcclusionTextureInfo, ITextureInfo {\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IMaterialPbrMetallicRoughnessV2 extends IMaterialPbrMetallicRoughness {\r\n    baseColorTexture?: ITextureInfoV2;\r\n    metallicRoughnessTexture?: ITextureInfoV2;\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IMaterialV2 extends IMaterial, IArrayItemV2 {\r\n    pbrMetallicRoughness?: IMaterialPbrMetallicRoughnessV2;\r\n    normalTexture?: IMaterialNormalTextureInfoV2;\r\n    occlusionTexture?: IMaterialOcclusionTextureInfoV2;\r\n    emissiveTexture?: ITextureInfoV2;\r\n\r\n    /** @hidden */\r\n    _babylonData?: {\r\n        [drawMode: number]: {\r\n            material: Material;\r\n            meshes: AbstractMesh[];\r\n            promise: Promise<void>;\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IMeshV2 extends IMesh, IArrayItemV2 {\r\n    primitives: IMeshPrimitiveV2[];\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IMeshPrimitiveV2 extends IMeshPrimitive, IArrayItemV2 {\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface INodeV2 extends INode, IArrayItemV2 {\r\n    /**\r\n     * The parent glTF node.\r\n     */\r\n    parent?: INodeV2;\r\n\r\n    /** @hidden */\r\n    _babylonMesh?: Mesh;\r\n\r\n    /** @hidden */\r\n    _primitiveBabylonMeshes?: Mesh[];\r\n\r\n    /** @hidden */\r\n    _babylonBones?: Bone[];\r\n\r\n    /** @hidden */\r\n    _numMorphTargets?: number;\r\n}\r\n\r\n/** @hidden */\r\nexport interface _ISamplerDataV2 {\r\n    noMipMaps: boolean;\r\n    samplingMode: number;\r\n    wrapU: number;\r\n    wrapV: number;\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface ISamplerV2 extends ISampler, IArrayItemV2 {\r\n    /** @hidden */\r\n    _data?: _ISamplerDataV2;\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface ISceneV2 extends IScene, IArrayItemV2 {\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface ISkinV2 extends ISkin, IArrayItemV2 {\r\n    /** @hidden */\r\n    _babylonSkeleton?: Skeleton;\r\n\r\n    /** @hidden */\r\n    _promise?: Promise<void>;\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface ITextureV2 extends ITexture, IArrayItemV2 {\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface ITextureInfoV2 extends ITextureInfo {\r\n}\r\n\r\n/**\r\n * Loader interface with additional members.\r\n */\r\nexport interface IGLTFV2 extends IGLTF {\r\n    accessors?: IAccessorV2[];\r\n    animations?: IAnimationV2[];\r\n    buffers?: IBufferV2[];\r\n    bufferViews?: IBufferViewV2[];\r\n    cameras?: ICameraV2[];\r\n    images?: IImageV2[];\r\n    materials?: IMaterialV2[];\r\n    meshes?: IMeshV2[];\r\n    nodes?: INodeV2[];\r\n    samplers?: ISamplerV2[];\r\n    scenes?: ISceneV2[];\r\n    skins?: ISkinV2[];\r\n    textures?: ITextureV2[];\r\n}\r\n","export * from \"./EXT_lights_image_based\";\r\nexport * from \"./KHR_draco_mesh_compression\";\r\nexport * from \"./KHR_lights_punctual\";\r\nexport * from \"./KHR_materials_pbrSpecularGlossiness\";\r\nexport * from \"./KHR_materials_unlit\";\r\nexport * from \"./KHR_texture_transform\";\r\nexport * from \"./MSFT_audio_emitter\";\r\nexport * from \"./MSFT_lod\";\r\nexport * from \"./MSFT_minecraftMesh\";\r\nexport * from \"./MSFT_sRGBFactors\";","/// <reference path=\"../../../../../dist/preview release/babylon.d.ts\"/>\nvar BABYLON;\n(function (BABYLON) {\n    var GLTF2;\n    (function (GLTF2) {\n        var Loader;\n        (function (Loader) {\n            var Extensions;\n            (function (Extensions) {\n                var NAME = \"EXT_lights_image_based\";\n                /**\n                 * [Specification](https://github.com/KhronosGroup/glTF/blob/eb3e32332042e04691a5f35103f8c261e50d8f1e/extensions/2.0/Khronos/EXT_lights_image_based/README.md) (Experimental)\n                 */\n                var EXT_lights_image_based = /** @class */ (function () {\n                    /** @hidden */\n                    function EXT_lights_image_based(loader) {\n                        /** The name of this extension. */\n                        this.name = NAME;\n                        /** Defines whether this extension is enabled. */\n                        this.enabled = true;\n                        this._loader = loader;\n                    }\n                    /** @hidden */\n                    EXT_lights_image_based.prototype.dispose = function () {\n                        delete this._loader;\n                        delete this._lights;\n                    };\n                    /** @hidden */\n                    EXT_lights_image_based.prototype.onLoading = function () {\n                        var extensions = this._loader.gltf.extensions;\n                        if (extensions && extensions[this.name]) {\n                            var extension = extensions[this.name];\n                            this._lights = extension.lights;\n                        }\n                    };\n                    /** @hidden */\n                    EXT_lights_image_based.prototype.loadSceneAsync = function (context, scene) {\n                        var _this = this;\n                        return GLTF2.GLTFLoader.LoadExtensionAsync(context, scene, this.name, function (extensionContext, extension) {\n                            var promises = new Array();\n                            promises.push(_this._loader.loadSceneAsync(context, scene));\n                            _this._loader.logOpen(\"\" + extensionContext);\n                            var light = GLTF2.ArrayItem.Get(extensionContext + \"/light\", _this._lights, extension.light);\n                            promises.push(_this._loadLightAsync(\"#/extensions/\" + _this.name + \"/lights/\" + extension.light, light).then(function (texture) {\n                                _this._loader.babylonScene.environmentTexture = texture;\n                            }));\n                            _this._loader.logClose();\n                            return Promise.all(promises).then(function () { });\n                        });\n                    };\n                    EXT_lights_image_based.prototype._loadLightAsync = function (context, light) {\n                        var _this = this;\n                        if (!light._loaded) {\n                            var promises = new Array();\n                            this._loader.logOpen(\"\" + context);\n                            var imageData_1 = new Array(light.specularImages.length);\n                            var _loop_1 = function (mipmap) {\n                                var faces = light.specularImages[mipmap];\n                                imageData_1[mipmap] = new Array(faces.length);\n                                var _loop_2 = function (face) {\n                                    var specularImageContext = context + \"/specularImages/\" + mipmap + \"/\" + face;\n                                    this_1._loader.logOpen(\"\" + specularImageContext);\n                                    var index = faces[face];\n                                    var image = GLTF2.ArrayItem.Get(specularImageContext, this_1._loader.gltf.images, index);\n                                    promises.push(this_1._loader.loadImageAsync(\"#/images/\" + index, image).then(function (data) {\n                                        imageData_1[mipmap][face] = data;\n                                    }));\n                                    this_1._loader.logClose();\n                                };\n                                for (var face = 0; face < faces.length; face++) {\n                                    _loop_2(face);\n                                }\n                            };\n                            var this_1 = this;\n                            for (var mipmap = 0; mipmap < light.specularImages.length; mipmap++) {\n                                _loop_1(mipmap);\n                            }\n                            this._loader.logClose();\n                            light._loaded = Promise.all(promises).then(function () {\n                                var babylonTexture = new BABYLON.RawCubeTexture(_this._loader.babylonScene, null, light.specularImageSize);\n                                light._babylonTexture = babylonTexture;\n                                if (light.intensity != undefined) {\n                                    babylonTexture.level = light.intensity;\n                                }\n                                if (light.rotation) {\n                                    var rotation = BABYLON.Quaternion.FromArray(light.rotation);\n                                    // Invert the rotation so that positive rotation is counter-clockwise.\n                                    if (!_this._loader.babylonScene.useRightHandedSystem) {\n                                        rotation = BABYLON.Quaternion.Inverse(rotation);\n                                    }\n                                    BABYLON.Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());\n                                }\n                                var sphericalHarmonics = BABYLON.SphericalHarmonics.FromArray(light.irradianceCoefficients);\n                                sphericalHarmonics.scale(light.intensity);\n                                sphericalHarmonics.convertIrradianceToLambertianRadiance();\n                                var sphericalPolynomial = BABYLON.SphericalPolynomial.FromHarmonics(sphericalHarmonics);\n                                // Compute the lod generation scale to fit exactly to the number of levels available.\n                                var lodGenerationScale = (imageData_1.length - 1) / BABYLON.Scalar.Log2(light.specularImageSize);\n                                return babylonTexture.updateRGBDAsync(imageData_1, sphericalPolynomial, lodGenerationScale);\n                            });\n                        }\n                        return light._loaded.then(function () {\n                            return light._babylonTexture;\n                        });\n                    };\n                    return EXT_lights_image_based;\n                }());\n                Extensions.EXT_lights_image_based = EXT_lights_image_based;\n                GLTF2.GLTFLoader.RegisterExtension(NAME, function (loader) { return new EXT_lights_image_based(loader); });\n            })(Extensions = Loader.Extensions || (Loader.Extensions = {}));\n        })(Loader = GLTF2.Loader || (GLTF2.Loader = {}));\n    })(GLTF2 = BABYLON.GLTF2 || (BABYLON.GLTF2 = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=EXT_lights_image_based.js.map\n","/// <reference path=\"../../../../../dist/preview release/babylon.d.ts\"/>\nvar BABYLON;\n(function (BABYLON) {\n    var GLTF2;\n    (function (GLTF2) {\n        var Loader;\n        (function (Loader) {\n            var Extensions;\n            (function (Extensions) {\n                var NAME = \"KHR_draco_mesh_compression\";\n                /**\n                 * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression)\n                 */\n                var KHR_draco_mesh_compression = /** @class */ (function () {\n                    /** @hidden */\n                    function KHR_draco_mesh_compression(loader) {\n                        /** The name of this extension. */\n                        this.name = NAME;\n                        /** Defines whether this extension is enabled. */\n                        this.enabled = BABYLON.DracoCompression.DecoderAvailable;\n                        this._loader = loader;\n                    }\n                    /** @hidden */\n                    KHR_draco_mesh_compression.prototype.dispose = function () {\n                        if (this._dracoCompression) {\n                            this._dracoCompression.dispose();\n                            delete this._dracoCompression;\n                        }\n                        delete this._loader;\n                    };\n                    /** @hidden */\n                    KHR_draco_mesh_compression.prototype._loadVertexDataAsync = function (context, primitive, babylonMesh) {\n                        var _this = this;\n                        return GLTF2.GLTFLoader.LoadExtensionAsync(context, primitive, this.name, function (extensionContext, extension) {\n                            if (primitive.mode != undefined) {\n                                if (primitive.mode !== 5 /* TRIANGLE_STRIP */ &&\n                                    primitive.mode !== 4 /* TRIANGLES */) {\n                                    throw new Error(context + \": Unsupported mode \" + primitive.mode);\n                                }\n                                // TODO: handle triangle strips\n                                if (primitive.mode === 5 /* TRIANGLE_STRIP */) {\n                                    throw new Error(context + \": Mode \" + primitive.mode + \" is not currently supported\");\n                                }\n                            }\n                            var attributes = {};\n                            var loadAttribute = function (name, kind) {\n                                var uniqueId = extension.attributes[name];\n                                if (uniqueId == undefined) {\n                                    return;\n                                }\n                                babylonMesh._delayInfo = babylonMesh._delayInfo || [];\n                                if (babylonMesh._delayInfo.indexOf(kind) === -1) {\n                                    babylonMesh._delayInfo.push(kind);\n                                }\n                                attributes[kind] = uniqueId;\n                            };\n                            loadAttribute(\"POSITION\", BABYLON.VertexBuffer.PositionKind);\n                            loadAttribute(\"NORMAL\", BABYLON.VertexBuffer.NormalKind);\n                            loadAttribute(\"TANGENT\", BABYLON.VertexBuffer.TangentKind);\n                            loadAttribute(\"TEXCOORD_0\", BABYLON.VertexBuffer.UVKind);\n                            loadAttribute(\"TEXCOORD_1\", BABYLON.VertexBuffer.UV2Kind);\n                            loadAttribute(\"JOINTS_0\", BABYLON.VertexBuffer.MatricesIndicesKind);\n                            loadAttribute(\"WEIGHTS_0\", BABYLON.VertexBuffer.MatricesWeightsKind);\n                            loadAttribute(\"COLOR_0\", BABYLON.VertexBuffer.ColorKind);\n                            var bufferView = GLTF2.ArrayItem.Get(extensionContext, _this._loader.gltf.bufferViews, extension.bufferView);\n                            if (!bufferView._dracoBabylonGeometry) {\n                                bufferView._dracoBabylonGeometry = _this._loader.loadBufferViewAsync(\"#/bufferViews/\" + bufferView.index, bufferView).then(function (data) {\n                                    if (!_this._dracoCompression) {\n                                        _this._dracoCompression = new BABYLON.DracoCompression();\n                                    }\n                                    return _this._dracoCompression.decodeMeshAsync(data, attributes).then(function (babylonVertexData) {\n                                        var babylonGeometry = new BABYLON.Geometry(babylonMesh.name, _this._loader.babylonScene);\n                                        babylonVertexData.applyToGeometry(babylonGeometry);\n                                        return babylonGeometry;\n                                    }).catch(function (error) {\n                                        throw new Error(context + \": \" + error.message);\n                                    });\n                                });\n                            }\n                            return bufferView._dracoBabylonGeometry;\n                        });\n                    };\n                    return KHR_draco_mesh_compression;\n                }());\n                Extensions.KHR_draco_mesh_compression = KHR_draco_mesh_compression;\n                GLTF2.GLTFLoader.RegisterExtension(NAME, function (loader) { return new KHR_draco_mesh_compression(loader); });\n            })(Extensions = Loader.Extensions || (Loader.Extensions = {}));\n        })(Loader = GLTF2.Loader || (GLTF2.Loader = {}));\n    })(GLTF2 = BABYLON.GLTF2 || (BABYLON.GLTF2 = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=KHR_draco_mesh_compression.js.map\n","/// <reference path=\"../../../../../dist/preview release/babylon.d.ts\"/>\nvar BABYLON;\n(function (BABYLON) {\n    var GLTF2;\n    (function (GLTF2) {\n        var Loader;\n        (function (Loader) {\n            var Extensions;\n            (function (Extensions) {\n                var NAME = \"KHR_lights_punctual\";\n                var LightType;\n                (function (LightType) {\n                    LightType[\"DIRECTIONAL\"] = \"directional\";\n                    LightType[\"POINT\"] = \"point\";\n                    LightType[\"SPOT\"] = \"spot\";\n                })(LightType || (LightType = {}));\n                /**\n                 * [Specification](https://github.com/KhronosGroup/glTF/blob/1048d162a44dbcb05aefc1874bfd423cf60135a6/extensions/2.0/Khronos/KHR_lights_punctual/README.md) (Experimental)\n                 */\n                var KHR_lights = /** @class */ (function () {\n                    /** @hidden */\n                    function KHR_lights(loader) {\n                        /** The name of this extension. */\n                        this.name = NAME;\n                        /** Defines whether this extension is enabled. */\n                        this.enabled = true;\n                        this._loader = loader;\n                    }\n                    /** @hidden */\n                    KHR_lights.prototype.dispose = function () {\n                        delete this._loader;\n                        delete this._lights;\n                    };\n                    /** @hidden */\n                    KHR_lights.prototype.onLoading = function () {\n                        var extensions = this._loader.gltf.extensions;\n                        if (extensions && extensions[this.name]) {\n                            var extension = extensions[this.name];\n                            this._lights = extension.lights;\n                        }\n                    };\n                    /** @hidden */\n                    KHR_lights.prototype.loadNodeAsync = function (context, node, assign) {\n                        var _this = this;\n                        return GLTF2.GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) {\n                            return _this._loader.loadNodeAsync(context, node, function (babylonMesh) {\n                                var babylonLight;\n                                var light = GLTF2.ArrayItem.Get(extensionContext, _this._lights, extension.light);\n                                var name = light.name || babylonMesh.name;\n                                switch (light.type) {\n                                    case LightType.DIRECTIONAL: {\n                                        babylonLight = new BABYLON.DirectionalLight(name, BABYLON.Vector3.Backward(), _this._loader.babylonScene);\n                                        break;\n                                    }\n                                    case LightType.POINT: {\n                                        babylonLight = new BABYLON.PointLight(name, BABYLON.Vector3.Zero(), _this._loader.babylonScene);\n                                        break;\n                                    }\n                                    case LightType.SPOT: {\n                                        var babylonSpotLight = new BABYLON.SpotLight(name, BABYLON.Vector3.Zero(), BABYLON.Vector3.Backward(), 0, 1, _this._loader.babylonScene);\n                                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\n                                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\n                                        babylonLight = babylonSpotLight;\n                                        break;\n                                    }\n                                    default: {\n                                        throw new Error(extensionContext + \": Invalid light type (\" + light.type + \")\");\n                                    }\n                                }\n                                babylonLight.falloffType = BABYLON.Light.FALLOFF_GLTF;\n                                babylonLight.diffuse = light.color ? BABYLON.Color3.FromArray(light.color) : BABYLON.Color3.White();\n                                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\n                                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\n                                babylonLight.parent = babylonMesh;\n                                assign(babylonMesh);\n                            });\n                        });\n                    };\n                    return KHR_lights;\n                }());\n                Extensions.KHR_lights = KHR_lights;\n                GLTF2.GLTFLoader.RegisterExtension(NAME, function (loader) { return new KHR_lights(loader); });\n            })(Extensions = Loader.Extensions || (Loader.Extensions = {}));\n        })(Loader = GLTF2.Loader || (GLTF2.Loader = {}));\n    })(GLTF2 = BABYLON.GLTF2 || (BABYLON.GLTF2 = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=KHR_lights_punctual.js.map\n","/// <reference path=\"../../../../../dist/preview release/babylon.d.ts\"/>\nvar BABYLON;\n(function (BABYLON) {\n    var GLTF2;\n    (function (GLTF2) {\n        var Loader;\n        (function (Loader) {\n            var Extensions;\n            (function (Extensions) {\n                var NAME = \"KHR_materials_pbrSpecularGlossiness\";\n                /**\n                 * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness)\n                 */\n                var KHR_materials_pbrSpecularGlossiness = /** @class */ (function () {\n                    /** @hidden */\n                    function KHR_materials_pbrSpecularGlossiness(loader) {\n                        /** The name of this extension. */\n                        this.name = NAME;\n                        /** Defines whether this extension is enabled. */\n                        this.enabled = true;\n                        this._loader = loader;\n                    }\n                    /** @hidden */\n                    KHR_materials_pbrSpecularGlossiness.prototype.dispose = function () {\n                        delete this._loader;\n                    };\n                    /** @hidden */\n                    KHR_materials_pbrSpecularGlossiness.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n                        var _this = this;\n                        return GLTF2.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) {\n                            var promises = new Array();\n                            promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n                            promises.push(_this._loadSpecularGlossinessPropertiesAsync(extensionContext, material, extension, babylonMaterial));\n                            _this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\n                            return Promise.all(promises).then(function () { });\n                        });\n                    };\n                    KHR_materials_pbrSpecularGlossiness.prototype._loadSpecularGlossinessPropertiesAsync = function (context, material, properties, babylonMaterial) {\n                        if (!(babylonMaterial instanceof BABYLON.PBRMaterial)) {\n                            throw new Error(context + \": Material type not supported\");\n                        }\n                        var promises = new Array();\n                        babylonMaterial.metallic = null;\n                        babylonMaterial.roughness = null;\n                        if (properties.diffuseFactor) {\n                            babylonMaterial.albedoColor = BABYLON.Color3.FromArray(properties.diffuseFactor);\n                            babylonMaterial.alpha = properties.diffuseFactor[3];\n                        }\n                        else {\n                            babylonMaterial.albedoColor = BABYLON.Color3.White();\n                        }\n                        babylonMaterial.reflectivityColor = properties.specularFactor ? BABYLON.Color3.FromArray(properties.specularFactor) : BABYLON.Color3.White();\n                        babylonMaterial.microSurface = properties.glossinessFactor == undefined ? 1 : properties.glossinessFactor;\n                        if (properties.diffuseTexture) {\n                            promises.push(this._loader.loadTextureInfoAsync(context + \"/diffuseTexture\", properties.diffuseTexture, function (texture) {\n                                babylonMaterial.albedoTexture = texture;\n                                return Promise.resolve();\n                            }));\n                        }\n                        if (properties.specularGlossinessTexture) {\n                            promises.push(this._loader.loadTextureInfoAsync(context + \"/specularGlossinessTexture\", properties.specularGlossinessTexture, function (texture) {\n                                babylonMaterial.reflectivityTexture = texture;\n                                return Promise.resolve();\n                            }));\n                            babylonMaterial.reflectivityTexture.hasAlpha = true;\n                            babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;\n                        }\n                        return Promise.all(promises).then(function () { });\n                    };\n                    return KHR_materials_pbrSpecularGlossiness;\n                }());\n                Extensions.KHR_materials_pbrSpecularGlossiness = KHR_materials_pbrSpecularGlossiness;\n                GLTF2.GLTFLoader.RegisterExtension(NAME, function (loader) { return new KHR_materials_pbrSpecularGlossiness(loader); });\n            })(Extensions = Loader.Extensions || (Loader.Extensions = {}));\n        })(Loader = GLTF2.Loader || (GLTF2.Loader = {}));\n    })(GLTF2 = BABYLON.GLTF2 || (BABYLON.GLTF2 = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=KHR_materials_pbrSpecularGlossiness.js.map\n","/// <reference path=\"../../../../../dist/preview release/babylon.d.ts\"/>\nvar BABYLON;\n(function (BABYLON) {\n    var GLTF2;\n    (function (GLTF2) {\n        var Loader;\n        (function (Loader) {\n            var Extensions;\n            (function (Extensions) {\n                var NAME = \"KHR_materials_unlit\";\n                /**\n                 * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit)\n                 */\n                var KHR_materials_unlit = /** @class */ (function () {\n                    /** @hidden */\n                    function KHR_materials_unlit(loader) {\n                        /** The name of this extension. */\n                        this.name = NAME;\n                        /** Defines whether this extension is enabled. */\n                        this.enabled = true;\n                        this._loader = loader;\n                    }\n                    /** @hidden */\n                    KHR_materials_unlit.prototype.dispose = function () {\n                        delete this._loader;\n                    };\n                    /** @hidden */\n                    KHR_materials_unlit.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n                        var _this = this;\n                        return GLTF2.GLTFLoader.LoadExtensionAsync(context, material, this.name, function () {\n                            return _this._loadUnlitPropertiesAsync(context, material, babylonMaterial);\n                        });\n                    };\n                    KHR_materials_unlit.prototype._loadUnlitPropertiesAsync = function (context, material, babylonMaterial) {\n                        if (!(babylonMaterial instanceof BABYLON.PBRMaterial)) {\n                            throw new Error(context + \": Material type not supported\");\n                        }\n                        var promises = new Array();\n                        babylonMaterial.unlit = true;\n                        var properties = material.pbrMetallicRoughness;\n                        if (properties) {\n                            if (properties.baseColorFactor) {\n                                babylonMaterial.albedoColor = BABYLON.Color3.FromArray(properties.baseColorFactor);\n                                babylonMaterial.alpha = properties.baseColorFactor[3];\n                            }\n                            else {\n                                babylonMaterial.albedoColor = BABYLON.Color3.White();\n                            }\n                            if (properties.baseColorTexture) {\n                                promises.push(this._loader.loadTextureInfoAsync(context + \"/baseColorTexture\", properties.baseColorTexture, function (texture) {\n                                    babylonMaterial.albedoTexture = texture;\n                                    return Promise.resolve();\n                                }));\n                            }\n                        }\n                        if (material.doubleSided) {\n                            babylonMaterial.backFaceCulling = false;\n                            babylonMaterial.twoSidedLighting = true;\n                        }\n                        this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\n                        return Promise.all(promises).then(function () { });\n                    };\n                    return KHR_materials_unlit;\n                }());\n                Extensions.KHR_materials_unlit = KHR_materials_unlit;\n                GLTF2.GLTFLoader.RegisterExtension(NAME, function (loader) { return new KHR_materials_unlit(loader); });\n            })(Extensions = Loader.Extensions || (Loader.Extensions = {}));\n        })(Loader = GLTF2.Loader || (GLTF2.Loader = {}));\n    })(GLTF2 = BABYLON.GLTF2 || (BABYLON.GLTF2 = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=KHR_materials_unlit.js.map\n","/// <reference path=\"../../../../../dist/preview release/babylon.d.ts\"/>\nvar BABYLON;\n(function (BABYLON) {\n    var GLTF2;\n    (function (GLTF2) {\n        var Loader;\n        (function (Loader) {\n            var Extensions;\n            (function (Extensions) {\n                var NAME = \"KHR_texture_transform\";\n                /**\n                 * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md)\n                 */\n                var KHR_texture_transform = /** @class */ (function () {\n                    /** @hidden */\n                    function KHR_texture_transform(loader) {\n                        /** The name of this extension. */\n                        this.name = NAME;\n                        /** Defines whether this extension is enabled. */\n                        this.enabled = true;\n                        this._loader = loader;\n                    }\n                    /** @hidden */\n                    KHR_texture_transform.prototype.dispose = function () {\n                        delete this._loader;\n                    };\n                    /** @hidden */\n                    KHR_texture_transform.prototype.loadTextureInfoAsync = function (context, textureInfo, assign) {\n                        var _this = this;\n                        return GLTF2.GLTFLoader.LoadExtensionAsync(context, textureInfo, this.name, function (extensionContext, extension) {\n                            return _this._loader.loadTextureInfoAsync(context, textureInfo, function (babylonTexture) {\n                                if (!(babylonTexture instanceof BABYLON.Texture)) {\n                                    throw new Error(extensionContext + \": Texture type not supported\");\n                                }\n                                if (extension.offset) {\n                                    babylonTexture.uOffset = extension.offset[0];\n                                    babylonTexture.vOffset = extension.offset[1];\n                                }\n                                // Always rotate around the origin.\n                                babylonTexture.uRotationCenter = 0;\n                                babylonTexture.vRotationCenter = 0;\n                                if (extension.rotation) {\n                                    babylonTexture.wAng = -extension.rotation;\n                                }\n                                if (extension.scale) {\n                                    babylonTexture.uScale = extension.scale[0];\n                                    babylonTexture.vScale = extension.scale[1];\n                                }\n                                if (extension.texCoord != undefined) {\n                                    babylonTexture.coordinatesIndex = extension.texCoord;\n                                }\n                                assign(babylonTexture);\n                            });\n                        });\n                    };\n                    return KHR_texture_transform;\n                }());\n                Extensions.KHR_texture_transform = KHR_texture_transform;\n                GLTF2.GLTFLoader.RegisterExtension(NAME, function (loader) { return new KHR_texture_transform(loader); });\n            })(Extensions = Loader.Extensions || (Loader.Extensions = {}));\n        })(Loader = GLTF2.Loader || (GLTF2.Loader = {}));\n    })(GLTF2 = BABYLON.GLTF2 || (BABYLON.GLTF2 = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=KHR_texture_transform.js.map\n","/// <reference path=\"../../../../../dist/preview release/babylon.d.ts\"/>\nvar BABYLON;\n(function (BABYLON) {\n    var GLTF2;\n    (function (GLTF2) {\n        var Loader;\n        (function (Loader) {\n            var Extensions;\n            (function (Extensions) {\n                var NAME = \"MSFT_audio_emitter\";\n                /**\n                 * [Specification](https://github.com/najadojo/glTF/tree/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter)\n                 */\n                var MSFT_audio_emitter = /** @class */ (function () {\n                    /** @hidden */\n                    function MSFT_audio_emitter(loader) {\n                        /** The name of this extension. */\n                        this.name = NAME;\n                        /** Defines whether this extension is enabled. */\n                        this.enabled = true;\n                        this._loader = loader;\n                    }\n                    /** @hidden */\n                    MSFT_audio_emitter.prototype.dispose = function () {\n                        delete this._loader;\n                        delete this._clips;\n                        delete this._emitters;\n                    };\n                    /** @hidden */\n                    MSFT_audio_emitter.prototype.onLoading = function () {\n                        var extensions = this._loader.gltf.extensions;\n                        if (extensions && extensions[this.name]) {\n                            var extension = extensions[this.name];\n                            this._clips = extension.clips;\n                            this._emitters = extension.emitters;\n                            GLTF2.ArrayItem.Assign(this._clips);\n                            GLTF2.ArrayItem.Assign(this._emitters);\n                        }\n                    };\n                    /** @hidden */\n                    MSFT_audio_emitter.prototype.loadSceneAsync = function (context, scene) {\n                        var _this = this;\n                        return GLTF2.GLTFLoader.LoadExtensionAsync(context, scene, this.name, function (extensionContext, extension) {\n                            var promises = new Array();\n                            promises.push(_this._loader.loadSceneAsync(context, scene));\n                            for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {\n                                var emitterIndex = _a[_i];\n                                var emitter = GLTF2.ArrayItem.Get(extensionContext + \"/emitters\", _this._emitters, emitterIndex);\n                                if (emitter.refDistance != undefined || emitter.maxDistance != undefined || emitter.rolloffFactor != undefined ||\n                                    emitter.distanceModel != undefined || emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                                    throw new Error(extensionContext + \": Direction or Distance properties are not allowed on emitters attached to a scene\");\n                                }\n                                promises.push(_this._loadEmitterAsync(extensionContext + \"/emitters/\" + emitter.index, emitter));\n                            }\n                            return Promise.all(promises).then(function () { });\n                        });\n                    };\n                    /** @hidden */\n                    MSFT_audio_emitter.prototype.loadNodeAsync = function (context, node, assign) {\n                        var _this = this;\n                        return GLTF2.GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) {\n                            var promises = new Array();\n                            return _this._loader.loadNodeAsync(extensionContext, node, function (babylonMesh) {\n                                var _loop_1 = function (emitterIndex) {\n                                    var emitter = GLTF2.ArrayItem.Get(extensionContext + \"/emitters\", _this._emitters, emitterIndex);\n                                    promises.push(_this._loadEmitterAsync(extensionContext + \"/emitters/\" + emitter.index, emitter).then(function () {\n                                        for (var _i = 0, _a = emitter._babylonSounds; _i < _a.length; _i++) {\n                                            var sound = _a[_i];\n                                            sound.attachToMesh(babylonMesh);\n                                            if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                                                sound.setLocalDirectionToMesh(BABYLON.Vector3.Forward());\n                                                sound.setDirectionalCone(2 * BABYLON.Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle), 2 * BABYLON.Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle), 0);\n                                            }\n                                        }\n                                    }));\n                                };\n                                for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {\n                                    var emitterIndex = _a[_i];\n                                    _loop_1(emitterIndex);\n                                }\n                                assign(babylonMesh);\n                            }).then(function (babylonMesh) {\n                                return Promise.all(promises).then(function () {\n                                    return babylonMesh;\n                                });\n                            });\n                        });\n                    };\n                    /** @hidden */\n                    MSFT_audio_emitter.prototype.loadAnimationAsync = function (context, animation) {\n                        var _this = this;\n                        return GLTF2.GLTFLoader.LoadExtensionAsync(context, animation, this.name, function (extensionContext, extension) {\n                            return _this._loader.loadAnimationAsync(context, animation).then(function (babylonAnimationGroup) {\n                                var promises = new Array();\n                                GLTF2.ArrayItem.Assign(extension.events);\n                                for (var _i = 0, _a = extension.events; _i < _a.length; _i++) {\n                                    var event_1 = _a[_i];\n                                    promises.push(_this._loadAnimationEventAsync(extensionContext + \"/events/\" + event_1.index, context, animation, event_1, babylonAnimationGroup));\n                                }\n                                return Promise.all(promises).then(function () {\n                                    return babylonAnimationGroup;\n                                });\n                            });\n                        });\n                    };\n                    MSFT_audio_emitter.prototype._loadClipAsync = function (context, clip) {\n                        if (clip._objectURL) {\n                            return clip._objectURL;\n                        }\n                        var promise;\n                        if (clip.uri) {\n                            promise = this._loader.loadUriAsync(context, clip.uri);\n                        }\n                        else {\n                            var bufferView = GLTF2.ArrayItem.Get(context + \"/bufferView\", this._loader.gltf.bufferViews, clip.bufferView);\n                            promise = this._loader.loadBufferViewAsync(\"#/bufferViews/\" + bufferView.index, bufferView);\n                        }\n                        clip._objectURL = promise.then(function (data) {\n                            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\n                        });\n                        return clip._objectURL;\n                    };\n                    MSFT_audio_emitter.prototype._loadEmitterAsync = function (context, emitter) {\n                        var _this = this;\n                        emitter._babylonSounds = emitter._babylonSounds || [];\n                        if (!emitter._babylonData) {\n                            var clipPromises = new Array();\n                            var name_1 = emitter.name || \"emitter\" + emitter.index;\n                            var options_1 = {\n                                loop: false,\n                                autoplay: false,\n                                volume: emitter.volume == undefined ? 1 : emitter.volume,\n                            };\n                            var _loop_2 = function (i) {\n                                var clipContext = \"#/extensions/\" + this_1.name + \"/clips\";\n                                var clip = GLTF2.ArrayItem.Get(clipContext, this_1._clips, emitter.clips[i].clip);\n                                clipPromises.push(this_1._loadClipAsync(clipContext + \"/\" + emitter.clips[i].clip, clip).then(function (objectURL) {\n                                    var sound = emitter._babylonSounds[i] = new BABYLON.Sound(name_1, objectURL, _this._loader.babylonScene, null, options_1);\n                                    sound.refDistance = emitter.refDistance || 1;\n                                    sound.maxDistance = emitter.maxDistance || 256;\n                                    sound.rolloffFactor = emitter.rolloffFactor || 1;\n                                    sound.distanceModel = emitter.distanceModel || 'exponential';\n                                    sound._positionInEmitterSpace = true;\n                                }));\n                            };\n                            var this_1 = this;\n                            for (var i = 0; i < emitter.clips.length; i++) {\n                                _loop_2(i);\n                            }\n                            var promise = Promise.all(clipPromises).then(function () {\n                                var weights = emitter.clips.map(function (clip) { return clip.weight || 1; });\n                                var weightedSound = new BABYLON.WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\n                                if (emitter.innerAngle) {\n                                    weightedSound.directionalConeInnerAngle = 2 * BABYLON.Tools.ToDegrees(emitter.innerAngle);\n                                }\n                                if (emitter.outerAngle) {\n                                    weightedSound.directionalConeOuterAngle = 2 * BABYLON.Tools.ToDegrees(emitter.outerAngle);\n                                }\n                                if (emitter.volume) {\n                                    weightedSound.volume = emitter.volume;\n                                }\n                                emitter._babylonData.sound = weightedSound;\n                            });\n                            emitter._babylonData = {\n                                loaded: promise\n                            };\n                        }\n                        return emitter._babylonData.loaded;\n                    };\n                    MSFT_audio_emitter.prototype._getEventAction = function (context, sound, action, time, startOffset) {\n                        switch (action) {\n                            case \"play\" /* play */: {\n                                return function (currentFrame) {\n                                    var frameOffset = (startOffset || 0) + (currentFrame - time);\n                                    sound.play(frameOffset);\n                                };\n                            }\n                            case \"stop\" /* stop */: {\n                                return function (currentFrame) {\n                                    sound.stop();\n                                };\n                            }\n                            case \"pause\" /* pause */: {\n                                return function (currentFrame) {\n                                    sound.pause();\n                                };\n                            }\n                            default: {\n                                throw new Error(context + \": Unsupported action \" + action);\n                            }\n                        }\n                    };\n                    MSFT_audio_emitter.prototype._loadAnimationEventAsync = function (context, animationContext, animation, event, babylonAnimationGroup) {\n                        var _this = this;\n                        if (babylonAnimationGroup.targetedAnimations.length == 0) {\n                            return Promise.resolve();\n                        }\n                        var babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\n                        var emitterIndex = event.emitter;\n                        var emitter = GLTF2.ArrayItem.Get(\"#/extensions/\" + this.name + \"/emitters\", this._emitters, emitterIndex);\n                        return this._loadEmitterAsync(context, emitter).then(function () {\n                            var sound = emitter._babylonData.sound;\n                            if (sound) {\n                                var babylonAnimationEvent = new BABYLON.AnimationEvent(event.time, _this._getEventAction(context, sound, event.action, event.time, event.startOffset));\n                                babylonAnimation.animation.addEvent(babylonAnimationEvent);\n                                // Make sure all started audio stops when this animation is terminated.\n                                babylonAnimationGroup.onAnimationGroupEndObservable.add(function () {\n                                    sound.stop();\n                                });\n                                babylonAnimationGroup.onAnimationGroupPauseObservable.add(function () {\n                                    sound.pause();\n                                });\n                            }\n                        });\n                    };\n                    return MSFT_audio_emitter;\n                }());\n                Extensions.MSFT_audio_emitter = MSFT_audio_emitter;\n                GLTF2.GLTFLoader.RegisterExtension(NAME, function (loader) { return new MSFT_audio_emitter(loader); });\n            })(Extensions = Loader.Extensions || (Loader.Extensions = {}));\n        })(Loader = GLTF2.Loader || (GLTF2.Loader = {}));\n    })(GLTF2 = BABYLON.GLTF2 || (BABYLON.GLTF2 = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=MSFT_audio_emitter.js.map\n","/// <reference path=\"../../../../../dist/preview release/babylon.d.ts\"/>\nvar BABYLON;\n(function (BABYLON) {\n    var GLTF2;\n    (function (GLTF2) {\n        var Loader;\n        (function (Loader) {\n            var Extensions;\n            (function (Extensions) {\n                var NAME = \"MSFT_lod\";\n                /**\n                 * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_lod)\n                 */\n                var MSFT_lod = /** @class */ (function () {\n                    /** @hidden */\n                    function MSFT_lod(loader) {\n                        /** The name of this extension. */\n                        this.name = NAME;\n                        /** Defines whether this extension is enabled. */\n                        this.enabled = true;\n                        /**\n                         * Maximum number of LODs to load, starting from the lowest LOD.\n                         */\n                        this.maxLODsToLoad = Number.MAX_VALUE;\n                        /**\n                         * Observable raised when all node LODs of one level are loaded.\n                         * The event data is the index of the loaded LOD starting from zero.\n                         * Dispose the loader to cancel the loading of the next level of LODs.\n                         */\n                        this.onNodeLODsLoadedObservable = new BABYLON.Observable();\n                        /**\n                         * Observable raised when all material LODs of one level are loaded.\n                         * The event data is the index of the loaded LOD starting from zero.\n                         * Dispose the loader to cancel the loading of the next level of LODs.\n                         */\n                        this.onMaterialLODsLoadedObservable = new BABYLON.Observable();\n                        this._nodeIndexLOD = null;\n                        this._nodeSignalLODs = new Array();\n                        this._nodePromiseLODs = new Array();\n                        this._materialIndexLOD = null;\n                        this._materialSignalLODs = new Array();\n                        this._materialPromiseLODs = new Array();\n                        this._loader = loader;\n                    }\n                    /** @hidden */\n                    MSFT_lod.prototype.dispose = function () {\n                        delete this._loader;\n                        this._nodeIndexLOD = null;\n                        this._nodeSignalLODs.length = 0;\n                        this._nodePromiseLODs.length = 0;\n                        this._materialIndexLOD = null;\n                        this._materialSignalLODs.length = 0;\n                        this._materialPromiseLODs.length = 0;\n                        this.onMaterialLODsLoadedObservable.clear();\n                        this.onNodeLODsLoadedObservable.clear();\n                    };\n                    /** @hidden */\n                    MSFT_lod.prototype.onReady = function () {\n                        var _this = this;\n                        var _loop_1 = function (indexLOD) {\n                            var promise = Promise.all(this_1._nodePromiseLODs[indexLOD]).then(function () {\n                                if (indexLOD !== 0) {\n                                    _this._loader.endPerformanceCounter(\"Node LOD \" + indexLOD);\n                                }\n                                _this._loader.log(\"Loaded node LOD \" + indexLOD);\n                                _this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\n                                if (indexLOD !== _this._nodePromiseLODs.length - 1) {\n                                    _this._loader.startPerformanceCounter(\"Node LOD \" + (indexLOD + 1));\n                                    if (_this._nodeSignalLODs[indexLOD]) {\n                                        _this._nodeSignalLODs[indexLOD].resolve();\n                                    }\n                                }\n                            });\n                            this_1._loader._completePromises.push(promise);\n                        };\n                        var this_1 = this;\n                        for (var indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\n                            _loop_1(indexLOD);\n                        }\n                        var _loop_2 = function (indexLOD) {\n                            var promise = Promise.all(this_2._materialPromiseLODs[indexLOD]).then(function () {\n                                if (indexLOD !== 0) {\n                                    _this._loader.endPerformanceCounter(\"Material LOD \" + indexLOD);\n                                }\n                                _this._loader.log(\"Loaded material LOD \" + indexLOD);\n                                _this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\n                                if (indexLOD !== _this._materialPromiseLODs.length - 1) {\n                                    _this._loader.startPerformanceCounter(\"Material LOD \" + (indexLOD + 1));\n                                    if (_this._materialSignalLODs[indexLOD]) {\n                                        _this._materialSignalLODs[indexLOD].resolve();\n                                    }\n                                }\n                            });\n                            this_2._loader._completePromises.push(promise);\n                        };\n                        var this_2 = this;\n                        for (var indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\n                            _loop_2(indexLOD);\n                        }\n                    };\n                    /** @hidden */\n                    MSFT_lod.prototype.loadNodeAsync = function (context, node, assign) {\n                        var _this = this;\n                        return GLTF2.GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) {\n                            var firstPromise;\n                            var nodeLODs = _this._getLODs(extensionContext, node, _this._loader.gltf.nodes, extension.ids);\n                            _this._loader.logOpen(\"\" + extensionContext);\n                            var _loop_3 = function (indexLOD) {\n                                var nodeLOD = nodeLODs[indexLOD];\n                                if (indexLOD !== 0) {\n                                    _this._nodeIndexLOD = indexLOD;\n                                    _this._nodeSignalLODs[indexLOD] = _this._nodeSignalLODs[indexLOD] || new BABYLON.Deferred();\n                                }\n                                var promise = _this._loader.loadNodeAsync(\"#/nodes/\" + nodeLOD.index, nodeLOD).then(function (babylonMesh) {\n                                    if (indexLOD !== 0) {\n                                        // TODO: should not rely on _babylonMesh\n                                        var previousNodeLOD = nodeLODs[indexLOD - 1];\n                                        if (previousNodeLOD._babylonMesh) {\n                                            previousNodeLOD._babylonMesh.dispose();\n                                            delete previousNodeLOD._babylonMesh;\n                                            _this._disposeUnusedMaterials();\n                                        }\n                                    }\n                                    return babylonMesh;\n                                });\n                                if (indexLOD === 0) {\n                                    firstPromise = promise;\n                                }\n                                else {\n                                    _this._nodeIndexLOD = null;\n                                }\n                                _this._nodePromiseLODs[indexLOD] = _this._nodePromiseLODs[indexLOD] || [];\n                                _this._nodePromiseLODs[indexLOD].push(promise);\n                            };\n                            for (var indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\n                                _loop_3(indexLOD);\n                            }\n                            _this._loader.logClose();\n                            return firstPromise;\n                        });\n                    };\n                    /** @hidden */\n                    MSFT_lod.prototype._loadMaterialAsync = function (context, material, babylonMesh, babylonDrawMode, assign) {\n                        var _this = this;\n                        // Don't load material LODs if already loading a node LOD.\n                        if (this._nodeIndexLOD) {\n                            return null;\n                        }\n                        return GLTF2.GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) {\n                            var firstPromise;\n                            var materialLODs = _this._getLODs(extensionContext, material, _this._loader.gltf.materials, extension.ids);\n                            _this._loader.logOpen(\"\" + extensionContext);\n                            var _loop_4 = function (indexLOD) {\n                                var materialLOD = materialLODs[indexLOD];\n                                if (indexLOD !== 0) {\n                                    _this._materialIndexLOD = indexLOD;\n                                }\n                                var promise = _this._loader._loadMaterialAsync(\"#/materials/\" + materialLOD.index, materialLOD, babylonMesh, babylonDrawMode, function (babylonMaterial) {\n                                    if (indexLOD === 0) {\n                                        assign(babylonMaterial);\n                                    }\n                                }).then(function (babylonMaterial) {\n                                    if (indexLOD !== 0) {\n                                        assign(babylonMaterial);\n                                        // TODO: should not rely on _babylonData\n                                        var previousBabylonDataLOD = materialLODs[indexLOD - 1]._babylonData;\n                                        if (previousBabylonDataLOD[babylonDrawMode]) {\n                                            previousBabylonDataLOD[babylonDrawMode].material.dispose();\n                                            delete previousBabylonDataLOD[babylonDrawMode];\n                                        }\n                                    }\n                                    return babylonMaterial;\n                                });\n                                if (indexLOD === 0) {\n                                    firstPromise = promise;\n                                }\n                                else {\n                                    _this._materialIndexLOD = null;\n                                }\n                                _this._materialPromiseLODs[indexLOD] = _this._materialPromiseLODs[indexLOD] || [];\n                                _this._materialPromiseLODs[indexLOD].push(promise);\n                            };\n                            for (var indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\n                                _loop_4(indexLOD);\n                            }\n                            _this._loader.logClose();\n                            return firstPromise;\n                        });\n                    };\n                    /** @hidden */\n                    MSFT_lod.prototype._loadUriAsync = function (context, uri) {\n                        var _this = this;\n                        // Defer the loading of uris if loading a material or node LOD.\n                        if (this._materialIndexLOD !== null) {\n                            this._loader.log(\"deferred\");\n                            var previousIndexLOD = this._materialIndexLOD - 1;\n                            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new BABYLON.Deferred();\n                            return this._materialSignalLODs[previousIndexLOD].promise.then(function () {\n                                return _this._loader.loadUriAsync(context, uri);\n                            });\n                        }\n                        else if (this._nodeIndexLOD !== null) {\n                            this._loader.log(\"deferred\");\n                            var previousIndexLOD = this._nodeIndexLOD - 1;\n                            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new BABYLON.Deferred();\n                            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(function () {\n                                return _this._loader.loadUriAsync(context, uri);\n                            });\n                        }\n                        return null;\n                    };\n                    /**\n                     * Gets an array of LOD properties from lowest to highest.\n                     */\n                    MSFT_lod.prototype._getLODs = function (context, property, array, ids) {\n                        if (this.maxLODsToLoad <= 0) {\n                            throw new Error(\"maxLODsToLoad must be greater than zero\");\n                        }\n                        var properties = new Array();\n                        for (var i = ids.length - 1; i >= 0; i--) {\n                            properties.push(GLTF2.ArrayItem.Get(context + \"/ids/\" + ids[i], array, ids[i]));\n                            if (properties.length === this.maxLODsToLoad) {\n                                return properties;\n                            }\n                        }\n                        properties.push(property);\n                        return properties;\n                    };\n                    MSFT_lod.prototype._disposeUnusedMaterials = function () {\n                        // TODO: should not rely on _babylonData\n                        var materials = this._loader.gltf.materials;\n                        if (materials) {\n                            for (var _i = 0, materials_1 = materials; _i < materials_1.length; _i++) {\n                                var material = materials_1[_i];\n                                if (material._babylonData) {\n                                    for (var drawMode in material._babylonData) {\n                                        var babylonData = material._babylonData[drawMode];\n                                        if (babylonData.meshes.length === 0) {\n                                            babylonData.material.dispose(false, true);\n                                            delete material._babylonData[drawMode];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    };\n                    return MSFT_lod;\n                }());\n                Extensions.MSFT_lod = MSFT_lod;\n                GLTF2.GLTFLoader.RegisterExtension(NAME, function (loader) { return new MSFT_lod(loader); });\n            })(Extensions = Loader.Extensions || (Loader.Extensions = {}));\n        })(Loader = GLTF2.Loader || (GLTF2.Loader = {}));\n    })(GLTF2 = BABYLON.GLTF2 || (BABYLON.GLTF2 = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=MSFT_lod.js.map\n","/// <reference path=\"../../../../../dist/preview release/babylon.d.ts\"/>\nvar BABYLON;\n(function (BABYLON) {\n    var GLTF2;\n    (function (GLTF2) {\n        var Loader;\n        (function (Loader) {\n            var Extensions;\n            (function (Extensions) {\n                var NAME = \"MSFT_minecraftMesh\";\n                /** @hidden */\n                var MSFT_minecraftMesh = /** @class */ (function () {\n                    function MSFT_minecraftMesh(loader) {\n                        this.name = NAME;\n                        this.enabled = true;\n                        this._loader = loader;\n                    }\n                    MSFT_minecraftMesh.prototype.dispose = function () {\n                        delete this._loader;\n                    };\n                    MSFT_minecraftMesh.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n                        var _this = this;\n                        return GLTF2.GLTFLoader.LoadExtraAsync(context, material, this.name, function (extraContext, extra) {\n                            if (extra) {\n                                if (!(babylonMaterial instanceof BABYLON.PBRMaterial)) {\n                                    throw new Error(extraContext + \": Material type not supported\");\n                                }\n                                var promise = _this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\n                                if (babylonMaterial.needAlphaBlending()) {\n                                    babylonMaterial.forceDepthWrite = true;\n                                    babylonMaterial.separateCullingPass = true;\n                                }\n                                babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;\n                                babylonMaterial.twoSidedLighting = true;\n                                return promise;\n                            }\n                            return null;\n                        });\n                    };\n                    return MSFT_minecraftMesh;\n                }());\n                Extensions.MSFT_minecraftMesh = MSFT_minecraftMesh;\n                GLTF2.GLTFLoader.RegisterExtension(NAME, function (loader) { return new MSFT_minecraftMesh(loader); });\n            })(Extensions = Loader.Extensions || (Loader.Extensions = {}));\n        })(Loader = GLTF2.Loader || (GLTF2.Loader = {}));\n    })(GLTF2 = BABYLON.GLTF2 || (BABYLON.GLTF2 = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=MSFT_minecraftMesh.js.map\n","/// <reference path=\"../../../../../dist/preview release/babylon.d.ts\"/>\nvar BABYLON;\n(function (BABYLON) {\n    var GLTF2;\n    (function (GLTF2) {\n        var Loader;\n        (function (Loader) {\n            var Extensions;\n            (function (Extensions) {\n                var NAME = \"MSFT_sRGBFactors\";\n                /** @hidden */\n                var MSFT_sRGBFactors = /** @class */ (function () {\n                    function MSFT_sRGBFactors(loader) {\n                        this.name = NAME;\n                        this.enabled = true;\n                        this._loader = loader;\n                    }\n                    MSFT_sRGBFactors.prototype.dispose = function () {\n                        delete this._loader;\n                    };\n                    MSFT_sRGBFactors.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n                        var _this = this;\n                        return GLTF2.GLTFLoader.LoadExtraAsync(context, material, this.name, function (extraContext, extra) {\n                            if (extra) {\n                                if (!(babylonMaterial instanceof BABYLON.PBRMaterial)) {\n                                    throw new Error(extraContext + \": Material type not supported\");\n                                }\n                                var promise = _this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\n                                if (!babylonMaterial.albedoTexture) {\n                                    babylonMaterial.albedoColor.toLinearSpaceToRef(babylonMaterial.albedoColor);\n                                }\n                                if (!babylonMaterial.reflectivityTexture) {\n                                    babylonMaterial.reflectivityColor.toLinearSpaceToRef(babylonMaterial.reflectivityColor);\n                                }\n                                return promise;\n                            }\n                            return null;\n                        });\n                    };\n                    return MSFT_sRGBFactors;\n                }());\n                Extensions.MSFT_sRGBFactors = MSFT_sRGBFactors;\n                GLTF2.GLTFLoader.RegisterExtension(NAME, function (loader) { return new MSFT_sRGBFactors(loader); });\n            })(Extensions = Loader.Extensions || (Loader.Extensions = {}));\n        })(Loader = GLTF2.Loader || (GLTF2.Loader = {}));\n    })(GLTF2 = BABYLON.GLTF2 || (BABYLON.GLTF2 = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=MSFT_sRGBFactors.js.map\n","export * from \"./objFileLoader\";","import { Geometry, Mesh, SceneLoader, Vector3, Vector2, Tools, Color3, StandardMaterial, Nullable, Scene, Texture, ISceneLoaderPluginAsync, SceneLoaderProgressEvent, AbstractMesh, IParticleSystem, Skeleton, AnimationGroup, AssetContainer, VertexData } from \"babylonjs\";\n\n/**\n * Class reading and parsing the MTL file bundled with the obj file.\n */\nexport class MTLFileLoader {\n\n    // All material loaded from the mtl will be set here\n    public materials: StandardMaterial[] = [];\n\n    /**\n     * This function will read the mtl file and create each material described inside\n     * This function could be improve by adding :\n     * -some component missing (Ni, Tf...)\n     * -including the specific options available\n     *\n     * @param scene\n     * @param data\n     * @param rootUrl\n     */\n    public parseMTL(scene: Scene, data: string | ArrayBuffer, rootUrl: string) {\n        if (data instanceof ArrayBuffer) {\n            return;\n        }\n\n        //Split the lines from the file\n        var lines = data.split('\\n');\n        //Space char\n        var delimiter_pattern = /\\s+/;\n        //Array with RGB colors\n        var color: number[];\n        //New material\n        var material: Nullable<StandardMaterial> = null;\n\n        //Look at each line\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i].trim();\n\n            // Blank line or comment\n            if (line.length === 0 || line.charAt(0) === '#') {\n                continue;\n            }\n\n            //Get the first parameter (keyword)\n            var pos = line.indexOf(' ');\n            var key = (pos >= 0) ? line.substring(0, pos) : line;\n            key = key.toLowerCase();\n\n            //Get the data following the key\n            var value: string = (pos >= 0) ? line.substring(pos + 1).trim() : \"\";\n\n            //This mtl keyword will create the new material\n            if (key === \"newmtl\") {\n                //Check if it is the first material.\n                // Materials specifications are described after this keyword.\n                if (material) {\n                    //Add the previous material in the material array.\n                    this.materials.push(material);\n                }\n                //Create a new material.\n                // value is the name of the material read in the mtl file\n                material = new StandardMaterial(value, scene);\n            } else if (key === \"kd\" && material) {\n                // Diffuse color (color under white light) using RGB values\n\n                //value  = \"r g b\"\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.diffuseColor = Color3.FromArray(color);\n            } else if (key === \"ka\" && material) {\n                // Ambient color (color under shadow) using RGB values\n\n                //value = \"r g b\"\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.ambientColor = Color3.FromArray(color);\n            } else if (key === \"ks\" && material) {\n                // Specular color (color when light is reflected from shiny surface) using RGB values\n\n                //value = \"r g b\"\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set the color into the material\n                material.specularColor = Color3.FromArray(color);\n            } else if (key === \"ke\" && material) {\n                // Emissive color using RGB values\n                color = value.split(delimiter_pattern, 3).map(parseFloat);\n                material.emissiveColor = Color3.FromArray(color);\n            } else if (key === \"ns\" && material) {\n\n                //value = \"Integer\"\n                material.specularPower = parseFloat(value);\n            } else if (key === \"d\" && material) {\n                //d is dissolve for current material. It mean alpha for BABYLON\n                material.alpha = parseFloat(value);\n\n                //Texture\n                //This part can be improved by adding the possible options of texture\n            } else if (key === \"map_ka\" && material) {\n                // ambient texture map with a loaded image\n                //We must first get the folder of the image\n                material.ambientTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n            } else if (key === \"map_kd\" && material) {\n                // Diffuse texture map with a loaded image\n                material.diffuseTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n            } else if (key === \"map_ks\" && material) {\n                // Specular texture map with a loaded image\n                //We must first get the folder of the image\n                material.specularTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n            } else if (key === \"map_ns\") {\n                //Specular\n                //Specular highlight component\n                //We must first get the folder of the image\n                //\n                //Not supported by BABYLON\n                //\n                //    continue;\n            } else if (key === \"map_bump\" && material) {\n                //The bump texture\n                material.bumpTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n            } else if (key === \"map_d\" && material) {\n                // The dissolve of the material\n                material.opacityTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n\n                //Options for illumination\n            } else if (key === \"illum\") {\n                //Illumination\n                if (value === \"0\") {\n                    //That mean Kd == Kd\n                } else if (value === \"1\") {\n                    //Color on and Ambient on\n                } else if (value === \"2\") {\n                    //Highlight on\n                } else if (value === \"3\") {\n                    //Reflection on and Ray trace on\n                } else if (value === \"4\") {\n                    //Transparency: Glass on, Reflection: Ray trace on\n                } else if (value === \"5\") {\n                    //Reflection: Fresnel on and Ray trace on\n                } else if (value === \"6\") {\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\n                } else if (value === \"7\") {\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\n                } else if (value === \"8\") {\n                    //Reflection on and Ray trace off\n                } else if (value === \"9\") {\n                    //Transparency: Glass on, Reflection: Ray trace off\n                } else if (value === \"10\") {\n                    //Casts shadows onto invisible surfaces\n                }\n            } else {\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\n            }\n        }\n        //At the end of the file, add the last material\n        if (material) {\n            this.materials.push(material);\n        }\n    }\n\n    /**\n     * Gets the texture for the material.\n     *\n     * If the material is imported from input file,\n     * We sanitize the url to ensure it takes the textre from aside the material.\n     *\n     * @param rootUrl The root url to load from\n     * @param value The value stored in the mtl\n     * @return The Texture\n     */\n    private static _getTexture(rootUrl: string, value: string, scene: Scene): Nullable<Texture> {\n        if (!value) {\n            return null;\n        }\n\n        var url = rootUrl;\n        // Load from input file.\n        if (rootUrl === \"file:\") {\n            var lastDelimiter = value.lastIndexOf(\"\\\\\");\n            if (lastDelimiter === -1) {\n                lastDelimiter = value.lastIndexOf(\"/\");\n            }\n\n            if (lastDelimiter > -1) {\n                url += value.substr(lastDelimiter + 1);\n            }\n            else {\n                url += value;\n            }\n        }\n        // Not from input file.\n        else {\n            url += value;\n        }\n\n        return new Texture(url, scene);\n    }\n}\n\nexport class OBJFileLoader implements ISceneLoaderPluginAsync {\n\n    public static OPTIMIZE_WITH_UV = false;\n    public static INVERT_Y = false;\n    public name = \"obj\";\n    public extensions = \".obj\";\n    public obj = /^o/;\n    public group = /^g/;\n    public mtllib = /^mtllib /;\n    public usemtl = /^usemtl /;\n    public smooth = /^s /;\n    public vertexPattern = /v( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n    // vn float float float\n    public normalPattern = /vn( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n    // vt float float\n    public uvPattern = /vt( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n    // f vertex vertex vertex ...\n    public facePattern1 = /f\\s+(([\\d]{1,}[\\s]?){3,})+/;\n    // f vertex/uvs vertex/uvs vertex/uvs ...\n    public facePattern2 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n    // f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal ...\n    public facePattern3 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n    // f vertex//normal vertex//normal vertex//normal ...\n    public facePattern4 = /f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\n    // f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal ...\n    public facePattern5 = /f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\n\n    /**\n     * Calls synchronously the MTL file attached to this obj.\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\n     * Without this function materials are not displayed in the first frame (but displayed after).\n     * In consequence it is impossible to get material information in your HTML file\n     *\n     * @param url The URL of the MTL file\n     * @param rootUrl\n     * @param onSuccess Callback function to be called when the MTL file is loaded\n     * @private\n     */\n    private _loadMTL(url: string, rootUrl: string, onSuccess: (response: string | ArrayBuffer, responseUrl?: string) => any) {\n        //The complete path to the mtl file\n        var pathOfFile = Tools.BaseUrl + rootUrl + url;\n\n        // Loads through the babylon tools to allow fileInput search.\n        Tools.LoadFile(pathOfFile,\n            onSuccess,\n            undefined,\n            undefined,\n            false,\n            () => { console.warn(\"Error - Unable to load \" + pathOfFile); });\n    }\n\n    /**\n     * Imports one or more meshes from the loaded glTF data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the glTF data to load\n     * @param rootUrl root url to load from\n     * @param onProgress event that fires when loading progress has occured\n     * @param fileName Defines the name of the file to load\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\n     */\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }> {\n        //get the meshes from OBJ file\n        return this._parseSolid(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: []\n            };\n        });\n    }\n\n    /**\n     * Imports all objects from the loaded glTF data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the glTF data to load\n     * @param rootUrl root url to load from\n     * @param onProgress event that fires when loading progress has occured\n     * @param fileName Defines the name of the file to load\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    public loadAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\n        //Get the 3D model\n        return this.importMeshAsync(null, scene, data, rootUrl, onProgress).then(() => {\n            // return void\n        });\n    }\n\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @param onProgress The callback when the load progresses\n     * @param fileName Defines the name of the file to load\n     * @returns The loaded asset container\n     */\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer> {\n        return this.importMeshAsync(null, scene, data, rootUrl).then((result) => {\n            var container = new AssetContainer(scene);\n            result.meshes.forEach((mesh) => container.meshes.push(mesh));\n            container.removeAllFromScene();\n            return container;\n        });\n    }\n\n    /**\n     * Read the OBJ file and create an Array of meshes.\n     * Each mesh contains all information given by the OBJ and the MTL file.\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\n     *\n     * @param meshesNames\n     * @param scene Scene The scene where are displayed the data\n     * @param data String The content of the obj file\n     * @param rootUrl String The path to the folder\n     * @returns Array<AbstractMesh>\n     * @private\n     */\n    private _parseSolid(meshesNames: any, scene: Scene, data: string, rootUrl: string): Promise<Array<AbstractMesh>> {\n\n        var positions: Array<Vector3> = [];      //values for the positions of vertices\n        var normals: Array<Vector3> = [];      //Values for the normals\n        var uvs: Array<Vector2> = [];      //Values for the textures\n        var meshesFromObj: Array<any> = [];      //[mesh] Contains all the obj meshes\n        var handledMesh: any;      //The current mesh of meshes array\n        var indicesForBabylon: Array<number> = [];      //The list of indices for VertexData\n        var wrappedPositionForBabylon: Array<Vector3> = [];      //The list of position in vectors\n        var wrappedUvsForBabylon: Array<Vector2> = [];      //Array with all value of uvs to match with the indices\n        var wrappedNormalsForBabylon: Array<Vector3> = [];      //Array with all value of normals to match with the indices\n        var tuplePosNorm: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }> = [];      //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\n        var curPositionInIndices = 0;\n        var hasMeshes: Boolean = false;   //Meshes are defined in the file\n        var unwrappedPositionsForBabylon: Array<number> = [];      //Value of positionForBabylon w/o Vector3() [x,y,z]\n        var unwrappedNormalsForBabylon: Array<number> = [];      //Value of normalsForBabylon w/o Vector3()  [x,y,z]\n        var unwrappedUVForBabylon: Array<number> = [];      //Value of uvsForBabylon w/o Vector3()      [x,y,z]\n        var triangles: Array<string> = [];      //Indices from new triangles coming from polygons\n        var materialNameFromObj: string = \"\";      //The name of the current material\n        var fileToLoad: string = \"\";      //The name of the mtlFile to load\n        var materialsFromMTLFile: MTLFileLoader = new MTLFileLoader();\n        var objMeshName: string = \"\";      //The name of the current obj mesh\n        var increment: number = 1;      //Id for meshes created by the multimaterial\n        var isFirstMaterial: boolean = true;\n\n        /**\n         * Search for obj in the given array.\n         * This function is called to check if a couple of data already exists in an array.\n         *\n         * If found, returns the index of the founded tuple index. Returns -1 if not found\n         * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\n         * @param obj Array<number>\n         * @returns {boolean}\n         */\n        var isInArray = (arr: Array<{ normals: Array<number>; idx: Array<number> }>, obj: Array<number>) => {\n            if (!arr[obj[0]]) { arr[obj[0]] = { normals: [], idx: [] }; }\n            var idx = arr[obj[0]].normals.indexOf(obj[1]);\n\n            return idx === -1 ? -1 : arr[obj[0]].idx[idx];\n        };\n        var isInArrayUV = (arr: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }>, obj: Array<number>) => {\n            if (!arr[obj[0]]) { arr[obj[0]] = { normals: [], idx: [], uv: [] }; }\n            var idx = arr[obj[0]].normals.indexOf(obj[1]);\n\n            if (idx != 1 && (obj[2] == arr[obj[0]].uv[idx])) {\n                return arr[obj[0]].idx[idx];\n            }\n            return -1;\n        };\n\n        /**\n         * This function set the data for each triangle.\n         * Data are position, normals and uvs\n         * If a tuple of (position, normal) is not set, add the data into the corresponding array\n         * If the tuple already exist, add only their indice\n         *\n         * @param indicePositionFromObj Integer The index in positions array\n         * @param indiceUvsFromObj Integer The index in uvs array\n         * @param indiceNormalFromObj Integer The index in normals array\n         * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\n         * @param textureVectorFromOBJ Vector3 The value of uvs\n         * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\n         */\n        var setData = (indicePositionFromObj: number, indiceUvsFromObj: number, indiceNormalFromObj: number, positionVectorFromOBJ: Vector3, textureVectorFromOBJ: Vector2, normalsVectorFromOBJ: Vector3) => {\n            //Check if this tuple already exists in the list of tuples\n            var _index: number;\n            if (OBJFileLoader.OPTIMIZE_WITH_UV) {\n                _index = isInArrayUV(\n                    tuplePosNorm,\n                    [\n                        indicePositionFromObj,\n                        indiceNormalFromObj,\n                        indiceUvsFromObj\n                    ]\n                );\n            }\n            else {\n                _index = isInArray(\n                    tuplePosNorm,\n                    [\n                        indicePositionFromObj,\n                        indiceNormalFromObj\n                    ]\n                );\n            }\n\n            //If it not exists\n            if (_index == -1) {\n                //Add an new indice.\n                //The array of indices is only an array with his length equal to the number of triangles - 1.\n                //We add vertices data in this order\n                indicesForBabylon.push(wrappedPositionForBabylon.length);\n                //Push the position of vertice for Babylon\n                //Each element is a Vector3(x,y,z)\n                wrappedPositionForBabylon.push(positionVectorFromOBJ);\n                //Push the uvs for Babylon\n                //Each element is a Vector3(u,v)\n                wrappedUvsForBabylon.push(textureVectorFromOBJ);\n                //Push the normals for Babylon\n                //Each element is a Vector3(x,y,z)\n                wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\n                //Add the tuple in the comparison list\n                tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\n                tuplePosNorm[indicePositionFromObj].idx.push(curPositionInIndices++);\n                if (OBJFileLoader.OPTIMIZE_WITH_UV) { tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj); }\n            } else {\n                //The tuple already exists\n                //Add the index of the already existing tuple\n                //At this index we can get the value of position, normal and uvs of vertex\n                indicesForBabylon.push(_index);\n            }\n        };\n\n        /**\n         * Transform Vector() object onto 3 digits in an array\n         */\n        var unwrapData = () => {\n            //Every array has the same length\n            for (var l = 0; l < wrappedPositionForBabylon.length; l++) {\n                //Push the x, y, z values of each element in the unwrapped array\n                unwrappedPositionsForBabylon.push(wrappedPositionForBabylon[l].x, wrappedPositionForBabylon[l].y, wrappedPositionForBabylon[l].z);\n                unwrappedNormalsForBabylon.push(wrappedNormalsForBabylon[l].x, wrappedNormalsForBabylon[l].y, wrappedNormalsForBabylon[l].z);\n                unwrappedUVForBabylon.push(wrappedUvsForBabylon[l].x, wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\n            }\n            // Reset arrays for the next new meshes\n            wrappedPositionForBabylon = [];\n            wrappedNormalsForBabylon = [];\n            wrappedUvsForBabylon = [];\n            tuplePosNorm = [];\n            curPositionInIndices = 0;\n        };\n\n        /**\n         * Create triangles from polygons by recursion\n         * The best to understand how it works is to draw it in the same time you get the recursion.\n         * It is important to notice that a triangle is a polygon\n         * We get 5 patterns of face defined in OBJ File :\n         * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\n         * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\n         * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\n         * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\n         * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\n         * Each pattern is divided by the same method\n         * @param face Array[String] The indices of elements\n         * @param v Integer The variable to increment\n         */\n        var getTriangles = (face: Array<string>, v: number) => {\n            //Work for each element of the array\n            if (v + 1 < face.length) {\n                //Add on the triangle variable the indexes to obtain triangles\n                triangles.push(face[0], face[v], face[v + 1]);\n                //Incrementation for recursion\n                v += 1;\n                //Recursion\n                getTriangles(face, v);\n            }\n\n            //Result obtained after 2 iterations:\n            //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\n            //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\n            //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\n            //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\n            //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 1\n         * In this pattern we get vertice positions\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern1 = (face: Array<string>, v: number) => {\n            //Get the indices of triangles for each polygon\n            getTriangles(face, v);\n            //For each element in the triangles array.\n            //This var could contains 1 to an infinity of triangles\n            for (var k = 0; k < triangles.length; k++) {\n                // Set position indice\n                var indicePositionFromObj = parseInt(triangles[k]) - 1;\n\n                setData(\n                    indicePositionFromObj,\n                    0, 0,                                           //In the pattern 1, normals and uvs are not defined\n                    positions[indicePositionFromObj],               //Get the vectors data\n                    Vector2.Zero(), Vector3.Up()    //Create default vectors\n                );\n            }\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 2\n         * In this pattern we get vertice positions and uvsu\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern2 = (face: Array<string>, v: number) => {\n            //Get the indices of triangles for each polygon\n            getTriangles(face, v);\n            for (var k = 0; k < triangles.length; k++) {\n                //triangle[k] = \"1/1\"\n                //Split the data for getting position and uv\n                var point = triangles[k].split(\"/\"); // [\"1\", \"1\"]\n                //Set position indice\n                var indicePositionFromObj = parseInt(point[0]) - 1;\n                //Set uv indice\n                var indiceUvsFromObj = parseInt(point[1]) - 1;\n\n                setData(\n                    indicePositionFromObj,\n                    indiceUvsFromObj,\n                    0,                                  //Default value for normals\n                    positions[indicePositionFromObj],   //Get the values for each element\n                    uvs[indiceUvsFromObj],\n                    Vector3.Up()                //Default value for normals\n                );\n            }\n\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 3\n         * In this pattern we get vertice positions, uvs and normals\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern3 = (face: Array<string>, v: number) => {\n            //Get the indices of triangles for each polygon\n            getTriangles(face, v);\n\n            for (var k = 0; k < triangles.length; k++) {\n                //triangle[k] = \"1/1/1\"\n                //Split the data for getting position, uv, and normals\n                var point = triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\n                // Set position indice\n                var indicePositionFromObj = parseInt(point[0]) - 1;\n                // Set uv indice\n                var indiceUvsFromObj = parseInt(point[1]) - 1;\n                // Set normal indice\n                var indiceNormalFromObj = parseInt(point[2]) - 1;\n\n                setData(\n                    indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj,\n                    positions[indicePositionFromObj], uvs[indiceUvsFromObj], normals[indiceNormalFromObj] //Set the vector for each component\n                );\n\n            }\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 4\n         * In this pattern we get vertice positions and normals\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern4 = (face: Array<string>, v: number) => {\n            getTriangles(face, v);\n\n            for (var k = 0; k < triangles.length; k++) {\n                //triangle[k] = \"1//1\"\n                //Split the data for getting position and normals\n                var point = triangles[k].split(\"//\"); // [\"1\", \"1\"]\n                // We check indices, and normals\n                var indicePositionFromObj = parseInt(point[0]) - 1;\n                var indiceNormalFromObj = parseInt(point[1]) - 1;\n\n                setData(\n                    indicePositionFromObj,\n                    1, //Default value for uv\n                    indiceNormalFromObj,\n                    positions[indicePositionFromObj], //Get each vector of data\n                    Vector2.Zero(),\n                    normals[indiceNormalFromObj]\n                );\n            }\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 3\n         * In this pattern we get vertice positions, uvs and normals\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern5 = (face: Array<string>, v: number) => {\n            //Get the indices of triangles for each polygon\n            getTriangles(face, v);\n\n            for (var k = 0; k < triangles.length; k++) {\n                //triangle[k] = \"-1/-1/-1\"\n                //Split the data for getting position, uv, and normals\n                var point = triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\n                // Set position indice\n                var indicePositionFromObj =  positions.length + parseInt(point[0]);\n                // Set uv indice\n                var indiceUvsFromObj =  uvs.length + parseInt(point[1]);\n                // Set normal indice\n                var indiceNormalFromObj = normals.length + parseInt(point[2]);\n\n                setData(\n                    indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj,\n                    positions[indicePositionFromObj], uvs[indiceUvsFromObj], normals[indiceNormalFromObj] //Set the vector for each component\n                );\n\n            }\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        var addPreviousObjMesh = () => {\n\n            //Check if it is not the first mesh. Otherwise we don't have data.\n            if (meshesFromObj.length > 0) {\n                //Get the previous mesh for applying the data about the faces\n                //=> in obj file, faces definition append after the name of the mesh\n                handledMesh = meshesFromObj[meshesFromObj.length - 1];\n\n                //Set the data into Array for the mesh\n                unwrapData();\n\n                // Reverse tab. Otherwise face are displayed in the wrong sens\n                indicesForBabylon.reverse();\n                //Set the information for the mesh\n                //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\n                handledMesh.indices = indicesForBabylon.slice();\n                handledMesh.positions = unwrappedPositionsForBabylon.slice();\n                handledMesh.normals = unwrappedNormalsForBabylon.slice();\n                handledMesh.uvs = unwrappedUVForBabylon.slice();\n\n                //Reset the array for the next mesh\n                indicesForBabylon = [];\n                unwrappedPositionsForBabylon = [];\n                unwrappedNormalsForBabylon = [];\n                unwrappedUVForBabylon = [];\n            }\n        };\n        //Main function\n\n        //Split the file into lines\n        var lines = data.split('\\n');\n        //Look at each line\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i].trim();\n            var result;\n\n            //Comment or newLine\n            if (line.length === 0 || line.charAt(0) === '#') {\n                continue;\n\n                //Get information about one position possible for the vertices\n            } else if ((result = this.vertexPattern.exec(line)) !== null) {\n                //Create a Vector3 with the position x, y, z\n                //Value of result:\n                // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n                //Add the Vector in the list of positions\n                positions.push(new Vector3(\n                    parseFloat(result[1]),\n                    parseFloat(result[2]),\n                    parseFloat(result[3])\n                ));\n\n            } else if ((result = this.normalPattern.exec(line)) !== null) {\n                //Create a Vector3 with the normals x, y, z\n                //Value of result\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n                //Add the Vector in the list of normals\n                normals.push(new Vector3(\n                    parseFloat(result[1]),\n                    parseFloat(result[2]),\n                    parseFloat(result[3])\n                ));\n\n            } else if ((result = this.uvPattern.exec(line)) !== null) {\n                //Create a Vector2 with the normals u, v\n                //Value of result\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\n                //Add the Vector in the list of uvs\n                uvs.push(new Vector2(\n                    parseFloat(result[1]),\n                    parseFloat(result[2])\n                ));\n\n                //Identify patterns of faces\n                //Face could be defined in different type of pattern\n            } else if ((result = this.facePattern3.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern3(\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\n                    1\n                );\n\n            } else if ((result = this.facePattern4.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern4(\n                    result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\n                    1\n                );\n\n            } else if ((result = this.facePattern5.exec(line)) !== null) {\n                //Value of result:\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern5(\n                    result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\n                    1\n                );\n\n            } else if ((result = this.facePattern2.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern2(\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\n                    1\n                );\n\n            } else if ((result = this.facePattern1.exec(line)) !== null) {\n                //Value of result\n                //[\"f 1 2 3\", \"1 2 3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern1(\n                    result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\n                    1\n                );\n\n                //Define a mesh or an object\n                //Each time this keyword is analysed, create a new Object with all data for creating a babylonMesh\n            } else if (this.group.test(line) || this.obj.test(line)) {\n                //Create a new mesh corresponding to the name of the group.\n                //Definition of the mesh\n                var objMesh: {\n                    name: string;\n                    indices?: Array<number>;\n                    positions?: Array<number>;\n                    normals?: Array<number>;\n                    uvs?: Array<number>;\n                    materialName: string;\n                } =\n                //Set the name of the current obj mesh\n                {\n                    name: line.substring(2).trim(),\n                    indices: undefined,\n                    positions: undefined,\n                    normals: undefined,\n                    uvs: undefined,\n                    materialName: \"\"\n                };\n                addPreviousObjMesh();\n\n                //Push the last mesh created with only the name\n                meshesFromObj.push(objMesh);\n\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\n                hasMeshes = true;\n                isFirstMaterial = true;\n                increment = 1;\n                //Keyword for applying a material\n            } else if (this.usemtl.test(line)) {\n                //Get the name of the material\n                materialNameFromObj = line.substring(7).trim();\n\n                //If this new material is in the same mesh\n\n                if (!isFirstMaterial) {\n                    //Set the data for the previous mesh\n                    addPreviousObjMesh();\n                    //Create a new mesh\n                    var objMesh: {\n                        name: string;\n                        indices?: Array<number>;\n                        positions?: Array<number>;\n                        normals?: Array<number>;\n                        uvs?: Array<number>;\n                        materialName: string;\n                    } =\n                    //Set the name of the current obj mesh\n                    {\n                        name: objMeshName + \"_mm\" + increment.toString(),\n                        indices: undefined,\n                        positions: undefined,\n                        normals: undefined,\n                        uvs: undefined,\n                        materialName: materialNameFromObj\n                    };\n                    increment++;\n                    //If meshes are already defined\n                    meshesFromObj.push(objMesh);\n                }\n                //Set the material name if the previous line define a mesh\n\n                if (hasMeshes && isFirstMaterial) {\n                    //Set the material name to the previous mesh (1 material per mesh)\n                    meshesFromObj[meshesFromObj.length - 1].materialName = materialNameFromObj;\n                    isFirstMaterial = false;\n                }\n                //Keyword for loading the mtl file\n            } else if (this.mtllib.test(line)) {\n                //Get the name of mtl file\n                fileToLoad = line.substring(7).trim();\n\n                //Apply smoothing\n            } else if (this.smooth.test(line)) {\n                // smooth shading => apply smoothing\n                //Toda  y I don't know it work with babylon and with obj.\n                //With the obj file  an integer is set\n            } else {\n                //If there is another possibility\n                console.log(\"Unhandled expression at line : \" + line);\n            }\n        }\n\n        //At the end of the file, add the last mesh into the meshesFromObj array\n        if (hasMeshes) {\n            //Set the data for the last mesh\n            handledMesh = meshesFromObj[meshesFromObj.length - 1];\n\n            //Reverse indices for displaying faces in the good sens\n            indicesForBabylon.reverse();\n            //Get the good array\n            unwrapData();\n            //Set array\n            handledMesh.indices = indicesForBabylon;\n            handledMesh.positions = unwrappedPositionsForBabylon;\n            handledMesh.normals = unwrappedNormalsForBabylon;\n            handledMesh.uvs = unwrappedUVForBabylon;\n        }\n\n        //If any o or g keyword found, create a mesj with a random id\n        if (!hasMeshes) {\n            // reverse tab of indices\n            indicesForBabylon.reverse();\n            //Get positions normals uvs\n            unwrapData();\n            //Set data for one mesh\n            meshesFromObj.push({\n                name: Geometry.RandomId(),\n                indices: indicesForBabylon,\n                positions: unwrappedPositionsForBabylon,\n                normals: unwrappedNormalsForBabylon,\n                uvs: unwrappedUVForBabylon,\n                materialName: materialNameFromObj\n            });\n        }\n\n        //Create a Mesh list\n        var babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\n        var materialToUse = new Array<string>();\n\n        //Set data for each mesh\n        for (var j = 0; j < meshesFromObj.length; j++) {\n\n            //check meshesNames (stlFileLoader)\n            if (meshesNames && meshesFromObj[j].name) {\n                if (meshesNames instanceof Array) {\n                    if (meshesNames.indexOf(meshesFromObj[j].name) == -1) {\n                        continue;\n                    }\n                }\n                else {\n                    if (meshesFromObj[j].name !== meshesNames) {\n                        continue;\n                    }\n                }\n            }\n\n            //Get the current mesh\n            //Set the data with VertexBuffer for each mesh\n            handledMesh = meshesFromObj[j];\n            //Create a Mesh with the name of the obj mesh\n            var babylonMesh = new Mesh(meshesFromObj[j].name, scene);\n            //Push the name of the material to an array\n            //This is indispensable for the importMesh function\n            materialToUse.push(meshesFromObj[j].materialName);\n\n            var vertexData: VertexData = new VertexData(); //The container for the values\n            //Set the data for the babylonMesh\n            vertexData.positions = handledMesh.positions;\n            vertexData.normals = handledMesh.normals;\n            vertexData.uvs = handledMesh.uvs;\n            vertexData.indices = handledMesh.indices;\n            //Set the data from the VertexBuffer to the current Mesh\n            vertexData.applyToMesh(babylonMesh);\n            if (OBJFileLoader.INVERT_Y) {\n                babylonMesh.scaling.y *= -1;\n            }\n\n            //Push the mesh into an array\n            babylonMeshesArray.push(babylonMesh);\n        }\n\n        let mtlPromises: Array<Promise<any>> = [];\n        //load the materials\n        //Check if we have a file to load\n        if (fileToLoad !== \"\") {\n            //Load the file synchronously\n            mtlPromises.push(new Promise((resolve, reject) => {\n                this._loadMTL(fileToLoad, rootUrl, function(dataLoaded) {\n                    try {\n                        //Create materials thanks MTLLoader function\n                        materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl);\n                        //Look at each material loaded in the mtl file\n                        for (var n = 0; n < materialsFromMTLFile.materials.length; n++) {\n                            //Three variables to get all meshes with the same material\n                            var startIndex = 0;\n                            var _indices = [];\n                            var _index;\n\n                            //The material from MTL file is used in the meshes loaded\n                            //Push the indice in an array\n                            //Check if the material is not used for another mesh\n                            while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\n                                _indices.push(_index);\n                                startIndex = _index + 1;\n                            }\n                            //If the material is not used dispose it\n                            if (_index == -1 && _indices.length == 0) {\n                                //If the material is not needed, remove it\n                                materialsFromMTLFile.materials[n].dispose();\n                            } else {\n                                for (var o = 0; o < _indices.length; o++) {\n                                    //Apply the material to the Mesh for each mesh with the material\n                                    babylonMeshesArray[_indices[o]].material = materialsFromMTLFile.materials[n];\n                                }\n                            }\n                        }\n                        resolve();\n                    } catch (e) {\n                        reject(e);\n                    }\n\n                });\n            }));\n\n        }\n        //Return an array with all Mesh\n        return Promise.all(mtlPromises).then(() => {\n            return babylonMeshesArray;\n        });\n    }\n\n}\n\nif (SceneLoader) {\n    //Add this loader into the register plugin\n    SceneLoader.RegisterPlugin(new OBJFileLoader());\n}","export * from \"./stlFileLoader\";","import { SceneLoader, ISceneLoaderPlugin, ISceneLoaderPluginExtensions, Scene, Nullable, AbstractMesh, IParticleSystem, Skeleton, Mesh, Tools, AssetContainer, VertexBuffer } from \"babylonjs\";\n\nexport class STLFileLoader implements ISceneLoaderPlugin {\n\n    public solidPattern = /solid (\\S*)([\\S\\s]*)endsolid[ ]*(\\S*)/g;\n    public facetsPattern = /facet([\\s\\S]*?)endfacet/g;\n    public normalPattern = /normal[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n    public vertexPattern = /vertex[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n    public name = \"stl\";\n\n    // force data to come in as an ArrayBuffer\n    // we'll convert to string if it looks like it's an ASCII .stl\n    public extensions: ISceneLoaderPluginExtensions = {\n        \".stl\": { isBinary: true },\n    };\n\n    public importMesh(meshesNames: any, scene: Scene, data: any, rootUrl: string, meshes: Nullable<AbstractMesh[]>, particleSystems: Nullable<IParticleSystem[]>, skeletons: Nullable<Skeleton[]>): boolean {\n        var matches;\n\n        if (typeof data !== \"string\") {\n\n            if (this.isBinary(data)) {\n                // binary .stl\n                var babylonMesh = new Mesh(\"stlmesh\", scene);\n                this.parseBinary(babylonMesh, data);\n                if (meshes) {\n                    meshes.push(babylonMesh);\n                }\n                return true;\n            }\n\n            // ASCII .stl\n\n            // convert to string\n            var array_buffer = new Uint8Array(data);\n            var str = '';\n            for (var i = 0; i < data.byteLength; i++) {\n                str += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian\n            }\n            data = str;\n        }\n\n        //if arrived here, data is a string, containing the STLA data.\n\n        while (matches = this.solidPattern.exec(data)) {\n            var meshName = matches[1];\n            var meshNameFromEnd = matches[3];\n            if (meshName != meshNameFromEnd) {\n                Tools.Error(\"Error in STL, solid name != endsolid name\");\n                return false;\n            }\n\n            // check meshesNames\n            if (meshesNames && meshName) {\n                if (meshesNames instanceof Array) {\n                    if (!meshesNames.indexOf(meshName)) {\n                        continue;\n                    }\n                } else {\n                    if (meshName !== meshesNames) {\n                        continue;\n                    }\n                }\n            }\n\n            // stl mesh name can be empty as well\n            meshName = meshName || \"stlmesh\";\n\n            var babylonMesh = new Mesh(meshName, scene);\n            this.parseASCII(babylonMesh, matches[2]);\n            if (meshes) {\n                meshes.push(babylonMesh);\n            }\n        }\n\n        return true;\n\n    }\n\n    public load(scene: Scene, data: any, rootUrl: string): boolean {\n        var result = this.importMesh(null, scene, data, rootUrl, null, null, null);\n\n        if (result) {\n            scene.createDefaultCameraOrLight();\n        }\n\n        return result;\n    }\n\n    public loadAssetContainer(scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer {\n        var container = new AssetContainer(scene);\n        this.importMesh(null, scene, data, rootUrl, container.meshes, null, null);\n        container.removeAllFromScene();\n        return container;\n    }\n\n    private isBinary(data: any) {\n\n        // check if file size is correct for binary stl\n        var faceSize, nFaces, reader;\n        reader = new DataView(data);\n        faceSize = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);\n        nFaces = reader.getUint32(80, true);\n\n        if (80 + (32 / 8) + (nFaces * faceSize) === reader.byteLength) {\n            return true;\n        }\n\n        // check characters higher than ASCII to confirm binary\n        var fileLength = reader.byteLength;\n        for (var index = 0; index < fileLength; index++) {\n            if (reader.getUint8(index) > 127) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private parseBinary(mesh: Mesh, data: ArrayBuffer) {\n\n        var reader = new DataView(data);\n        var faces = reader.getUint32(80, true);\n\n        var dataOffset = 84;\n        var faceLength = 12 * 4 + 2;\n\n        var offset = 0;\n\n        var positions = new Float32Array(faces * 3 * 3);\n        var normals = new Float32Array(faces * 3 * 3);\n        var indices = new Uint32Array(faces * 3);\n        var indicesCount = 0;\n\n        for (var face = 0; face < faces; face++) {\n\n            var start = dataOffset + face * faceLength;\n            var normalX = reader.getFloat32(start, true);\n            var normalY = reader.getFloat32(start + 4, true);\n            var normalZ = reader.getFloat32(start + 8, true);\n\n            for (var i = 1; i <= 3; i++) {\n\n                var vertexstart = start + i * 12;\n\n                // ordering is intentional to match ascii import\n                positions[offset] = reader.getFloat32(vertexstart, true);\n                positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);\n                positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);\n\n                normals[offset] = normalX;\n                normals[offset + 2] = normalY;\n                normals[offset + 1] = normalZ;\n\n                offset += 3;\n            }\n            indices[indicesCount] = indicesCount++;\n            indices[indicesCount] = indicesCount++;\n            indices[indicesCount] = indicesCount++;\n        }\n\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n        mesh.setIndices(indices);\n        mesh.computeWorldMatrix(true);\n    }\n\n    private parseASCII(mesh: Mesh, solidData: string) {\n\n        var positions = [];\n        var normals = [];\n        var indices = [];\n        var indicesCount = 0;\n\n        //load facets, ignoring loop as the standard doesn't define it can contain more than vertices\n        var matches;\n        while (matches = this.facetsPattern.exec(solidData)) {\n            var facet = matches[1];\n            //one normal per face\n            var normalMatches = this.normalPattern.exec(facet);\n            this.normalPattern.lastIndex = 0;\n            if (!normalMatches) {\n                continue;\n            }\n            var normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];\n\n            var vertexMatch;\n            while (vertexMatch = this.vertexPattern.exec(facet)) {\n                positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));\n                normals.push(normal[0], normal[1], normal[2]);\n            }\n            indices.push(indicesCount++, indicesCount++, indicesCount++);\n            this.vertexPattern.lastIndex = 0;\n        }\n\n        this.facetsPattern.lastIndex = 0;\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n        mesh.setIndices(indices);\n        mesh.computeWorldMatrix(true);\n    }\n}\n\nif (SceneLoader) {\n    SceneLoader.RegisterPlugin(new STLFileLoader());\n}"],"sourceRoot":""}