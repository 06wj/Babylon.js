{"version":3,"sources":["webpack://LOADERS/webpack/universalModuleDefinition","webpack://LOADERS/webpack/bootstrap","webpack://LOADERS/../node_modules/webpack/buildin/global.js","webpack://LOADERS/../Tools/Gulp/../../loaders/legacy/legacy-objFileLoader.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/OBJ/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/OBJ/objFileLoader.ts","webpack://LOADERS/external {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}"],"names":[],"mappings":"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","file":"babylon.objFileLoader.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-loaders\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-loaders\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"LOADERS\"] = factory(root[\"BABYLON\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE_babylonjs__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./legacy/legacy-objFileLoader.ts\");\n","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","import * as Loaders from \"../src/OBJ\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    for (var key in Loaders) {\r\n        (<any>globalObject).BABYLON[key] = (<any>Loaders)[key];\r\n    }\r\n}\r\n\r\nexport * from \"../src/OBJ\";","export * from \"./objFileLoader\";","import { Geometry, Mesh, SceneLoader, Vector3, Vector2, Tools, Color3, StandardMaterial, Nullable, Scene, Texture, ISceneLoaderPluginAsync, SceneLoaderProgressEvent, AbstractMesh, IParticleSystem, Skeleton, AnimationGroup, AssetContainer, VertexData } from \"babylonjs\";\n\n/**\n * Class reading and parsing the MTL file bundled with the obj file.\n */\nexport class MTLFileLoader {\n\n    // All material loaded from the mtl will be set here\n    public materials: StandardMaterial[] = [];\n\n    /**\n     * This function will read the mtl file and create each material described inside\n     * This function could be improve by adding :\n     * -some component missing (Ni, Tf...)\n     * -including the specific options available\n     *\n     * @param scene\n     * @param data\n     * @param rootUrl\n     */\n    public parseMTL(scene: Scene, data: string | ArrayBuffer, rootUrl: string) {\n        if (data instanceof ArrayBuffer) {\n            return;\n        }\n\n        //Split the lines from the file\n        var lines = data.split('\\n');\n        //Space char\n        var delimiter_pattern = /\\s+/;\n        //Array with RGB colors\n        var color: number[];\n        //New material\n        var material: Nullable<StandardMaterial> = null;\n\n        //Look at each line\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i].trim();\n\n            // Blank line or comment\n            if (line.length === 0 || line.charAt(0) === '#') {\n                continue;\n            }\n\n            //Get the first parameter (keyword)\n            var pos = line.indexOf(' ');\n            var key = (pos >= 0) ? line.substring(0, pos) : line;\n            key = key.toLowerCase();\n\n            //Get the data following the key\n            var value: string = (pos >= 0) ? line.substring(pos + 1).trim() : \"\";\n\n            //This mtl keyword will create the new material\n            if (key === \"newmtl\") {\n                //Check if it is the first material.\n                // Materials specifications are described after this keyword.\n                if (material) {\n                    //Add the previous material in the material array.\n                    this.materials.push(material);\n                }\n                //Create a new material.\n                // value is the name of the material read in the mtl file\n                material = new StandardMaterial(value, scene);\n            } else if (key === \"kd\" && material) {\n                // Diffuse color (color under white light) using RGB values\n\n                //value  = \"r g b\"\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.diffuseColor = Color3.FromArray(color);\n            } else if (key === \"ka\" && material) {\n                // Ambient color (color under shadow) using RGB values\n\n                //value = \"r g b\"\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.ambientColor = Color3.FromArray(color);\n            } else if (key === \"ks\" && material) {\n                // Specular color (color when light is reflected from shiny surface) using RGB values\n\n                //value = \"r g b\"\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set the color into the material\n                material.specularColor = Color3.FromArray(color);\n            } else if (key === \"ke\" && material) {\n                // Emissive color using RGB values\n                color = value.split(delimiter_pattern, 3).map(parseFloat);\n                material.emissiveColor = Color3.FromArray(color);\n            } else if (key === \"ns\" && material) {\n\n                //value = \"Integer\"\n                material.specularPower = parseFloat(value);\n            } else if (key === \"d\" && material) {\n                //d is dissolve for current material. It mean alpha for BABYLON\n                material.alpha = parseFloat(value);\n\n                //Texture\n                //This part can be improved by adding the possible options of texture\n            } else if (key === \"map_ka\" && material) {\n                // ambient texture map with a loaded image\n                //We must first get the folder of the image\n                material.ambientTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n            } else if (key === \"map_kd\" && material) {\n                // Diffuse texture map with a loaded image\n                material.diffuseTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n            } else if (key === \"map_ks\" && material) {\n                // Specular texture map with a loaded image\n                //We must first get the folder of the image\n                material.specularTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n            } else if (key === \"map_ns\") {\n                //Specular\n                //Specular highlight component\n                //We must first get the folder of the image\n                //\n                //Not supported by BABYLON\n                //\n                //    continue;\n            } else if (key === \"map_bump\" && material) {\n                //The bump texture\n                material.bumpTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n            } else if (key === \"map_d\" && material) {\n                // The dissolve of the material\n                material.opacityTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n\n                //Options for illumination\n            } else if (key === \"illum\") {\n                //Illumination\n                if (value === \"0\") {\n                    //That mean Kd == Kd\n                } else if (value === \"1\") {\n                    //Color on and Ambient on\n                } else if (value === \"2\") {\n                    //Highlight on\n                } else if (value === \"3\") {\n                    //Reflection on and Ray trace on\n                } else if (value === \"4\") {\n                    //Transparency: Glass on, Reflection: Ray trace on\n                } else if (value === \"5\") {\n                    //Reflection: Fresnel on and Ray trace on\n                } else if (value === \"6\") {\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\n                } else if (value === \"7\") {\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\n                } else if (value === \"8\") {\n                    //Reflection on and Ray trace off\n                } else if (value === \"9\") {\n                    //Transparency: Glass on, Reflection: Ray trace off\n                } else if (value === \"10\") {\n                    //Casts shadows onto invisible surfaces\n                }\n            } else {\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\n            }\n        }\n        //At the end of the file, add the last material\n        if (material) {\n            this.materials.push(material);\n        }\n    }\n\n    /**\n     * Gets the texture for the material.\n     *\n     * If the material is imported from input file,\n     * We sanitize the url to ensure it takes the textre from aside the material.\n     *\n     * @param rootUrl The root url to load from\n     * @param value The value stored in the mtl\n     * @return The Texture\n     */\n    private static _getTexture(rootUrl: string, value: string, scene: Scene): Nullable<Texture> {\n        if (!value) {\n            return null;\n        }\n\n        var url = rootUrl;\n        // Load from input file.\n        if (rootUrl === \"file:\") {\n            var lastDelimiter = value.lastIndexOf(\"\\\\\");\n            if (lastDelimiter === -1) {\n                lastDelimiter = value.lastIndexOf(\"/\");\n            }\n\n            if (lastDelimiter > -1) {\n                url += value.substr(lastDelimiter + 1);\n            }\n            else {\n                url += value;\n            }\n        }\n        // Not from input file.\n        else {\n            url += value;\n        }\n\n        return new Texture(url, scene);\n    }\n}\n\nexport class OBJFileLoader implements ISceneLoaderPluginAsync {\n\n    public static OPTIMIZE_WITH_UV = false;\n    public static INVERT_Y = false;\n    public name = \"obj\";\n    public extensions = \".obj\";\n    public obj = /^o/;\n    public group = /^g/;\n    public mtllib = /^mtllib /;\n    public usemtl = /^usemtl /;\n    public smooth = /^s /;\n    public vertexPattern = /v( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n    // vn float float float\n    public normalPattern = /vn( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n    // vt float float\n    public uvPattern = /vt( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n    // f vertex vertex vertex ...\n    public facePattern1 = /f\\s+(([\\d]{1,}[\\s]?){3,})+/;\n    // f vertex/uvs vertex/uvs vertex/uvs ...\n    public facePattern2 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n    // f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal ...\n    public facePattern3 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n    // f vertex//normal vertex//normal vertex//normal ...\n    public facePattern4 = /f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\n    // f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal ...\n    public facePattern5 = /f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\n\n    /**\n     * Calls synchronously the MTL file attached to this obj.\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\n     * Without this function materials are not displayed in the first frame (but displayed after).\n     * In consequence it is impossible to get material information in your HTML file\n     *\n     * @param url The URL of the MTL file\n     * @param rootUrl\n     * @param onSuccess Callback function to be called when the MTL file is loaded\n     * @private\n     */\n    private _loadMTL(url: string, rootUrl: string, onSuccess: (response: string | ArrayBuffer, responseUrl?: string) => any) {\n        //The complete path to the mtl file\n        var pathOfFile = Tools.BaseUrl + rootUrl + url;\n\n        // Loads through the babylon tools to allow fileInput search.\n        Tools.LoadFile(pathOfFile,\n            onSuccess,\n            undefined,\n            undefined,\n            false,\n            () => { console.warn(\"Error - Unable to load \" + pathOfFile); });\n    }\n\n    /**\n     * Imports one or more meshes from the loaded glTF data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the glTF data to load\n     * @param rootUrl root url to load from\n     * @param onProgress event that fires when loading progress has occured\n     * @param fileName Defines the name of the file to load\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\n     */\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }> {\n        //get the meshes from OBJ file\n        return this._parseSolid(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: []\n            };\n        });\n    }\n\n    /**\n     * Imports all objects from the loaded glTF data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the glTF data to load\n     * @param rootUrl root url to load from\n     * @param onProgress event that fires when loading progress has occured\n     * @param fileName Defines the name of the file to load\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    public loadAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\n        //Get the 3D model\n        return this.importMeshAsync(null, scene, data, rootUrl, onProgress).then(() => {\n            // return void\n        });\n    }\n\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @param onProgress The callback when the load progresses\n     * @param fileName Defines the name of the file to load\n     * @returns The loaded asset container\n     */\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer> {\n        return this.importMeshAsync(null, scene, data, rootUrl).then((result) => {\n            var container = new AssetContainer(scene);\n            result.meshes.forEach((mesh) => container.meshes.push(mesh));\n            container.removeAllFromScene();\n            return container;\n        });\n    }\n\n    /**\n     * Read the OBJ file and create an Array of meshes.\n     * Each mesh contains all information given by the OBJ and the MTL file.\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\n     *\n     * @param meshesNames\n     * @param scene Scene The scene where are displayed the data\n     * @param data String The content of the obj file\n     * @param rootUrl String The path to the folder\n     * @returns Array<AbstractMesh>\n     * @private\n     */\n    private _parseSolid(meshesNames: any, scene: Scene, data: string, rootUrl: string): Promise<Array<AbstractMesh>> {\n\n        var positions: Array<Vector3> = [];      //values for the positions of vertices\n        var normals: Array<Vector3> = [];      //Values for the normals\n        var uvs: Array<Vector2> = [];      //Values for the textures\n        var meshesFromObj: Array<any> = [];      //[mesh] Contains all the obj meshes\n        var handledMesh: any;      //The current mesh of meshes array\n        var indicesForBabylon: Array<number> = [];      //The list of indices for VertexData\n        var wrappedPositionForBabylon: Array<Vector3> = [];      //The list of position in vectors\n        var wrappedUvsForBabylon: Array<Vector2> = [];      //Array with all value of uvs to match with the indices\n        var wrappedNormalsForBabylon: Array<Vector3> = [];      //Array with all value of normals to match with the indices\n        var tuplePosNorm: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }> = [];      //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\n        var curPositionInIndices = 0;\n        var hasMeshes: Boolean = false;   //Meshes are defined in the file\n        var unwrappedPositionsForBabylon: Array<number> = [];      //Value of positionForBabylon w/o Vector3() [x,y,z]\n        var unwrappedNormalsForBabylon: Array<number> = [];      //Value of normalsForBabylon w/o Vector3()  [x,y,z]\n        var unwrappedUVForBabylon: Array<number> = [];      //Value of uvsForBabylon w/o Vector3()      [x,y,z]\n        var triangles: Array<string> = [];      //Indices from new triangles coming from polygons\n        var materialNameFromObj: string = \"\";      //The name of the current material\n        var fileToLoad: string = \"\";      //The name of the mtlFile to load\n        var materialsFromMTLFile: MTLFileLoader = new MTLFileLoader();\n        var objMeshName: string = \"\";      //The name of the current obj mesh\n        var increment: number = 1;      //Id for meshes created by the multimaterial\n        var isFirstMaterial: boolean = true;\n\n        /**\n         * Search for obj in the given array.\n         * This function is called to check if a couple of data already exists in an array.\n         *\n         * If found, returns the index of the founded tuple index. Returns -1 if not found\n         * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\n         * @param obj Array<number>\n         * @returns {boolean}\n         */\n        var isInArray = (arr: Array<{ normals: Array<number>; idx: Array<number> }>, obj: Array<number>) => {\n            if (!arr[obj[0]]) { arr[obj[0]] = { normals: [], idx: [] }; }\n            var idx = arr[obj[0]].normals.indexOf(obj[1]);\n\n            return idx === -1 ? -1 : arr[obj[0]].idx[idx];\n        };\n        var isInArrayUV = (arr: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }>, obj: Array<number>) => {\n            if (!arr[obj[0]]) { arr[obj[0]] = { normals: [], idx: [], uv: [] }; }\n            var idx = arr[obj[0]].normals.indexOf(obj[1]);\n\n            if (idx != 1 && (obj[2] == arr[obj[0]].uv[idx])) {\n                return arr[obj[0]].idx[idx];\n            }\n            return -1;\n        };\n\n        /**\n         * This function set the data for each triangle.\n         * Data are position, normals and uvs\n         * If a tuple of (position, normal) is not set, add the data into the corresponding array\n         * If the tuple already exist, add only their indice\n         *\n         * @param indicePositionFromObj Integer The index in positions array\n         * @param indiceUvsFromObj Integer The index in uvs array\n         * @param indiceNormalFromObj Integer The index in normals array\n         * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\n         * @param textureVectorFromOBJ Vector3 The value of uvs\n         * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\n         */\n        var setData = (indicePositionFromObj: number, indiceUvsFromObj: number, indiceNormalFromObj: number, positionVectorFromOBJ: Vector3, textureVectorFromOBJ: Vector2, normalsVectorFromOBJ: Vector3) => {\n            //Check if this tuple already exists in the list of tuples\n            var _index: number;\n            if (OBJFileLoader.OPTIMIZE_WITH_UV) {\n                _index = isInArrayUV(\n                    tuplePosNorm,\n                    [\n                        indicePositionFromObj,\n                        indiceNormalFromObj,\n                        indiceUvsFromObj\n                    ]\n                );\n            }\n            else {\n                _index = isInArray(\n                    tuplePosNorm,\n                    [\n                        indicePositionFromObj,\n                        indiceNormalFromObj\n                    ]\n                );\n            }\n\n            //If it not exists\n            if (_index == -1) {\n                //Add an new indice.\n                //The array of indices is only an array with his length equal to the number of triangles - 1.\n                //We add vertices data in this order\n                indicesForBabylon.push(wrappedPositionForBabylon.length);\n                //Push the position of vertice for Babylon\n                //Each element is a Vector3(x,y,z)\n                wrappedPositionForBabylon.push(positionVectorFromOBJ);\n                //Push the uvs for Babylon\n                //Each element is a Vector3(u,v)\n                wrappedUvsForBabylon.push(textureVectorFromOBJ);\n                //Push the normals for Babylon\n                //Each element is a Vector3(x,y,z)\n                wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\n                //Add the tuple in the comparison list\n                tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\n                tuplePosNorm[indicePositionFromObj].idx.push(curPositionInIndices++);\n                if (OBJFileLoader.OPTIMIZE_WITH_UV) { tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj); }\n            } else {\n                //The tuple already exists\n                //Add the index of the already existing tuple\n                //At this index we can get the value of position, normal and uvs of vertex\n                indicesForBabylon.push(_index);\n            }\n        };\n\n        /**\n         * Transform Vector() object onto 3 digits in an array\n         */\n        var unwrapData = () => {\n            //Every array has the same length\n            for (var l = 0; l < wrappedPositionForBabylon.length; l++) {\n                //Push the x, y, z values of each element in the unwrapped array\n                unwrappedPositionsForBabylon.push(wrappedPositionForBabylon[l].x, wrappedPositionForBabylon[l].y, wrappedPositionForBabylon[l].z);\n                unwrappedNormalsForBabylon.push(wrappedNormalsForBabylon[l].x, wrappedNormalsForBabylon[l].y, wrappedNormalsForBabylon[l].z);\n                unwrappedUVForBabylon.push(wrappedUvsForBabylon[l].x, wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\n            }\n            // Reset arrays for the next new meshes\n            wrappedPositionForBabylon = [];\n            wrappedNormalsForBabylon = [];\n            wrappedUvsForBabylon = [];\n            tuplePosNorm = [];\n            curPositionInIndices = 0;\n        };\n\n        /**\n         * Create triangles from polygons by recursion\n         * The best to understand how it works is to draw it in the same time you get the recursion.\n         * It is important to notice that a triangle is a polygon\n         * We get 5 patterns of face defined in OBJ File :\n         * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\n         * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\n         * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\n         * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\n         * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\n         * Each pattern is divided by the same method\n         * @param face Array[String] The indices of elements\n         * @param v Integer The variable to increment\n         */\n        var getTriangles = (face: Array<string>, v: number) => {\n            //Work for each element of the array\n            if (v + 1 < face.length) {\n                //Add on the triangle variable the indexes to obtain triangles\n                triangles.push(face[0], face[v], face[v + 1]);\n                //Incrementation for recursion\n                v += 1;\n                //Recursion\n                getTriangles(face, v);\n            }\n\n            //Result obtained after 2 iterations:\n            //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\n            //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\n            //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\n            //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\n            //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 1\n         * In this pattern we get vertice positions\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern1 = (face: Array<string>, v: number) => {\n            //Get the indices of triangles for each polygon\n            getTriangles(face, v);\n            //For each element in the triangles array.\n            //This var could contains 1 to an infinity of triangles\n            for (var k = 0; k < triangles.length; k++) {\n                // Set position indice\n                var indicePositionFromObj = parseInt(triangles[k]) - 1;\n\n                setData(\n                    indicePositionFromObj,\n                    0, 0,                                           //In the pattern 1, normals and uvs are not defined\n                    positions[indicePositionFromObj],               //Get the vectors data\n                    Vector2.Zero(), Vector3.Up()    //Create default vectors\n                );\n            }\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 2\n         * In this pattern we get vertice positions and uvsu\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern2 = (face: Array<string>, v: number) => {\n            //Get the indices of triangles for each polygon\n            getTriangles(face, v);\n            for (var k = 0; k < triangles.length; k++) {\n                //triangle[k] = \"1/1\"\n                //Split the data for getting position and uv\n                var point = triangles[k].split(\"/\"); // [\"1\", \"1\"]\n                //Set position indice\n                var indicePositionFromObj = parseInt(point[0]) - 1;\n                //Set uv indice\n                var indiceUvsFromObj = parseInt(point[1]) - 1;\n\n                setData(\n                    indicePositionFromObj,\n                    indiceUvsFromObj,\n                    0,                                  //Default value for normals\n                    positions[indicePositionFromObj],   //Get the values for each element\n                    uvs[indiceUvsFromObj],\n                    Vector3.Up()                //Default value for normals\n                );\n            }\n\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 3\n         * In this pattern we get vertice positions, uvs and normals\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern3 = (face: Array<string>, v: number) => {\n            //Get the indices of triangles for each polygon\n            getTriangles(face, v);\n\n            for (var k = 0; k < triangles.length; k++) {\n                //triangle[k] = \"1/1/1\"\n                //Split the data for getting position, uv, and normals\n                var point = triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\n                // Set position indice\n                var indicePositionFromObj = parseInt(point[0]) - 1;\n                // Set uv indice\n                var indiceUvsFromObj = parseInt(point[1]) - 1;\n                // Set normal indice\n                var indiceNormalFromObj = parseInt(point[2]) - 1;\n\n                setData(\n                    indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj,\n                    positions[indicePositionFromObj], uvs[indiceUvsFromObj], normals[indiceNormalFromObj] //Set the vector for each component\n                );\n\n            }\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 4\n         * In this pattern we get vertice positions and normals\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern4 = (face: Array<string>, v: number) => {\n            getTriangles(face, v);\n\n            for (var k = 0; k < triangles.length; k++) {\n                //triangle[k] = \"1//1\"\n                //Split the data for getting position and normals\n                var point = triangles[k].split(\"//\"); // [\"1\", \"1\"]\n                // We check indices, and normals\n                var indicePositionFromObj = parseInt(point[0]) - 1;\n                var indiceNormalFromObj = parseInt(point[1]) - 1;\n\n                setData(\n                    indicePositionFromObj,\n                    1, //Default value for uv\n                    indiceNormalFromObj,\n                    positions[indicePositionFromObj], //Get each vector of data\n                    Vector2.Zero(),\n                    normals[indiceNormalFromObj]\n                );\n            }\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 3\n         * In this pattern we get vertice positions, uvs and normals\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern5 = (face: Array<string>, v: number) => {\n            //Get the indices of triangles for each polygon\n            getTriangles(face, v);\n\n            for (var k = 0; k < triangles.length; k++) {\n                //triangle[k] = \"-1/-1/-1\"\n                //Split the data for getting position, uv, and normals\n                var point = triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\n                // Set position indice\n                var indicePositionFromObj =  positions.length + parseInt(point[0]);\n                // Set uv indice\n                var indiceUvsFromObj =  uvs.length + parseInt(point[1]);\n                // Set normal indice\n                var indiceNormalFromObj = normals.length + parseInt(point[2]);\n\n                setData(\n                    indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj,\n                    positions[indicePositionFromObj], uvs[indiceUvsFromObj], normals[indiceNormalFromObj] //Set the vector for each component\n                );\n\n            }\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        var addPreviousObjMesh = () => {\n\n            //Check if it is not the first mesh. Otherwise we don't have data.\n            if (meshesFromObj.length > 0) {\n                //Get the previous mesh for applying the data about the faces\n                //=> in obj file, faces definition append after the name of the mesh\n                handledMesh = meshesFromObj[meshesFromObj.length - 1];\n\n                //Set the data into Array for the mesh\n                unwrapData();\n\n                // Reverse tab. Otherwise face are displayed in the wrong sens\n                indicesForBabylon.reverse();\n                //Set the information for the mesh\n                //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\n                handledMesh.indices = indicesForBabylon.slice();\n                handledMesh.positions = unwrappedPositionsForBabylon.slice();\n                handledMesh.normals = unwrappedNormalsForBabylon.slice();\n                handledMesh.uvs = unwrappedUVForBabylon.slice();\n\n                //Reset the array for the next mesh\n                indicesForBabylon = [];\n                unwrappedPositionsForBabylon = [];\n                unwrappedNormalsForBabylon = [];\n                unwrappedUVForBabylon = [];\n            }\n        };\n        //Main function\n\n        //Split the file into lines\n        var lines = data.split('\\n');\n        //Look at each line\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i].trim();\n            var result;\n\n            //Comment or newLine\n            if (line.length === 0 || line.charAt(0) === '#') {\n                continue;\n\n                //Get information about one position possible for the vertices\n            } else if ((result = this.vertexPattern.exec(line)) !== null) {\n                //Create a Vector3 with the position x, y, z\n                //Value of result:\n                // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n                //Add the Vector in the list of positions\n                positions.push(new Vector3(\n                    parseFloat(result[1]),\n                    parseFloat(result[2]),\n                    parseFloat(result[3])\n                ));\n\n            } else if ((result = this.normalPattern.exec(line)) !== null) {\n                //Create a Vector3 with the normals x, y, z\n                //Value of result\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n                //Add the Vector in the list of normals\n                normals.push(new Vector3(\n                    parseFloat(result[1]),\n                    parseFloat(result[2]),\n                    parseFloat(result[3])\n                ));\n\n            } else if ((result = this.uvPattern.exec(line)) !== null) {\n                //Create a Vector2 with the normals u, v\n                //Value of result\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\n                //Add the Vector in the list of uvs\n                uvs.push(new Vector2(\n                    parseFloat(result[1]),\n                    parseFloat(result[2])\n                ));\n\n                //Identify patterns of faces\n                //Face could be defined in different type of pattern\n            } else if ((result = this.facePattern3.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern3(\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\n                    1\n                );\n\n            } else if ((result = this.facePattern4.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern4(\n                    result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\n                    1\n                );\n\n            } else if ((result = this.facePattern5.exec(line)) !== null) {\n                //Value of result:\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern5(\n                    result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\n                    1\n                );\n\n            } else if ((result = this.facePattern2.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern2(\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\n                    1\n                );\n\n            } else if ((result = this.facePattern1.exec(line)) !== null) {\n                //Value of result\n                //[\"f 1 2 3\", \"1 2 3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern1(\n                    result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\n                    1\n                );\n\n                //Define a mesh or an object\n                //Each time this keyword is analysed, create a new Object with all data for creating a babylonMesh\n            } else if (this.group.test(line) || this.obj.test(line)) {\n                //Create a new mesh corresponding to the name of the group.\n                //Definition of the mesh\n                var objMesh: {\n                    name: string;\n                    indices?: Array<number>;\n                    positions?: Array<number>;\n                    normals?: Array<number>;\n                    uvs?: Array<number>;\n                    materialName: string;\n                } =\n                //Set the name of the current obj mesh\n                {\n                    name: line.substring(2).trim(),\n                    indices: undefined,\n                    positions: undefined,\n                    normals: undefined,\n                    uvs: undefined,\n                    materialName: \"\"\n                };\n                addPreviousObjMesh();\n\n                //Push the last mesh created with only the name\n                meshesFromObj.push(objMesh);\n\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\n                hasMeshes = true;\n                isFirstMaterial = true;\n                increment = 1;\n                //Keyword for applying a material\n            } else if (this.usemtl.test(line)) {\n                //Get the name of the material\n                materialNameFromObj = line.substring(7).trim();\n\n                //If this new material is in the same mesh\n\n                if (!isFirstMaterial) {\n                    //Set the data for the previous mesh\n                    addPreviousObjMesh();\n                    //Create a new mesh\n                    var objMesh: {\n                        name: string;\n                        indices?: Array<number>;\n                        positions?: Array<number>;\n                        normals?: Array<number>;\n                        uvs?: Array<number>;\n                        materialName: string;\n                    } =\n                    //Set the name of the current obj mesh\n                    {\n                        name: objMeshName + \"_mm\" + increment.toString(),\n                        indices: undefined,\n                        positions: undefined,\n                        normals: undefined,\n                        uvs: undefined,\n                        materialName: materialNameFromObj\n                    };\n                    increment++;\n                    //If meshes are already defined\n                    meshesFromObj.push(objMesh);\n                }\n                //Set the material name if the previous line define a mesh\n\n                if (hasMeshes && isFirstMaterial) {\n                    //Set the material name to the previous mesh (1 material per mesh)\n                    meshesFromObj[meshesFromObj.length - 1].materialName = materialNameFromObj;\n                    isFirstMaterial = false;\n                }\n                //Keyword for loading the mtl file\n            } else if (this.mtllib.test(line)) {\n                //Get the name of mtl file\n                fileToLoad = line.substring(7).trim();\n\n                //Apply smoothing\n            } else if (this.smooth.test(line)) {\n                // smooth shading => apply smoothing\n                //Toda  y I don't know it work with babylon and with obj.\n                //With the obj file  an integer is set\n            } else {\n                //If there is another possibility\n                console.log(\"Unhandled expression at line : \" + line);\n            }\n        }\n\n        //At the end of the file, add the last mesh into the meshesFromObj array\n        if (hasMeshes) {\n            //Set the data for the last mesh\n            handledMesh = meshesFromObj[meshesFromObj.length - 1];\n\n            //Reverse indices for displaying faces in the good sens\n            indicesForBabylon.reverse();\n            //Get the good array\n            unwrapData();\n            //Set array\n            handledMesh.indices = indicesForBabylon;\n            handledMesh.positions = unwrappedPositionsForBabylon;\n            handledMesh.normals = unwrappedNormalsForBabylon;\n            handledMesh.uvs = unwrappedUVForBabylon;\n        }\n\n        //If any o or g keyword found, create a mesj with a random id\n        if (!hasMeshes) {\n            // reverse tab of indices\n            indicesForBabylon.reverse();\n            //Get positions normals uvs\n            unwrapData();\n            //Set data for one mesh\n            meshesFromObj.push({\n                name: Geometry.RandomId(),\n                indices: indicesForBabylon,\n                positions: unwrappedPositionsForBabylon,\n                normals: unwrappedNormalsForBabylon,\n                uvs: unwrappedUVForBabylon,\n                materialName: materialNameFromObj\n            });\n        }\n\n        //Create a Mesh list\n        var babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\n        var materialToUse = new Array<string>();\n\n        //Set data for each mesh\n        for (var j = 0; j < meshesFromObj.length; j++) {\n\n            //check meshesNames (stlFileLoader)\n            if (meshesNames && meshesFromObj[j].name) {\n                if (meshesNames instanceof Array) {\n                    if (meshesNames.indexOf(meshesFromObj[j].name) == -1) {\n                        continue;\n                    }\n                }\n                else {\n                    if (meshesFromObj[j].name !== meshesNames) {\n                        continue;\n                    }\n                }\n            }\n\n            //Get the current mesh\n            //Set the data with VertexBuffer for each mesh\n            handledMesh = meshesFromObj[j];\n            //Create a Mesh with the name of the obj mesh\n            var babylonMesh = new Mesh(meshesFromObj[j].name, scene);\n            //Push the name of the material to an array\n            //This is indispensable for the importMesh function\n            materialToUse.push(meshesFromObj[j].materialName);\n\n            var vertexData: VertexData = new VertexData(); //The container for the values\n            //Set the data for the babylonMesh\n            vertexData.positions = handledMesh.positions;\n            vertexData.normals = handledMesh.normals;\n            vertexData.uvs = handledMesh.uvs;\n            vertexData.indices = handledMesh.indices;\n            //Set the data from the VertexBuffer to the current Mesh\n            vertexData.applyToMesh(babylonMesh);\n            if (OBJFileLoader.INVERT_Y) {\n                babylonMesh.scaling.y *= -1;\n            }\n\n            //Push the mesh into an array\n            babylonMeshesArray.push(babylonMesh);\n        }\n\n        let mtlPromises: Array<Promise<any>> = [];\n        //load the materials\n        //Check if we have a file to load\n        if (fileToLoad !== \"\") {\n            //Load the file synchronously\n            mtlPromises.push(new Promise((resolve, reject) => {\n                this._loadMTL(fileToLoad, rootUrl, function(dataLoaded) {\n                    try {\n                        //Create materials thanks MTLLoader function\n                        materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl);\n                        //Look at each material loaded in the mtl file\n                        for (var n = 0; n < materialsFromMTLFile.materials.length; n++) {\n                            //Three variables to get all meshes with the same material\n                            var startIndex = 0;\n                            var _indices = [];\n                            var _index;\n\n                            //The material from MTL file is used in the meshes loaded\n                            //Push the indice in an array\n                            //Check if the material is not used for another mesh\n                            while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\n                                _indices.push(_index);\n                                startIndex = _index + 1;\n                            }\n                            //If the material is not used dispose it\n                            if (_index == -1 && _indices.length == 0) {\n                                //If the material is not needed, remove it\n                                materialsFromMTLFile.materials[n].dispose();\n                            } else {\n                                for (var o = 0; o < _indices.length; o++) {\n                                    //Apply the material to the Mesh for each mesh with the material\n                                    babylonMeshesArray[_indices[o]].material = materialsFromMTLFile.materials[n];\n                                }\n                            }\n                        }\n                        resolve();\n                    } catch (e) {\n                        reject(e);\n                    }\n\n                });\n            }));\n\n        }\n        //Return an array with all Mesh\n        return Promise.all(mtlPromises).then(() => {\n            return babylonMeshesArray;\n        });\n    }\n\n}\n\nif (SceneLoader) {\n    //Add this loader into the register plugin\n    SceneLoader.RegisterPlugin(new OBJFileLoader());\n}","module.exports = __WEBPACK_EXTERNAL_MODULE_babylonjs__;"],"sourceRoot":""}