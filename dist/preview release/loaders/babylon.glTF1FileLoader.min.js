<<<<<<< HEAD
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("babylonjs"));
	else if(typeof define === 'function' && define.amd)
		define("babylonjs-loaders", ["babylonjs"], factory);
	else if(typeof exports === 'object')
		exports["babylonjs-loaders"] = factory(require("babylonjs"));
	else
		root["LOADERS"] = factory(root["BABYLON"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_babylonjs__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./legacy/legacy-glTF1FileLoader.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./legacy/legacy-glTF1FileLoader.ts":
/*!******************************************!*\
  !*** ./legacy/legacy-glTF1FileLoader.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var FileLoader = __webpack_require__(/*! ../src/glTF/glTFFileLoader */ "./src/glTF/glTFFileLoader.ts");
var LoadersV1 = __webpack_require__(/*! ../src/glTF/1.0 */ "./src/glTF/1.0/index.ts");
/**
 * This is the entry point for the UMD module.
 * The entry point for a future ESM package should be index.ts
 */
var globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);
if (typeof globalObject !== "undefined") {
    globalObject.BABYLON = globalObject.BABYLON || {};
    for (var key in FileLoader) {
        globalObject.BABYLON[key] = FileLoader[key];
    }
    globalObject.BABYLON.GLTF1 = globalObject.BABYLON.GLTF1 || {};
    for (var key in LoadersV1) {
        globalObject.BABYLON.GLTF1[key] = LoadersV1[key];
    }
}
__export(__webpack_require__(/*! ../src/glTF/glTFFileLoader */ "./src/glTF/glTFFileLoader.ts"));
__export(__webpack_require__(/*! ../src/glTF/1.0 */ "./src/glTF/1.0/index.ts"));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/glTF/1.0/GLTF1Loader.ts":
/*!*************************************!*\
  !*** ./src/glTF/1.0/GLTF1Loader.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var glTFLoaderInterfaces_1 = __webpack_require__(/*! ./glTFLoaderInterfaces */ "./src/glTF/1.0/glTFLoaderInterfaces.ts");
var glTFLoaderUtils_1 = __webpack_require__(/*! ./glTFLoaderUtils */ "./src/glTF/1.0/glTFLoaderUtils.ts");
var babylonjs_1 = __webpack_require__(/*! babylonjs */ "babylonjs");
var glTFFileLoader_1 = __webpack_require__(/*! ../glTFFileLoader */ "./src/glTF/glTFFileLoader.ts");
var glTFLoaderExtension_1 = __webpack_require__(/*! ./glTFLoaderExtension */ "./src/glTF/1.0/glTFLoaderExtension.ts");
/**
* Tokenizer. Used for shaders compatibility
* Automatically map world, view, projection, worldViewProjection, attributes and so on
*/
var ETokenType;
(function (ETokenType) {
    ETokenType[ETokenType["IDENTIFIER"] = 1] = "IDENTIFIER";
    ETokenType[ETokenType["UNKNOWN"] = 2] = "UNKNOWN";
    ETokenType[ETokenType["END_OF_INPUT"] = 3] = "END_OF_INPUT";
})(ETokenType || (ETokenType = {}));
var Tokenizer = /** @class */ (function () {
    function Tokenizer(toParse) {
        this._pos = 0;
        this.currentToken = ETokenType.UNKNOWN;
        this.currentIdentifier = "";
        this.currentString = "";
        this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/;
        this._toParse = toParse;
        this._maxPos = toParse.length;
    }
    Tokenizer.prototype.getNextToken = function () {
        if (this.isEnd()) {
            return ETokenType.END_OF_INPUT;
        }
        this.currentString = this.read();
        this.currentToken = ETokenType.UNKNOWN;
        if (this.currentString === "_" || this.isLetterOrDigitPattern.test(this.currentString)) {
            this.currentToken = ETokenType.IDENTIFIER;
            this.currentIdentifier = this.currentString;
            while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === "_")) {
                this.currentIdentifier += this.currentString;
                this.forward();
            }
        }
        return this.currentToken;
    };
    Tokenizer.prototype.peek = function () {
        return this._toParse[this._pos];
    };
    Tokenizer.prototype.read = function () {
        return this._toParse[this._pos++];
    };
    Tokenizer.prototype.forward = function () {
        this._pos++;
    };
    Tokenizer.prototype.isEnd = function () {
        return this._pos >= this._maxPos;
    };
    return Tokenizer;
}());
/**
* Values
*/
var glTFTransforms = ["MODEL", "VIEW", "PROJECTION", "MODELVIEW", "MODELVIEWPROJECTION", "JOINTMATRIX"];
var babylonTransforms = ["world", "view", "projection", "worldView", "worldViewProjection", "mBones"];
var glTFAnimationPaths = ["translation", "rotation", "scale"];
var babylonAnimationPaths = ["position", "rotationQuaternion", "scaling"];
/**
* Parse
*/
var parseBuffers = function (parsedBuffers, gltfRuntime) {
    for (var buf in parsedBuffers) {
        var parsedBuffer = parsedBuffers[buf];
        gltfRuntime.buffers[buf] = parsedBuffer;
        gltfRuntime.buffersCount++;
    }
};
var parseShaders = function (parsedShaders, gltfRuntime) {
    for (var sha in parsedShaders) {
        var parsedShader = parsedShaders[sha];
        gltfRuntime.shaders[sha] = parsedShader;
        gltfRuntime.shaderscount++;
    }
};
var parseObject = function (parsedObjects, runtimeProperty, gltfRuntime) {
    for (var object in parsedObjects) {
        var parsedObject = parsedObjects[object];
        gltfRuntime[runtimeProperty][object] = parsedObject;
    }
};
/**
* Utils
*/
var normalizeUVs = function (buffer) {
    if (!buffer) {
        return;
    }
    for (var i = 0; i < buffer.length / 2; i++) {
        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];
    }
};
var getAttribute = function (attributeParameter) {
    if (attributeParameter.semantic === "NORMAL") {
        return "normal";
    }
    else if (attributeParameter.semantic === "POSITION") {
        return "position";
    }
    else if (attributeParameter.semantic === "JOINT") {
        return "matricesIndices";
    }
    else if (attributeParameter.semantic === "WEIGHT") {
        return "matricesWeights";
    }
    else if (attributeParameter.semantic === "COLOR") {
        return "color";
    }
    else if (attributeParameter.semantic && attributeParameter.semantic.indexOf("TEXCOORD_") !== -1) {
        var channel = Number(attributeParameter.semantic.split("_")[1]);
        return "uv" + (channel === 0 ? "" : channel + 1);
    }
    return null;
};
/**
* Loads and creates animations
*/
var loadAnimations = function (gltfRuntime) {
    for (var anim in gltfRuntime.animations) {
        var animation = gltfRuntime.animations[anim];
        if (!animation.channels || !animation.samplers) {
            continue;
        }
        var lastAnimation = null;
        for (var i = 0; i < animation.channels.length; i++) {
            // Get parameters and load buffers
            var channel = animation.channels[i];
            var sampler = animation.samplers[channel.sampler];
            if (!sampler) {
                continue;
            }
            var inputData = null;
            var outputData = null;
            if (animation.parameters) {
                inputData = animation.parameters[sampler.input];
                outputData = animation.parameters[sampler.output];
            }
            else {
                inputData = sampler.input;
                outputData = sampler.output;
            }
            var bufferInput = glTFLoaderUtils_1.GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);
            var bufferOutput = glTFLoaderUtils_1.GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);
            var targetID = channel.target.id;
            var targetNode = gltfRuntime.scene.getNodeByID(targetID);
            if (targetNode === null) {
                targetNode = gltfRuntime.scene.getNodeByName(targetID);
            }
            if (targetNode === null) {
                babylonjs_1.Tools.Warn("Creating animation named " + anim + ". But cannot find node named " + targetID + " to attach to");
                continue;
            }
            var isBone = targetNode instanceof babylonjs_1.Bone;
            // Get target path (position, rotation or scaling)
            var targetPath = channel.target.path;
            var targetPathIndex = glTFAnimationPaths.indexOf(targetPath);
            if (targetPathIndex !== -1) {
                targetPath = babylonAnimationPaths[targetPathIndex];
            }
            // Determine animation type
            var animationType = babylonjs_1.Animation.ANIMATIONTYPE_MATRIX;
            if (!isBone) {
                if (targetPath === "rotationQuaternion") {
                    animationType = babylonjs_1.Animation.ANIMATIONTYPE_QUATERNION;
                    targetNode.rotationQuaternion = new babylonjs_1.Quaternion();
                }
                else {
                    animationType = babylonjs_1.Animation.ANIMATIONTYPE_VECTOR3;
                }
            }
            // Create animation and key frames
            var babylonAnimation = null;
            var keys = [];
            var arrayOffset = 0;
            var modifyKey = false;
            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {
                babylonAnimation = lastAnimation;
                modifyKey = true;
            }
            if (!modifyKey) {
                babylonAnimation = new babylonjs_1.Animation(anim, isBone ? "_matrix" : targetPath, 1, animationType, babylonjs_1.Animation.ANIMATIONLOOPMODE_CYCLE);
            }
            // For each frame
            for (var j = 0; j < bufferInput.length; j++) {
                var value = null;
                if (targetPath === "rotationQuaternion") { // VEC4
                    value = babylonjs_1.Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);
                    arrayOffset += 4;
                }
                else { // Position and scaling are VEC3
                    value = babylonjs_1.Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);
                    arrayOffset += 3;
                }
                if (isBone) {
                    var bone = targetNode;
                    var translation = babylonjs_1.Vector3.Zero();
                    var rotationQuaternion = new babylonjs_1.Quaternion();
                    var scaling = babylonjs_1.Vector3.Zero();
                    // Warning on decompose
                    var mat = bone.getBaseMatrix();
                    if (modifyKey && lastAnimation) {
                        mat = lastAnimation.getKeys()[j].value;
                    }
                    mat.decompose(scaling, rotationQuaternion, translation);
                    if (targetPath === "position") {
                        translation = value;
                    }
                    else if (targetPath === "rotationQuaternion") {
                        rotationQuaternion = value;
                    }
                    else {
                        scaling = value;
                    }
                    value = babylonjs_1.Matrix.Compose(scaling, rotationQuaternion, translation);
                }
                if (!modifyKey) {
                    keys.push({
                        frame: bufferInput[j],
                        value: value
                    });
                }
                else if (lastAnimation) {
                    lastAnimation.getKeys()[j].value = value;
                }
            }
            // Finish
            if (!modifyKey && babylonAnimation) {
                babylonAnimation.setKeys(keys);
                targetNode.animations.push(babylonAnimation);
            }
            lastAnimation = babylonAnimation;
            gltfRuntime.scene.stopAnimation(targetNode);
            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);
        }
    }
};
/**
* Returns the bones transformation matrix
*/
var configureBoneTransformation = function (node) {
    var mat = null;
    if (node.translation || node.rotation || node.scale) {
        var scale = babylonjs_1.Vector3.FromArray(node.scale || [1, 1, 1]);
        var rotation = babylonjs_1.Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);
        var position = babylonjs_1.Vector3.FromArray(node.translation || [0, 0, 0]);
        mat = babylonjs_1.Matrix.Compose(scale, rotation, position);
    }
    else {
        mat = babylonjs_1.Matrix.FromArray(node.matrix);
    }
    return mat;
};
/**
* Returns the parent bone
*/
var getParentBone = function (gltfRuntime, skins, jointName, newSkeleton) {
    // Try to find
    for (var i = 0; i < newSkeleton.bones.length; i++) {
        if (newSkeleton.bones[i].name === jointName) {
            return newSkeleton.bones[i];
        }
    }
    // Not found, search in gltf nodes
    var nodes = gltfRuntime.nodes;
    for (var nde in nodes) {
        var node = nodes[nde];
        if (!node.jointName) {
            continue;
        }
        var children = node.children;
        for (var i = 0; i < children.length; i++) {
            var child = gltfRuntime.nodes[children[i]];
            if (!child.jointName) {
                continue;
            }
            if (child.jointName === jointName) {
                var mat = configureBoneTransformation(node);
                var bone = new babylonjs_1.Bone(node.name || "", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);
                bone.id = nde;
                return bone;
            }
        }
    }
    return null;
};
/**
* Returns the appropriate root node
*/
var getNodeToRoot = function (nodesToRoot, id) {
    for (var i = 0; i < nodesToRoot.length; i++) {
        var nodeToRoot = nodesToRoot[i];
        for (var j = 0; j < nodeToRoot.node.children.length; j++) {
            var child = nodeToRoot.node.children[j];
            if (child === id) {
                return nodeToRoot.bone;
            }
        }
    }
    return null;
};
/**
* Returns the node with the joint name
*/
var getJointNode = function (gltfRuntime, jointName) {
    var nodes = gltfRuntime.nodes;
    var node = nodes[jointName];
    if (node) {
        return {
            node: node,
            id: jointName
        };
    }
    for (var nde in nodes) {
        node = nodes[nde];
        if (node.jointName === jointName) {
            return {
                node: node,
                id: nde
            };
        }
    }
    return null;
};
/**
* Checks if a nodes is in joints
*/
var nodeIsInJoints = function (skins, id) {
    for (var i = 0; i < skins.jointNames.length; i++) {
        if (skins.jointNames[i] === id) {
            return true;
        }
    }
    return false;
};
/**
* Fills the nodes to root for bones and builds hierarchy
*/
var getNodesToRoot = function (gltfRuntime, newSkeleton, skins, nodesToRoot) {
    // Creates nodes for root
    for (var nde in gltfRuntime.nodes) {
        var node = gltfRuntime.nodes[nde];
        var id = nde;
        if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {
            continue;
        }
        // Create node to root bone
        var mat = configureBoneTransformation(node);
        var bone = new babylonjs_1.Bone(node.name || "", newSkeleton, null, mat);
        bone.id = id;
        nodesToRoot.push({ bone: bone, node: node, id: id });
    }
    // Parenting
    for (var i = 0; i < nodesToRoot.length; i++) {
        var nodeToRoot = nodesToRoot[i];
        var children = nodeToRoot.node.children;
        for (var j = 0; j < children.length; j++) {
            var child = null;
            for (var k = 0; k < nodesToRoot.length; k++) {
                if (nodesToRoot[k].id === children[j]) {
                    child = nodesToRoot[k];
                    break;
                }
            }
            if (child) {
                child.bone._parent = nodeToRoot.bone;
                nodeToRoot.bone.children.push(child.bone);
            }
        }
    }
};
/**
* Imports a skeleton
*/
var importSkeleton = function (gltfRuntime, skins, mesh, newSkeleton, id) {
    if (!newSkeleton) {
        newSkeleton = new babylonjs_1.Skeleton(skins.name || "", "", gltfRuntime.scene);
    }
    if (!skins.babylonSkeleton) {
        return newSkeleton;
    }
    // Find the root bones
    var nodesToRoot = [];
    var nodesToRootToAdd = [];
    getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);
    newSkeleton.bones = [];
    // Joints
    for (var i = 0; i < skins.jointNames.length; i++) {
        var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);
        if (!jointNode) {
            continue;
        }
        var node = jointNode.node;
        if (!node) {
            babylonjs_1.Tools.Warn("Joint named " + skins.jointNames[i] + " does not exist");
            continue;
        }
        var id = jointNode.id;
        // Optimize, if the bone already exists...
        var existingBone = gltfRuntime.scene.getBoneByID(id);
        if (existingBone) {
            newSkeleton.bones.push(existingBone);
            continue;
        }
        // Search for parent bone
        var foundBone = false;
        var parentBone = null;
        for (var j = 0; j < i; j++) {
            var jointNode_1 = getJointNode(gltfRuntime, skins.jointNames[j]);
            if (!jointNode_1) {
                continue;
            }
            var joint = jointNode_1.node;
            if (!joint) {
                babylonjs_1.Tools.Warn("Joint named " + skins.jointNames[j] + " does not exist when looking for parent");
                continue;
            }
            var children = joint.children;
            if (!children) {
                continue;
            }
            foundBone = false;
            for (var k = 0; k < children.length; k++) {
                if (children[k] === id) {
                    parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);
                    foundBone = true;
                    break;
                }
            }
            if (foundBone) {
                break;
            }
        }
        // Create bone
        var mat = configureBoneTransformation(node);
        if (!parentBone && nodesToRoot.length > 0) {
            parentBone = getNodeToRoot(nodesToRoot, id);
            if (parentBone) {
                if (nodesToRootToAdd.indexOf(parentBone) === -1) {
                    nodesToRootToAdd.push(parentBone);
                }
            }
        }
        var bone = new babylonjs_1.Bone(node.jointName || "", newSkeleton, parentBone, mat);
        bone.id = id;
    }
    // Polish
    var bones = newSkeleton.bones;
    newSkeleton.bones = [];
    for (var i = 0; i < skins.jointNames.length; i++) {
        var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);
        if (!jointNode) {
            continue;
        }
        for (var j = 0; j < bones.length; j++) {
            if (bones[j].id === jointNode.id) {
                newSkeleton.bones.push(bones[j]);
                break;
            }
        }
    }
    newSkeleton.prepare();
    // Finish
    for (var i = 0; i < nodesToRootToAdd.length; i++) {
        newSkeleton.bones.push(nodesToRootToAdd[i]);
    }
    return newSkeleton;
};
/**
* Imports a mesh and its geometries
*/
var importMesh = function (gltfRuntime, node, meshes, id, newMesh) {
    if (!newMesh) {
        newMesh = new babylonjs_1.Mesh(node.name || "", gltfRuntime.scene);
        newMesh.id = id;
    }
    if (!node.babylonNode) {
        return newMesh;
    }
    var subMaterials = [];
    var vertexData = null;
    var verticesStarts = new Array();
    var verticesCounts = new Array();
    var indexStarts = new Array();
    var indexCounts = new Array();
    for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
        var meshID = meshes[meshIndex];
        var mesh = gltfRuntime.meshes[meshID];
        if (!mesh) {
            continue;
        }
        // Positions, normals and UVs
        for (var i = 0; i < mesh.primitives.length; i++) {
            // Temporary vertex data
            var tempVertexData = new babylonjs_1.VertexData();
            var primitive = mesh.primitives[i];
            if (primitive.mode !== 4) {
                // continue;
            }
            var attributes = primitive.attributes;
            var accessor = null;
            var buffer = null;
            // Set positions, normal and uvs
            for (var semantic in attributes) {
                // Link accessor and buffer view
                accessor = gltfRuntime.accessors[attributes[semantic]];
                buffer = glTFLoaderUtils_1.GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
                if (semantic === "NORMAL") {
                    tempVertexData.normals = new Float32Array(buffer.length);
                    tempVertexData.normals.set(buffer);
                }
                else if (semantic === "POSITION") {
                    if (glTFFileLoader_1.GLTFFileLoader.HomogeneousCoordinates) {
                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);
                        for (var j = 0; j < buffer.length; j += 4) {
                            tempVertexData.positions[j] = buffer[j];
                            tempVertexData.positions[j + 1] = buffer[j + 1];
                            tempVertexData.positions[j + 2] = buffer[j + 2];
                        }
                    }
                    else {
                        tempVertexData.positions = new Float32Array(buffer.length);
                        tempVertexData.positions.set(buffer);
                    }
                    verticesCounts.push(tempVertexData.positions.length);
                }
                else if (semantic.indexOf("TEXCOORD_") !== -1) {
                    var channel = Number(semantic.split("_")[1]);
                    var uvKind = babylonjs_1.VertexBuffer.UVKind + (channel === 0 ? "" : (channel + 1));
                    var uvs = new Float32Array(buffer.length);
                    uvs.set(buffer);
                    normalizeUVs(uvs);
                    tempVertexData.set(uvs, uvKind);
                }
                else if (semantic === "JOINT") {
                    tempVertexData.matricesIndices = new Float32Array(buffer.length);
                    tempVertexData.matricesIndices.set(buffer);
                }
                else if (semantic === "WEIGHT") {
                    tempVertexData.matricesWeights = new Float32Array(buffer.length);
                    tempVertexData.matricesWeights.set(buffer);
                }
                else if (semantic === "COLOR") {
                    tempVertexData.colors = new Float32Array(buffer.length);
                    tempVertexData.colors.set(buffer);
                }
            }
            // Indices
            accessor = gltfRuntime.accessors[primitive.indices];
            if (accessor) {
                buffer = glTFLoaderUtils_1.GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
                tempVertexData.indices = new Int32Array(buffer.length);
                tempVertexData.indices.set(buffer);
                indexCounts.push(tempVertexData.indices.length);
            }
            else {
                // Set indices on the fly
                var indices = [];
                for (var j = 0; j < tempVertexData.positions.length / 3; j++) {
                    indices.push(j);
                }
                tempVertexData.indices = new Int32Array(indices);
                indexCounts.push(tempVertexData.indices.length);
            }
            if (!vertexData) {
                vertexData = tempVertexData;
            }
            else {
                vertexData.merge(tempVertexData);
            }
            // Sub material
            var material_1 = gltfRuntime.scene.getMaterialByID(primitive.material);
            subMaterials.push(material_1 === null ? glTFLoaderUtils_1.GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material_1);
            // Update vertices start and index start
            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);
            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);
        }
    }
    var material;
    if (subMaterials.length > 1) {
        material = new babylonjs_1.MultiMaterial("multimat" + id, gltfRuntime.scene);
        material.subMaterials = subMaterials;
    }
    else {
        material = new babylonjs_1.StandardMaterial("multimat" + id, gltfRuntime.scene);
    }
    if (subMaterials.length === 1) {
        material = subMaterials[0];
    }
    if (!newMesh.material) {
        newMesh.material = material;
    }
    // Apply geometry
    new babylonjs_1.Geometry(id, gltfRuntime.scene, vertexData, false, newMesh);
    newMesh.computeWorldMatrix(true);
    // Apply submeshes
    newMesh.subMeshes = [];
    var index = 0;
    for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
        var meshID = meshes[meshIndex];
        var mesh = gltfRuntime.meshes[meshID];
        if (!mesh) {
            continue;
        }
        for (var i = 0; i < mesh.primitives.length; i++) {
            if (mesh.primitives[i].mode !== 4) {
                //continue;
            }
            babylonjs_1.SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);
            index++;
        }
    }
    // Finish
    return newMesh;
};
/**
* Configure node transformation from position, rotation and scaling
*/
var configureNode = function (newNode, position, rotation, scaling) {
    if (newNode.position) {
        newNode.position = position;
    }
    if (newNode.rotationQuaternion || newNode.rotation) {
        newNode.rotationQuaternion = rotation;
    }
    if (newNode.scaling) {
        newNode.scaling = scaling;
    }
};
/**
* Configures node from transformation matrix
*/
var configureNodeFromMatrix = function (newNode, node, parent) {
    if (node.matrix) {
        var position = new babylonjs_1.Vector3(0, 0, 0);
        var rotation = new babylonjs_1.Quaternion();
        var scaling = new babylonjs_1.Vector3(0, 0, 0);
        var mat = babylonjs_1.Matrix.FromArray(node.matrix);
        mat.decompose(scaling, rotation, position);
        configureNode(newNode, position, rotation, scaling);
    }
    else if (node.translation && node.rotation && node.scale) {
        configureNode(newNode, babylonjs_1.Vector3.FromArray(node.translation), babylonjs_1.Quaternion.FromArray(node.rotation), babylonjs_1.Vector3.FromArray(node.scale));
    }
    newNode.computeWorldMatrix(true);
};
/**
* Imports a node
*/
var importNode = function (gltfRuntime, node, id, parent) {
    var lastNode = null;
    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {
        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || "") === -1) {
            return null;
        }
    }
    // Meshes
    if (node.skin) {
        if (node.meshes) {
            var skin = gltfRuntime.skins[node.skin];
            var newMesh = importMesh(gltfRuntime, node, node.meshes, id, node.babylonNode);
            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonByID(node.skin);
            if (newMesh.skeleton === null) {
                newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton, node.skin);
                if (!skin.babylonSkeleton) {
                    skin.babylonSkeleton = newMesh.skeleton;
                }
            }
            lastNode = newMesh;
        }
    }
    else if (node.meshes) {
        /**
        * Improve meshes property
        */
        var newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, node.babylonNode);
        lastNode = newMesh;
    }
    // Lights
    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
        var light = gltfRuntime.lights[node.light];
        if (light) {
            if (light.type === "ambient") {
                var ambienLight = light[light.type];
                var hemiLight = new babylonjs_1.HemisphericLight(node.light, babylonjs_1.Vector3.Zero(), gltfRuntime.scene);
                hemiLight.name = node.name || "";
                if (ambienLight.color) {
                    hemiLight.diffuse = babylonjs_1.Color3.FromArray(ambienLight.color);
                }
                lastNode = hemiLight;
            }
            else if (light.type === "directional") {
                var directionalLight = light[light.type];
                var dirLight = new babylonjs_1.DirectionalLight(node.light, babylonjs_1.Vector3.Zero(), gltfRuntime.scene);
                dirLight.name = node.name || "";
                if (directionalLight.color) {
                    dirLight.diffuse = babylonjs_1.Color3.FromArray(directionalLight.color);
                }
                lastNode = dirLight;
            }
            else if (light.type === "point") {
                var pointLight = light[light.type];
                var ptLight = new babylonjs_1.PointLight(node.light, babylonjs_1.Vector3.Zero(), gltfRuntime.scene);
                ptLight.name = node.name || "";
                if (pointLight.color) {
                    ptLight.diffuse = babylonjs_1.Color3.FromArray(pointLight.color);
                }
                lastNode = ptLight;
            }
            else if (light.type === "spot") {
                var spotLight = light[light.type];
                var spLight = new babylonjs_1.SpotLight(node.light, babylonjs_1.Vector3.Zero(), babylonjs_1.Vector3.Zero(), 0, 0, gltfRuntime.scene);
                spLight.name = node.name || "";
                if (spotLight.color) {
                    spLight.diffuse = babylonjs_1.Color3.FromArray(spotLight.color);
                }
                if (spotLight.fallOfAngle) {
                    spLight.angle = spotLight.fallOfAngle;
                }
                if (spotLight.fallOffExponent) {
                    spLight.exponent = spotLight.fallOffExponent;
                }
                lastNode = spLight;
            }
        }
    }
    // Cameras
    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
        var camera = gltfRuntime.cameras[node.camera];
        if (camera) {
            if (camera.type === "orthographic") {
                var orthoCamera = new babylonjs_1.FreeCamera(node.camera, babylonjs_1.Vector3.Zero(), gltfRuntime.scene, false);
                orthoCamera.name = node.name || "";
                orthoCamera.mode = babylonjs_1.Camera.ORTHOGRAPHIC_CAMERA;
                orthoCamera.attachControl(gltfRuntime.scene.getEngine().getRenderingCanvas());
                lastNode = orthoCamera;
            }
            else if (camera.type === "perspective") {
                var perspectiveCamera = camera[camera.type];
                var persCamera = new babylonjs_1.FreeCamera(node.camera, babylonjs_1.Vector3.Zero(), gltfRuntime.scene, false);
                persCamera.name = node.name || "";
                persCamera.attachControl(gltfRuntime.scene.getEngine().getRenderingCanvas());
                if (!perspectiveCamera.aspectRatio) {
                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();
                }
                if (perspectiveCamera.znear && perspectiveCamera.zfar) {
                    persCamera.maxZ = perspectiveCamera.zfar;
                    persCamera.minZ = perspectiveCamera.znear;
                }
                lastNode = persCamera;
            }
        }
    }
    // Empty node
    if (!node.jointName) {
        if (node.babylonNode) {
            return node.babylonNode;
        }
        else if (lastNode === null) {
            var dummy = new babylonjs_1.Mesh(node.name || "", gltfRuntime.scene);
            node.babylonNode = dummy;
            lastNode = dummy;
        }
    }
    if (lastNode !== null) {
        if (node.matrix && lastNode instanceof babylonjs_1.Mesh) {
            configureNodeFromMatrix(lastNode, node, parent);
        }
        else {
            var translation = node.translation || [0, 0, 0];
            var rotation = node.rotation || [0, 0, 0, 1];
            var scale = node.scale || [1, 1, 1];
            configureNode(lastNode, babylonjs_1.Vector3.FromArray(translation), babylonjs_1.Quaternion.FromArray(rotation), babylonjs_1.Vector3.FromArray(scale));
        }
        lastNode.updateCache(true);
        node.babylonNode = lastNode;
    }
    return lastNode;
};
/**
* Traverses nodes and creates them
*/
var traverseNodes = function (gltfRuntime, id, parent, meshIncluded) {
    if (meshIncluded === void 0) { meshIncluded = false; }
    var node = gltfRuntime.nodes[id];
    var newNode = null;
    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {
        if (gltfRuntime.importMeshesNames.indexOf(node.name || "") !== -1 || gltfRuntime.importMeshesNames.length === 0) {
            meshIncluded = true;
        }
        else {
            meshIncluded = false;
        }
    }
    else {
        meshIncluded = true;
    }
    if (!node.jointName && meshIncluded) {
        newNode = importNode(gltfRuntime, node, id, parent);
        if (newNode !== null) {
            newNode.id = id;
            newNode.parent = parent;
        }
    }
    if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
            traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);
        }
    }
};
/**
* do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)
*/
var postLoad = function (gltfRuntime) {
    // Nodes
    var currentScene = gltfRuntime.currentScene;
    if (currentScene) {
        for (var i = 0; i < currentScene.nodes.length; i++) {
            traverseNodes(gltfRuntime, currentScene.nodes[i], null);
        }
    }
    else {
        for (var thing in gltfRuntime.scenes) {
            currentScene = gltfRuntime.scenes[thing];
            for (var i = 0; i < currentScene.nodes.length; i++) {
                traverseNodes(gltfRuntime, currentScene.nodes[i], null);
            }
        }
    }
    // Set animations
    loadAnimations(gltfRuntime);
    for (var i = 0; i < gltfRuntime.scene.skeletons.length; i++) {
        var skeleton = gltfRuntime.scene.skeletons[i];
        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);
    }
};
/**
* onBind shaderrs callback to set uniforms and matrices
*/
var onBindShaderMaterial = function (mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess) {
    var materialValues = material.values || technique.parameters;
    for (var unif in unTreatedUniforms) {
        var uniform = unTreatedUniforms[unif];
        var type = uniform.type;
        if (type === glTFLoaderInterfaces_1.EParameterType.FLOAT_MAT2 || type === glTFLoaderInterfaces_1.EParameterType.FLOAT_MAT3 || type === glTFLoaderInterfaces_1.EParameterType.FLOAT_MAT4) {
            if (uniform.semantic && !uniform.source && !uniform.node) {
                glTFLoaderUtils_1.GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());
            }
            else if (uniform.semantic && (uniform.source || uniform.node)) {
                var source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || "");
                if (source === null) {
                    source = gltfRuntime.scene.getNodeByID(uniform.source || uniform.node || "");
                }
                if (source === null) {
                    continue;
                }
                glTFLoaderUtils_1.GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());
            }
        }
        else {
            var value = materialValues[technique.uniforms[unif]];
            if (!value) {
                continue;
            }
            if (type === glTFLoaderInterfaces_1.EParameterType.SAMPLER_2D) {
                var texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;
                if (texture === null || texture === undefined) {
                    continue;
                }
                shaderMaterial.getEffect().setTexture(unif, texture);
            }
            else {
                glTFLoaderUtils_1.GLTFUtils.SetUniform((shaderMaterial.getEffect()), unif, value, type);
            }
        }
    }
    onSuccess(shaderMaterial);
};
/**
* Prepare uniforms to send the only one time
* Loads the appropriate textures
*/
var prepareShaderMaterialUniforms = function (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms) {
    var materialValues = material.values || technique.parameters;
    var techniqueUniforms = technique.uniforms;
    /**
    * Prepare values here (not matrices)
    */
    for (var unif in unTreatedUniforms) {
        var uniform = unTreatedUniforms[unif];
        var type = uniform.type;
        var value = materialValues[techniqueUniforms[unif]];
        if (value === undefined) {
            // In case the value is the same for all materials
            value = uniform.value;
        }
        if (!value) {
            continue;
        }
        var onLoadTexture = function (uniformName) {
            return function (texture) {
                if (uniform.value && uniformName) {
                    // Static uniform
                    shaderMaterial.setTexture(uniformName, texture);
                    delete unTreatedUniforms[uniformName];
                }
            };
        };
        // Texture (sampler2D)
        if (type === glTFLoaderInterfaces_1.EParameterType.SAMPLER_2D) {
            glTFLoaderExtension_1.GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), function () { return onLoadTexture(null); });
        }
        // Others
        else {
            if (uniform.value && glTFLoaderUtils_1.GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {
                // Static uniform
                delete unTreatedUniforms[unif];
            }
        }
    }
};
/**
* Shader compilation failed
*/
var onShaderCompileError = function (program, shaderMaterial, onError) {
    return function (effect, error) {
        shaderMaterial.dispose(true);
        onError("Cannot compile program named " + program.name + ". Error: " + error + ". Default material will be applied");
    };
};
/**
* Shader compilation success
*/
var onShaderCompileSuccess = function (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess) {
    return function (_) {
        prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);
        shaderMaterial.onBind = function (mesh) {
            onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);
        };
    };
};
/**
* Returns the appropriate uniform if already handled by babylon
*/
var parseShaderUniforms = function (tokenizer, technique, unTreatedUniforms) {
    for (var unif in technique.uniforms) {
        var uniform = technique.uniforms[unif];
        var uniformParameter = technique.parameters[uniform];
        if (tokenizer.currentIdentifier === unif) {
            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {
                var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
                if (transformIndex !== -1) {
                    delete unTreatedUniforms[unif];
                    return babylonTransforms[transformIndex];
                }
            }
        }
    }
    return tokenizer.currentIdentifier;
};
/**
* All shaders loaded. Create materials one by one
*/
var importMaterials = function (gltfRuntime) {
    // Create materials
    for (var mat in gltfRuntime.materials) {
        glTFLoaderExtension_1.GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, function (material) { }, function () { });
    }
};
/**
* Implementation of the base glTF spec
* @hidden
*/
var GLTFLoaderBase = /** @class */ (function () {
    function GLTFLoaderBase() {
    }
    GLTFLoaderBase.CreateRuntime = function (parsedData, scene, rootUrl) {
        var gltfRuntime = {
            extensions: {},
            accessors: {},
            buffers: {},
            bufferViews: {},
            meshes: {},
            lights: {},
            cameras: {},
            nodes: {},
            images: {},
            textures: {},
            shaders: {},
            programs: {},
            samplers: {},
            techniques: {},
            materials: {},
            animations: {},
            skins: {},
            extensionsUsed: [],
            scenes: {},
            buffersCount: 0,
            shaderscount: 0,
            scene: scene,
            rootUrl: rootUrl,
            loadedBufferCount: 0,
            loadedBufferViews: {},
            loadedShaderCount: 0,
            importOnlyMeshes: false,
            dummyNodes: []
        };
        // Parse
        if (parsedData.extensions) {
            parseObject(parsedData.extensions, "extensions", gltfRuntime);
        }
        if (parsedData.extensionsUsed) {
            parseObject(parsedData.extensionsUsed, "extensionsUsed", gltfRuntime);
        }
        if (parsedData.buffers) {
            parseBuffers(parsedData.buffers, gltfRuntime);
        }
        if (parsedData.bufferViews) {
            parseObject(parsedData.bufferViews, "bufferViews", gltfRuntime);
        }
        if (parsedData.accessors) {
            parseObject(parsedData.accessors, "accessors", gltfRuntime);
        }
        if (parsedData.meshes) {
            parseObject(parsedData.meshes, "meshes", gltfRuntime);
        }
        if (parsedData.lights) {
            parseObject(parsedData.lights, "lights", gltfRuntime);
        }
        if (parsedData.cameras) {
            parseObject(parsedData.cameras, "cameras", gltfRuntime);
        }
        if (parsedData.nodes) {
            parseObject(parsedData.nodes, "nodes", gltfRuntime);
        }
        if (parsedData.images) {
            parseObject(parsedData.images, "images", gltfRuntime);
        }
        if (parsedData.textures) {
            parseObject(parsedData.textures, "textures", gltfRuntime);
        }
        if (parsedData.shaders) {
            parseShaders(parsedData.shaders, gltfRuntime);
        }
        if (parsedData.programs) {
            parseObject(parsedData.programs, "programs", gltfRuntime);
        }
        if (parsedData.samplers) {
            parseObject(parsedData.samplers, "samplers", gltfRuntime);
        }
        if (parsedData.techniques) {
            parseObject(parsedData.techniques, "techniques", gltfRuntime);
        }
        if (parsedData.materials) {
            parseObject(parsedData.materials, "materials", gltfRuntime);
        }
        if (parsedData.animations) {
            parseObject(parsedData.animations, "animations", gltfRuntime);
        }
        if (parsedData.skins) {
            parseObject(parsedData.skins, "skins", gltfRuntime);
        }
        if (parsedData.scenes) {
            gltfRuntime.scenes = parsedData.scenes;
        }
        if (parsedData.scene && parsedData.scenes) {
            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];
        }
        return gltfRuntime;
    };
    GLTFLoaderBase.LoadBufferAsync = function (gltfRuntime, id, onSuccess, onError, onProgress) {
        var buffer = gltfRuntime.buffers[id];
        if (babylonjs_1.Tools.IsBase64(buffer.uri)) {
            setTimeout(function () { return onSuccess(new Uint8Array(babylonjs_1.Tools.DecodeBase64(buffer.uri))); });
        }
        else {
            babylonjs_1.Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, function (data) { return onSuccess(new Uint8Array(data)); }, onProgress, undefined, true, function (request) {
                if (request) {
                    onError(request.status + " " + request.statusText);
                }
            });
        }
    };
    GLTFLoaderBase.LoadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {
        var texture = gltfRuntime.textures[id];
        if (!texture || !texture.source) {
            onError("");
            return;
        }
        if (texture.babylonTexture) {
            onSuccess(null);
            return;
        }
        var source = gltfRuntime.images[texture.source];
        if (babylonjs_1.Tools.IsBase64(source.uri)) {
            setTimeout(function () { return onSuccess(new Uint8Array(babylonjs_1.Tools.DecodeBase64(source.uri))); });
        }
        else {
            babylonjs_1.Tools.LoadFile(gltfRuntime.rootUrl + source.uri, function (data) { return onSuccess(new Uint8Array(data)); }, undefined, undefined, true, function (request) {
                if (request) {
                    onError(request.status + " " + request.statusText);
                }
            });
        }
    };
    GLTFLoaderBase.CreateTextureAsync = function (gltfRuntime, id, buffer, onSuccess, onError) {
        var texture = gltfRuntime.textures[id];
        if (texture.babylonTexture) {
            onSuccess(texture.babylonTexture);
            return;
        }
        var sampler = gltfRuntime.samplers[texture.sampler];
        var createMipMaps = (sampler.minFilter === glTFLoaderInterfaces_1.ETextureFilterType.NEAREST_MIPMAP_NEAREST) ||
            (sampler.minFilter === glTFLoaderInterfaces_1.ETextureFilterType.NEAREST_MIPMAP_LINEAR) ||
            (sampler.minFilter === glTFLoaderInterfaces_1.ETextureFilterType.LINEAR_MIPMAP_NEAREST) ||
            (sampler.minFilter === glTFLoaderInterfaces_1.ETextureFilterType.LINEAR_MIPMAP_LINEAR);
        var samplingMode = babylonjs_1.Texture.BILINEAR_SAMPLINGMODE;
        var blob = buffer == null ? new Blob() : new Blob([buffer]);
        var blobURL = URL.createObjectURL(blob);
        var revokeBlobURL = function () { return URL.revokeObjectURL(blobURL); };
        var newTexture = new babylonjs_1.Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);
        if (sampler.wrapS !== undefined) {
            newTexture.wrapU = glTFLoaderUtils_1.GLTFUtils.GetWrapMode(sampler.wrapS);
        }
        if (sampler.wrapT !== undefined) {
            newTexture.wrapV = glTFLoaderUtils_1.GLTFUtils.GetWrapMode(sampler.wrapT);
        }
        newTexture.name = id;
        texture.babylonTexture = newTexture;
        onSuccess(newTexture);
    };
    GLTFLoaderBase.LoadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {
        var shader = gltfRuntime.shaders[id];
        if (babylonjs_1.Tools.IsBase64(shader.uri)) {
            var shaderString = atob(shader.uri.split(",")[1]);
            if (onSuccess) {
                onSuccess(shaderString);
            }
        }
        else {
            babylonjs_1.Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, function (request) {
                if (request && onError) {
                    onError(request.status + " " + request.statusText);
                }
            });
        }
    };
    GLTFLoaderBase.LoadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {
        var material = gltfRuntime.materials[id];
        if (!material.technique) {
            if (onError) {
                onError("No technique found.");
            }
            return;
        }
        var technique = gltfRuntime.techniques[material.technique];
        if (!technique) {
            var defaultMaterial = new babylonjs_1.StandardMaterial(id, gltfRuntime.scene);
            defaultMaterial.diffuseColor = new babylonjs_1.Color3(0.5, 0.5, 0.5);
            defaultMaterial.sideOrientation = babylonjs_1.Material.CounterClockWiseSideOrientation;
            onSuccess(defaultMaterial);
            return;
        }
        var program = gltfRuntime.programs[technique.program];
        var states = technique.states;
        var vertexShader = babylonjs_1.Effect.ShadersStore[program.vertexShader + "VertexShader"];
        var pixelShader = babylonjs_1.Effect.ShadersStore[program.fragmentShader + "PixelShader"];
        var newVertexShader = "";
        var newPixelShader = "";
        var vertexTokenizer = new Tokenizer(vertexShader);
        var pixelTokenizer = new Tokenizer(pixelShader);
        var unTreatedUniforms = {};
        var uniforms = [];
        var attributes = [];
        var samplers = [];
        // Fill uniform, sampler2D and attributes
        for (var unif in technique.uniforms) {
            var uniform = technique.uniforms[unif];
            var uniformParameter = technique.parameters[uniform];
            unTreatedUniforms[unif] = uniformParameter;
            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {
                var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
                if (transformIndex !== -1) {
                    uniforms.push(babylonTransforms[transformIndex]);
                    delete unTreatedUniforms[unif];
                }
                else {
                    uniforms.push(unif);
                }
            }
            else if (uniformParameter.type === glTFLoaderInterfaces_1.EParameterType.SAMPLER_2D) {
                samplers.push(unif);
            }
            else {
                uniforms.push(unif);
            }
        }
        for (var attr in technique.attributes) {
            var attribute = technique.attributes[attr];
            var attributeParameter = technique.parameters[attribute];
            if (attributeParameter.semantic) {
                var name_1 = getAttribute(attributeParameter);
                if (name_1) {
                    attributes.push(name_1);
                }
            }
        }
        // Configure vertex shader
        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {
            var tokenType = vertexTokenizer.currentToken;
            if (tokenType !== ETokenType.IDENTIFIER) {
                newVertexShader += vertexTokenizer.currentString;
                continue;
            }
            var foundAttribute = false;
            for (var attr in technique.attributes) {
                var attribute = technique.attributes[attr];
                var attributeParameter = technique.parameters[attribute];
                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {
                    newVertexShader += getAttribute(attributeParameter);
                    foundAttribute = true;
                    break;
                }
            }
            if (foundAttribute) {
                continue;
            }
            newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);
        }
        // Configure pixel shader
        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {
            var tokenType = pixelTokenizer.currentToken;
            if (tokenType !== ETokenType.IDENTIFIER) {
                newPixelShader += pixelTokenizer.currentString;
                continue;
            }
            newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);
        }
        // Create shader material
        var shaderPath = {
            vertex: program.vertexShader + id,
            fragment: program.fragmentShader + id
        };
        var options = {
            attributes: attributes,
            uniforms: uniforms,
            samplers: samplers,
            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1
        };
        babylonjs_1.Effect.ShadersStore[program.vertexShader + id + "VertexShader"] = newVertexShader;
        babylonjs_1.Effect.ShadersStore[program.fragmentShader + id + "PixelShader"] = newPixelShader;
        var shaderMaterial = new babylonjs_1.ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);
        shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);
        shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);
        shaderMaterial.sideOrientation = babylonjs_1.Material.CounterClockWiseSideOrientation;
        if (states && states.functions) {
            var functions = states.functions;
            if (functions.cullFace && functions.cullFace[0] !== glTFLoaderInterfaces_1.ECullingType.BACK) {
                shaderMaterial.backFaceCulling = false;
            }
            var blendFunc = functions.blendFuncSeparate;
            if (blendFunc) {
                if (blendFunc[0] === glTFLoaderInterfaces_1.EBlendingFunction.SRC_ALPHA && blendFunc[1] === glTFLoaderInterfaces_1.EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === glTFLoaderInterfaces_1.EBlendingFunction.ONE && blendFunc[3] === glTFLoaderInterfaces_1.EBlendingFunction.ONE) {
                    shaderMaterial.alphaMode = babylonjs_1.Engine.ALPHA_COMBINE;
                }
                else if (blendFunc[0] === glTFLoaderInterfaces_1.EBlendingFunction.ONE && blendFunc[1] === glTFLoaderInterfaces_1.EBlendingFunction.ONE && blendFunc[2] === glTFLoaderInterfaces_1.EBlendingFunction.ZERO && blendFunc[3] === glTFLoaderInterfaces_1.EBlendingFunction.ONE) {
                    shaderMaterial.alphaMode = babylonjs_1.Engine.ALPHA_ONEONE;
                }
                else if (blendFunc[0] === glTFLoaderInterfaces_1.EBlendingFunction.SRC_ALPHA && blendFunc[1] === glTFLoaderInterfaces_1.EBlendingFunction.ONE && blendFunc[2] === glTFLoaderInterfaces_1.EBlendingFunction.ZERO && blendFunc[3] === glTFLoaderInterfaces_1.EBlendingFunction.ONE) {
                    shaderMaterial.alphaMode = babylonjs_1.Engine.ALPHA_ADD;
                }
                else if (blendFunc[0] === glTFLoaderInterfaces_1.EBlendingFunction.ZERO && blendFunc[1] === glTFLoaderInterfaces_1.EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === glTFLoaderInterfaces_1.EBlendingFunction.ONE && blendFunc[3] === glTFLoaderInterfaces_1.EBlendingFunction.ONE) {
                    shaderMaterial.alphaMode = babylonjs_1.Engine.ALPHA_SUBTRACT;
                }
                else if (blendFunc[0] === glTFLoaderInterfaces_1.EBlendingFunction.DST_COLOR && blendFunc[1] === glTFLoaderInterfaces_1.EBlendingFunction.ZERO && blendFunc[2] === glTFLoaderInterfaces_1.EBlendingFunction.ONE && blendFunc[3] === glTFLoaderInterfaces_1.EBlendingFunction.ONE) {
                    shaderMaterial.alphaMode = babylonjs_1.Engine.ALPHA_MULTIPLY;
                }
                else if (blendFunc[0] === glTFLoaderInterfaces_1.EBlendingFunction.SRC_ALPHA && blendFunc[1] === glTFLoaderInterfaces_1.EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === glTFLoaderInterfaces_1.EBlendingFunction.ONE && blendFunc[3] === glTFLoaderInterfaces_1.EBlendingFunction.ONE) {
                    shaderMaterial.alphaMode = babylonjs_1.Engine.ALPHA_MAXIMIZED;
                }
            }
        }
    };
    return GLTFLoaderBase;
}());
exports.GLTFLoaderBase = GLTFLoaderBase;
/**
* glTF V1 Loader
* @hidden
*/
var GLTF1Loader = /** @class */ (function () {
    function GLTF1Loader() {
        this.state = null;
    }
    GLTF1Loader.RegisterExtension = function (extension) {
        if (GLTF1Loader.Extensions[extension.name]) {
            babylonjs_1.Tools.Error("Tool with the same name \"" + extension.name + "\" already exists");
            return;
        }
        GLTF1Loader.Extensions[extension.name] = extension;
    };
    GLTF1Loader.prototype.dispose = function () {
        // do nothing
    };
    GLTF1Loader.prototype._importMeshAsync = function (meshesNames, scene, data, rootUrl, onSuccess, onProgress, onError) {
        var _this = this;
        scene.useRightHandedSystem = true;
        glTFLoaderExtension_1.GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function (gltfRuntime) {
            gltfRuntime.importOnlyMeshes = true;
            if (meshesNames === "") {
                gltfRuntime.importMeshesNames = [];
            }
            else if (typeof meshesNames === "string") {
                gltfRuntime.importMeshesNames = [meshesNames];
            }
            else if (meshesNames && !(meshesNames instanceof Array)) {
                gltfRuntime.importMeshesNames = [meshesNames];
            }
            else {
                gltfRuntime.importMeshesNames = [];
                babylonjs_1.Tools.Warn("Argument meshesNames must be of type string or string[]");
            }
            // Create nodes
            _this._createNodes(gltfRuntime);
            var meshes = new Array();
            var skeletons = new Array();
            // Fill arrays of meshes and skeletons
            for (var nde in gltfRuntime.nodes) {
                var node = gltfRuntime.nodes[nde];
                if (node.babylonNode instanceof babylonjs_1.AbstractMesh) {
                    meshes.push(node.babylonNode);
                }
            }
            for (var skl in gltfRuntime.skins) {
                var skin = gltfRuntime.skins[skl];
                if (skin.babylonSkeleton instanceof babylonjs_1.Skeleton) {
                    skeletons.push(skin.babylonSkeleton);
                }
            }
            // Load buffers, shaders, materials, etc.
            _this._loadBuffersAsync(gltfRuntime, function () {
                _this._loadShadersAsync(gltfRuntime, function () {
                    importMaterials(gltfRuntime);
                    postLoad(gltfRuntime);
                    if (!glTFFileLoader_1.GLTFFileLoader.IncrementalLoading && onSuccess) {
                        onSuccess(meshes, skeletons);
                    }
                });
            }, onProgress);
            if (glTFFileLoader_1.GLTFFileLoader.IncrementalLoading && onSuccess) {
                onSuccess(meshes, skeletons);
            }
        }, onError);
        return true;
    };
    /**
    * Imports one or more meshes from a loaded gltf file and adds them to the scene
    * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
    * @param scene the scene the meshes should be added to
    * @param data gltf data containing information of the meshes in a loaded file
    * @param rootUrl root url to load from
    * @param onProgress event that fires when loading progress has occured
    * @returns a promise containg the loaded meshes, particles, skeletons and animations
    */
    GLTF1Loader.prototype.importMeshAsync = function (meshesNames, scene, data, rootUrl, onProgress) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._importMeshAsync(meshesNames, scene, data, rootUrl, function (meshes, skeletons) {
                resolve({
                    meshes: meshes,
                    particleSystems: [],
                    skeletons: skeletons,
                    animationGroups: []
                });
            }, onProgress, function (message) {
                reject(new Error(message));
            });
        });
    };
    GLTF1Loader.prototype._loadAsync = function (scene, data, rootUrl, onSuccess, onProgress, onError) {
        var _this = this;
        scene.useRightHandedSystem = true;
        glTFLoaderExtension_1.GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function (gltfRuntime) {
            // Load runtime extensios
            glTFLoaderExtension_1.GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, function () {
                // Create nodes
                _this._createNodes(gltfRuntime);
                // Load buffers, shaders, materials, etc.
                _this._loadBuffersAsync(gltfRuntime, function () {
                    _this._loadShadersAsync(gltfRuntime, function () {
                        importMaterials(gltfRuntime);
                        postLoad(gltfRuntime);
                        if (!glTFFileLoader_1.GLTFFileLoader.IncrementalLoading) {
                            onSuccess();
                        }
                    });
                });
                if (glTFFileLoader_1.GLTFFileLoader.IncrementalLoading) {
                    onSuccess();
                }
            }, onError);
        }, onError);
    };
    /**
    * Imports all objects from a loaded gltf file and adds them to the scene
    * @param scene the scene the objects should be added to
    * @param data gltf data containing information of the meshes in a loaded file
    * @param rootUrl root url to load from
    * @param onProgress event that fires when loading progress has occured
    * @returns a promise which completes when objects have been loaded to the scene
    */
    GLTF1Loader.prototype.loadAsync = function (scene, data, rootUrl, onProgress) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._loadAsync(scene, data, rootUrl, function () {
                resolve();
            }, onProgress, function (message) {
                reject(new Error(message));
            });
        });
    };
    GLTF1Loader.prototype._loadShadersAsync = function (gltfRuntime, onload) {
        var hasShaders = false;
        var processShader = function (sha, shader) {
            glTFLoaderExtension_1.GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, function (shaderString) {
                if (shaderString instanceof ArrayBuffer) {
                    return;
                }
                gltfRuntime.loadedShaderCount++;
                if (shaderString) {
                    babylonjs_1.Effect.ShadersStore[sha + (shader.type === glTFLoaderInterfaces_1.EShaderType.VERTEX ? "VertexShader" : "PixelShader")] = shaderString;
                }
                if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {
                    onload();
                }
            }, function () {
                babylonjs_1.Tools.Error("Error when loading shader program named " + sha + " located at " + shader.uri);
            });
        };
        for (var sha in gltfRuntime.shaders) {
            hasShaders = true;
            var shader = gltfRuntime.shaders[sha];
            if (shader) {
                processShader.bind(this, sha, shader)();
            }
            else {
                babylonjs_1.Tools.Error("No shader named: " + sha);
            }
        }
        if (!hasShaders) {
            onload();
        }
    };
    GLTF1Loader.prototype._loadBuffersAsync = function (gltfRuntime, onLoad, onProgress) {
        var hasBuffers = false;
        var processBuffer = function (buf, buffer) {
            glTFLoaderExtension_1.GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, function (bufferView) {
                gltfRuntime.loadedBufferCount++;
                if (bufferView) {
                    if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {
                        babylonjs_1.Tools.Error("Buffer named " + buf + " is length " + bufferView.byteLength + ". Expected: " + buffer.byteLength); // Improve error message
                    }
                    gltfRuntime.loadedBufferViews[buf] = bufferView;
                }
                if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {
                    onLoad();
                }
            }, function () {
                babylonjs_1.Tools.Error("Error when loading buffer named " + buf + " located at " + buffer.uri);
            });
        };
        for (var buf in gltfRuntime.buffers) {
            hasBuffers = true;
            var buffer = gltfRuntime.buffers[buf];
            if (buffer) {
                processBuffer.bind(this, buf, buffer)();
            }
            else {
                babylonjs_1.Tools.Error("No buffer named: " + buf);
            }
        }
        if (!hasBuffers) {
            onLoad();
        }
    };
    GLTF1Loader.prototype._createNodes = function (gltfRuntime) {
        var currentScene = gltfRuntime.currentScene;
        if (currentScene) {
            // Only one scene even if multiple scenes are defined
            for (var i = 0; i < currentScene.nodes.length; i++) {
                traverseNodes(gltfRuntime, currentScene.nodes[i], null);
            }
        }
        else {
            // Load all scenes
            for (var thing in gltfRuntime.scenes) {
                currentScene = gltfRuntime.scenes[thing];
                for (var i = 0; i < currentScene.nodes.length; i++) {
                    traverseNodes(gltfRuntime, currentScene.nodes[i], null);
                }
            }
        }
    };
    GLTF1Loader.Extensions = {};
    return GLTF1Loader;
}());
exports.GLTF1Loader = GLTF1Loader;
glTFFileLoader_1.GLTFFileLoader._CreateGLTF1Loader = function () { return new GLTF1Loader(); };


/***/ }),

/***/ "./src/glTF/1.0/glTFBinaryExtension.ts":
/*!*********************************************!*\
  !*** ./src/glTF/1.0/glTFBinaryExtension.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var glTFLoaderExtension_1 = __webpack_require__(/*! ./glTFLoaderExtension */ "./src/glTF/1.0/glTFLoaderExtension.ts");
var glTFLoaderUtils_1 = __webpack_require__(/*! ./glTFLoaderUtils */ "./src/glTF/1.0/glTFLoaderUtils.ts");
var glTFLoaderInterfaces_1 = __webpack_require__(/*! ./glTFLoaderInterfaces */ "./src/glTF/1.0/glTFLoaderInterfaces.ts");
var GLTF1Loader_1 = __webpack_require__(/*! ./GLTF1Loader */ "./src/glTF/1.0/GLTF1Loader.ts");
var BinaryExtensionBufferName = "binary_glTF";
/** @hidden */
var GLTFBinaryExtension = /** @class */ (function (_super) {
    __extends(GLTFBinaryExtension, _super);
    function GLTFBinaryExtension() {
        return _super.call(this, "KHR_binary_glTF") || this;
    }
    GLTFBinaryExtension.prototype.loadRuntimeAsync = function (scene, data, rootUrl, onSuccess, onError) {
        var extensionsUsed = data.json.extensionsUsed;
        if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {
            return false;
        }
        this._bin = data.bin;
        onSuccess(GLTF1Loader_1.GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
        return true;
    };
    GLTFBinaryExtension.prototype.loadBufferAsync = function (gltfRuntime, id, onSuccess, onError) {
        if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {
            return false;
        }
        if (id !== BinaryExtensionBufferName) {
            return false;
        }
        onSuccess(this._bin);
        return true;
    };
    GLTFBinaryExtension.prototype.loadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {
        var texture = gltfRuntime.textures[id];
        var source = gltfRuntime.images[texture.source];
        if (!source.extensions || !(this.name in source.extensions)) {
            return false;
        }
        var sourceExt = source.extensions[this.name];
        var bufferView = gltfRuntime.bufferViews[sourceExt.bufferView];
        var buffer = glTFLoaderUtils_1.GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, glTFLoaderInterfaces_1.EComponentType.UNSIGNED_BYTE);
        onSuccess(buffer);
        return true;
    };
    GLTFBinaryExtension.prototype.loadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {
        var shader = gltfRuntime.shaders[id];
        if (!shader.extensions || !(this.name in shader.extensions)) {
            return false;
        }
        var binaryExtensionShader = shader.extensions[this.name];
        var bufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];
        var shaderBytes = glTFLoaderUtils_1.GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, glTFLoaderInterfaces_1.EComponentType.UNSIGNED_BYTE);
        setTimeout(function () {
            var shaderString = glTFLoaderUtils_1.GLTFUtils.DecodeBufferToText(shaderBytes);
            onSuccess(shaderString);
        });
        return true;
    };
    return GLTFBinaryExtension;
}(glTFLoaderExtension_1.GLTFLoaderExtension));
exports.GLTFBinaryExtension = GLTFBinaryExtension;
GLTF1Loader_1.GLTF1Loader.RegisterExtension(new GLTFBinaryExtension());


/***/ }),

/***/ "./src/glTF/1.0/glTFLoaderExtension.ts":
/*!*********************************************!*\
  !*** ./src/glTF/1.0/glTFLoaderExtension.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GLTF1Loader_1 = __webpack_require__(/*! ./GLTF1Loader */ "./src/glTF/1.0/GLTF1Loader.ts");
/** @hidden */
var GLTFLoaderExtension = /** @class */ (function () {
    function GLTFLoaderExtension(name) {
        this._name = name;
    }
    Object.defineProperty(GLTFLoaderExtension.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Defines an override for loading the runtime
    * Return true to stop further extensions from loading the runtime
    */
    GLTFLoaderExtension.prototype.loadRuntimeAsync = function (scene, data, rootUrl, onSuccess, onError) {
        return false;
    };
    /**
     * Defines an onverride for creating gltf runtime
     * Return true to stop further extensions from creating the runtime
     */
    GLTFLoaderExtension.prototype.loadRuntimeExtensionsAsync = function (gltfRuntime, onSuccess, onError) {
        return false;
    };
    /**
    * Defines an override for loading buffers
    * Return true to stop further extensions from loading this buffer
    */
    GLTFLoaderExtension.prototype.loadBufferAsync = function (gltfRuntime, id, onSuccess, onError, onProgress) {
        return false;
    };
    /**
    * Defines an override for loading texture buffers
    * Return true to stop further extensions from loading this texture data
    */
    GLTFLoaderExtension.prototype.loadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {
        return false;
    };
    /**
    * Defines an override for creating textures
    * Return true to stop further extensions from loading this texture
    */
    GLTFLoaderExtension.prototype.createTextureAsync = function (gltfRuntime, id, buffer, onSuccess, onError) {
        return false;
    };
    /**
    * Defines an override for loading shader strings
    * Return true to stop further extensions from loading this shader data
    */
    GLTFLoaderExtension.prototype.loadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {
        return false;
    };
    /**
    * Defines an override for loading materials
    * Return true to stop further extensions from loading this material
    */
    GLTFLoaderExtension.prototype.loadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {
        return false;
    };
    // ---------
    // Utilities
    // ---------
    GLTFLoaderExtension.LoadRuntimeAsync = function (scene, data, rootUrl, onSuccess, onError) {
        GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {
            return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);
        }, function () {
            setTimeout(function () {
                if (!onSuccess) {
                    return;
                }
                onSuccess(GLTF1Loader_1.GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
            });
        });
    };
    GLTFLoaderExtension.LoadRuntimeExtensionsAsync = function (gltfRuntime, onSuccess, onError) {
        GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {
            return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);
        }, function () {
            setTimeout(function () {
                onSuccess();
            });
        });
    };
    GLTFLoaderExtension.LoadBufferAsync = function (gltfRuntime, id, onSuccess, onError, onProgress) {
        GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {
            return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
        }, function () {
            GLTF1Loader_1.GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
        });
    };
    GLTFLoaderExtension.LoadTextureAsync = function (gltfRuntime, id, onSuccess, onError) {
        GLTFLoaderExtension.LoadTextureBufferAsync(gltfRuntime, id, function (buffer) {
            if (buffer) {
                GLTFLoaderExtension.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
            }
        }, onError);
    };
    GLTFLoaderExtension.LoadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {
        GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {
            return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
        }, function () {
            GLTF1Loader_1.GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
        });
    };
    GLTFLoaderExtension.LoadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {
        GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {
            return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);
        }, function () {
            GLTF1Loader_1.GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);
        });
    };
    GLTFLoaderExtension.LoadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {
        GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {
            return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
        }, function () {
            GLTF1Loader_1.GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
        });
    };
    GLTFLoaderExtension.CreateTextureAsync = function (gltfRuntime, id, buffer, onSuccess, onError) {
        GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {
            return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
        }, function () {
            GLTF1Loader_1.GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
        });
    };
    GLTFLoaderExtension.ApplyExtensions = function (func, defaultFunc) {
        for (var extensionName in GLTF1Loader_1.GLTF1Loader.Extensions) {
            var loaderExtension = GLTF1Loader_1.GLTF1Loader.Extensions[extensionName];
            if (func(loaderExtension)) {
                return;
            }
        }
        defaultFunc();
    };
    return GLTFLoaderExtension;
}());
exports.GLTFLoaderExtension = GLTFLoaderExtension;


/***/ }),

/***/ "./src/glTF/1.0/glTFLoaderInterfaces.ts":
/*!**********************************************!*\
  !*** ./src/glTF/1.0/glTFLoaderInterfaces.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
* Enums
* @hidden
*/
var EComponentType;
(function (EComponentType) {
    EComponentType[EComponentType["BYTE"] = 5120] = "BYTE";
    EComponentType[EComponentType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    EComponentType[EComponentType["SHORT"] = 5122] = "SHORT";
    EComponentType[EComponentType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    EComponentType[EComponentType["FLOAT"] = 5126] = "FLOAT";
})(EComponentType = exports.EComponentType || (exports.EComponentType = {}));
/** @hidden */
var EShaderType;
(function (EShaderType) {
    EShaderType[EShaderType["FRAGMENT"] = 35632] = "FRAGMENT";
    EShaderType[EShaderType["VERTEX"] = 35633] = "VERTEX";
})(EShaderType = exports.EShaderType || (exports.EShaderType = {}));
/** @hidden */
var EParameterType;
(function (EParameterType) {
    EParameterType[EParameterType["BYTE"] = 5120] = "BYTE";
    EParameterType[EParameterType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    EParameterType[EParameterType["SHORT"] = 5122] = "SHORT";
    EParameterType[EParameterType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    EParameterType[EParameterType["INT"] = 5124] = "INT";
    EParameterType[EParameterType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    EParameterType[EParameterType["FLOAT"] = 5126] = "FLOAT";
    EParameterType[EParameterType["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
    EParameterType[EParameterType["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
    EParameterType[EParameterType["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
    EParameterType[EParameterType["INT_VEC2"] = 35667] = "INT_VEC2";
    EParameterType[EParameterType["INT_VEC3"] = 35668] = "INT_VEC3";
    EParameterType[EParameterType["INT_VEC4"] = 35669] = "INT_VEC4";
    EParameterType[EParameterType["BOOL"] = 35670] = "BOOL";
    EParameterType[EParameterType["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
    EParameterType[EParameterType["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
    EParameterType[EParameterType["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
    EParameterType[EParameterType["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
    EParameterType[EParameterType["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
    EParameterType[EParameterType["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
    EParameterType[EParameterType["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
})(EParameterType = exports.EParameterType || (exports.EParameterType = {}));
/** @hidden */
var ETextureWrapMode;
(function (ETextureWrapMode) {
    ETextureWrapMode[ETextureWrapMode["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    ETextureWrapMode[ETextureWrapMode["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    ETextureWrapMode[ETextureWrapMode["REPEAT"] = 10497] = "REPEAT";
})(ETextureWrapMode = exports.ETextureWrapMode || (exports.ETextureWrapMode = {}));
/** @hidden */
var ETextureFilterType;
(function (ETextureFilterType) {
    ETextureFilterType[ETextureFilterType["NEAREST"] = 9728] = "NEAREST";
    ETextureFilterType[ETextureFilterType["LINEAR"] = 9728] = "LINEAR";
    ETextureFilterType[ETextureFilterType["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    ETextureFilterType[ETextureFilterType["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    ETextureFilterType[ETextureFilterType["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    ETextureFilterType[ETextureFilterType["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(ETextureFilterType = exports.ETextureFilterType || (exports.ETextureFilterType = {}));
/** @hidden */
var ETextureFormat;
(function (ETextureFormat) {
    ETextureFormat[ETextureFormat["ALPHA"] = 6406] = "ALPHA";
    ETextureFormat[ETextureFormat["RGB"] = 6407] = "RGB";
    ETextureFormat[ETextureFormat["RGBA"] = 6408] = "RGBA";
    ETextureFormat[ETextureFormat["LUMINANCE"] = 6409] = "LUMINANCE";
    ETextureFormat[ETextureFormat["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
})(ETextureFormat = exports.ETextureFormat || (exports.ETextureFormat = {}));
/** @hidden */
var ECullingType;
(function (ECullingType) {
    ECullingType[ECullingType["FRONT"] = 1028] = "FRONT";
    ECullingType[ECullingType["BACK"] = 1029] = "BACK";
    ECullingType[ECullingType["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
})(ECullingType = exports.ECullingType || (exports.ECullingType = {}));
/** @hidden */
var EBlendingFunction;
(function (EBlendingFunction) {
    EBlendingFunction[EBlendingFunction["ZERO"] = 0] = "ZERO";
    EBlendingFunction[EBlendingFunction["ONE"] = 1] = "ONE";
    EBlendingFunction[EBlendingFunction["SRC_COLOR"] = 768] = "SRC_COLOR";
    EBlendingFunction[EBlendingFunction["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
    EBlendingFunction[EBlendingFunction["DST_COLOR"] = 774] = "DST_COLOR";
    EBlendingFunction[EBlendingFunction["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
    EBlendingFunction[EBlendingFunction["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    EBlendingFunction[EBlendingFunction["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    EBlendingFunction[EBlendingFunction["DST_ALPHA"] = 772] = "DST_ALPHA";
    EBlendingFunction[EBlendingFunction["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
    EBlendingFunction[EBlendingFunction["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
    EBlendingFunction[EBlendingFunction["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
    EBlendingFunction[EBlendingFunction["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
    EBlendingFunction[EBlendingFunction["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
    EBlendingFunction[EBlendingFunction["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
})(EBlendingFunction = exports.EBlendingFunction || (exports.EBlendingFunction = {}));


/***/ }),

/***/ "./src/glTF/1.0/glTFLoaderUtils.ts":
/*!*****************************************!*\
  !*** ./src/glTF/1.0/glTFLoaderUtils.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var babylonjs_1 = __webpack_require__(/*! babylonjs */ "babylonjs");
var glTFLoaderInterfaces_1 = __webpack_require__(/*! ./glTFLoaderInterfaces */ "./src/glTF/1.0/glTFLoaderInterfaces.ts");
/**
* Utils functions for GLTF
* @hidden
*/
var GLTFUtils = /** @class */ (function () {
    function GLTFUtils() {
    }
    /**
     * Sets the given "parameter" matrix
     * @param scene: the Scene object
     * @param source: the source node where to pick the matrix
     * @param parameter: the GLTF technique parameter
     * @param uniformName: the name of the shader's uniform
     * @param shaderMaterial: the shader material
     */
    GLTFUtils.SetMatrix = function (scene, source, parameter, uniformName, shaderMaterial) {
        var mat = null;
        if (parameter.semantic === "MODEL") {
            mat = source.getWorldMatrix();
        }
        else if (parameter.semantic === "PROJECTION") {
            mat = scene.getProjectionMatrix();
        }
        else if (parameter.semantic === "VIEW") {
            mat = scene.getViewMatrix();
        }
        else if (parameter.semantic === "MODELVIEWINVERSETRANSPOSE") {
            mat = babylonjs_1.Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());
        }
        else if (parameter.semantic === "MODELVIEW") {
            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());
        }
        else if (parameter.semantic === "MODELVIEWPROJECTION") {
            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());
        }
        else if (parameter.semantic === "MODELINVERSE") {
            mat = source.getWorldMatrix().invert();
        }
        else if (parameter.semantic === "VIEWINVERSE") {
            mat = scene.getViewMatrix().invert();
        }
        else if (parameter.semantic === "PROJECTIONINVERSE") {
            mat = scene.getProjectionMatrix().invert();
        }
        else if (parameter.semantic === "MODELVIEWINVERSE") {
            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();
        }
        else if (parameter.semantic === "MODELVIEWPROJECTIONINVERSE") {
            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();
        }
        else if (parameter.semantic === "MODELINVERSETRANSPOSE") {
            mat = babylonjs_1.Matrix.Transpose(source.getWorldMatrix().invert());
        }
        else {
            debugger;
        }
        if (mat) {
            switch (parameter.type) {
                case glTFLoaderInterfaces_1.EParameterType.FLOAT_MAT2:
                    shaderMaterial.setMatrix2x2(uniformName, babylonjs_1.Matrix.GetAsMatrix2x2(mat));
                    break;
                case glTFLoaderInterfaces_1.EParameterType.FLOAT_MAT3:
                    shaderMaterial.setMatrix3x3(uniformName, babylonjs_1.Matrix.GetAsMatrix3x3(mat));
                    break;
                case glTFLoaderInterfaces_1.EParameterType.FLOAT_MAT4:
                    shaderMaterial.setMatrix(uniformName, mat);
                    break;
                default: break;
            }
        }
    };
    /**
     * Sets the given "parameter" matrix
     * @param shaderMaterial: the shader material
     * @param uniform: the name of the shader's uniform
     * @param value: the value of the uniform
     * @param type: the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)
     */
    GLTFUtils.SetUniform = function (shaderMaterial, uniform, value, type) {
        switch (type) {
            case glTFLoaderInterfaces_1.EParameterType.FLOAT:
                shaderMaterial.setFloat(uniform, value);
                return true;
            case glTFLoaderInterfaces_1.EParameterType.FLOAT_VEC2:
                shaderMaterial.setVector2(uniform, babylonjs_1.Vector2.FromArray(value));
                return true;
            case glTFLoaderInterfaces_1.EParameterType.FLOAT_VEC3:
                shaderMaterial.setVector3(uniform, babylonjs_1.Vector3.FromArray(value));
                return true;
            case glTFLoaderInterfaces_1.EParameterType.FLOAT_VEC4:
                shaderMaterial.setVector4(uniform, babylonjs_1.Vector4.FromArray(value));
                return true;
            default: return false;
        }
    };
    /**
    * Returns the wrap mode of the texture
    * @param mode: the mode value
    */
    GLTFUtils.GetWrapMode = function (mode) {
        switch (mode) {
            case glTFLoaderInterfaces_1.ETextureWrapMode.CLAMP_TO_EDGE: return babylonjs_1.Texture.CLAMP_ADDRESSMODE;
            case glTFLoaderInterfaces_1.ETextureWrapMode.MIRRORED_REPEAT: return babylonjs_1.Texture.MIRROR_ADDRESSMODE;
            case glTFLoaderInterfaces_1.ETextureWrapMode.REPEAT: return babylonjs_1.Texture.WRAP_ADDRESSMODE;
            default: return babylonjs_1.Texture.WRAP_ADDRESSMODE;
        }
    };
    /**
     * Returns the byte stride giving an accessor
     * @param accessor: the GLTF accessor objet
     */
    GLTFUtils.GetByteStrideFromType = function (accessor) {
        // Needs this function since "byteStride" isn't requiered in glTF format
        var type = accessor.type;
        switch (type) {
            case "VEC2": return 2;
            case "VEC3": return 3;
            case "VEC4": return 4;
            case "MAT2": return 4;
            case "MAT3": return 9;
            case "MAT4": return 16;
            default: return 1;
        }
    };
    /**
     * Returns the texture filter mode giving a mode value
     * @param mode: the filter mode value
     */
    GLTFUtils.GetTextureFilterMode = function (mode) {
        switch (mode) {
            case glTFLoaderInterfaces_1.ETextureFilterType.LINEAR:
            case glTFLoaderInterfaces_1.ETextureFilterType.LINEAR_MIPMAP_NEAREST:
            case glTFLoaderInterfaces_1.ETextureFilterType.LINEAR_MIPMAP_LINEAR: return babylonjs_1.Texture.TRILINEAR_SAMPLINGMODE;
            case glTFLoaderInterfaces_1.ETextureFilterType.NEAREST:
            case glTFLoaderInterfaces_1.ETextureFilterType.NEAREST_MIPMAP_NEAREST: return babylonjs_1.Texture.NEAREST_SAMPLINGMODE;
            default: return babylonjs_1.Texture.BILINEAR_SAMPLINGMODE;
        }
    };
    GLTFUtils.GetBufferFromBufferView = function (gltfRuntime, bufferView, byteOffset, byteLength, componentType) {
        var byteOffset = bufferView.byteOffset + byteOffset;
        var loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];
        if (byteOffset + byteLength > loadedBufferView.byteLength) {
            throw new Error("Buffer access is out of range");
        }
        var buffer = loadedBufferView.buffer;
        byteOffset += loadedBufferView.byteOffset;
        switch (componentType) {
            case glTFLoaderInterfaces_1.EComponentType.BYTE: return new Int8Array(buffer, byteOffset, byteLength);
            case glTFLoaderInterfaces_1.EComponentType.UNSIGNED_BYTE: return new Uint8Array(buffer, byteOffset, byteLength);
            case glTFLoaderInterfaces_1.EComponentType.SHORT: return new Int16Array(buffer, byteOffset, byteLength);
            case glTFLoaderInterfaces_1.EComponentType.UNSIGNED_SHORT: return new Uint16Array(buffer, byteOffset, byteLength);
            default: return new Float32Array(buffer, byteOffset, byteLength);
        }
    };
    /**
     * Returns a buffer from its accessor
     * @param gltfRuntime: the GLTF runtime
     * @param accessor: the GLTF accessor
     */
    GLTFUtils.GetBufferFromAccessor = function (gltfRuntime, accessor) {
        var bufferView = gltfRuntime.bufferViews[accessor.bufferView];
        var byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);
        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);
    };
    /**
     * Decodes a buffer view into a string
     * @param view: the buffer view
     */
    GLTFUtils.DecodeBufferToText = function (view) {
        var result = "";
        var length = view.byteLength;
        for (var i = 0; i < length; ++i) {
            result += String.fromCharCode(view[i]);
        }
        return result;
    };
    /**
     * Returns the default material of gltf. Related to
     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material
     * @param scene: the Babylon.js scene
     */
    GLTFUtils.GetDefaultMaterial = function (scene) {
        if (!GLTFUtils._DefaultMaterial) {
            babylonjs_1.Effect.ShadersStore["GLTFDefaultMaterialVertexShader"] = [
                "precision highp float;",
                "",
                "uniform mat4 worldView;",
                "uniform mat4 projection;",
                "",
                "attribute vec3 position;",
                "",
                "void main(void)",
                "{",
                "    gl_Position = projection * worldView * vec4(position, 1.0);",
                "}"
            ].join("\n");
            babylonjs_1.Effect.ShadersStore["GLTFDefaultMaterialPixelShader"] = [
                "precision highp float;",
                "",
                "uniform vec4 u_emission;",
                "",
                "void main(void)",
                "{",
                "    gl_FragColor = u_emission;",
                "}"
            ].join("\n");
            var shaderPath = {
                vertex: "GLTFDefaultMaterial",
                fragment: "GLTFDefaultMaterial"
            };
            var options = {
                attributes: ["position"],
                uniforms: ["worldView", "projection", "u_emission"],
                samplers: new Array(),
                needAlphaBlending: false
            };
            GLTFUtils._DefaultMaterial = new babylonjs_1.ShaderMaterial("GLTFDefaultMaterial", scene, shaderPath, options);
            GLTFUtils._DefaultMaterial.setColor4("u_emission", new babylonjs_1.Color4(0.5, 0.5, 0.5, 1.0));
        }
        return GLTFUtils._DefaultMaterial;
    };
    // The GLTF default material
    GLTFUtils._DefaultMaterial = null;
    return GLTFUtils;
}());
exports.GLTFUtils = GLTFUtils;


/***/ }),

/***/ "./src/glTF/1.0/glTFMaterialsCommonExtension.ts":
/*!******************************************************!*\
  !*** ./src/glTF/1.0/glTFMaterialsCommonExtension.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = __webpack_require__(/*! . */ "./src/glTF/1.0/index.ts");
var babylonjs_1 = __webpack_require__(/*! babylonjs */ "babylonjs");
var GLTF1Loader_1 = __webpack_require__(/*! ./GLTF1Loader */ "./src/glTF/1.0/GLTF1Loader.ts");
/** @hidden */
var GLTFMaterialsCommonExtension = /** @class */ (function (_super) {
    __extends(GLTFMaterialsCommonExtension, _super);
    function GLTFMaterialsCommonExtension() {
        return _super.call(this, "KHR_materials_common") || this;
    }
    GLTFMaterialsCommonExtension.prototype.loadRuntimeExtensionsAsync = function (gltfRuntime, onSuccess, onError) {
        if (!gltfRuntime.extensions) {
            return false;
        }
        var extension = gltfRuntime.extensions[this.name];
        if (!extension) {
            return false;
        }
        // Create lights
        var lights = extension.lights;
        if (lights) {
            for (var thing in lights) {
                var light = lights[thing];
                switch (light.type) {
                    case "ambient":
                        var ambientLight = new babylonjs_1.HemisphericLight(light.name, new babylonjs_1.Vector3(0, 1, 0), gltfRuntime.scene);
                        var ambient = light.ambient;
                        if (ambient) {
                            ambientLight.diffuse = babylonjs_1.Color3.FromArray(ambient.color || [1, 1, 1]);
                        }
                        break;
                    case "point":
                        var pointLight = new babylonjs_1.PointLight(light.name, new babylonjs_1.Vector3(10, 10, 10), gltfRuntime.scene);
                        var point = light.point;
                        if (point) {
                            pointLight.diffuse = babylonjs_1.Color3.FromArray(point.color || [1, 1, 1]);
                        }
                        break;
                    case "directional":
                        var dirLight = new babylonjs_1.DirectionalLight(light.name, new babylonjs_1.Vector3(0, -1, 0), gltfRuntime.scene);
                        var directional = light.directional;
                        if (directional) {
                            dirLight.diffuse = babylonjs_1.Color3.FromArray(directional.color || [1, 1, 1]);
                        }
                        break;
                    case "spot":
                        var spot = light.spot;
                        if (spot) {
                            var spotLight = new babylonjs_1.SpotLight(light.name, new babylonjs_1.Vector3(0, 10, 0), new babylonjs_1.Vector3(0, -1, 0), spot.fallOffAngle || Math.PI, spot.fallOffExponent || 0.0, gltfRuntime.scene);
                            spotLight.diffuse = babylonjs_1.Color3.FromArray(spot.color || [1, 1, 1]);
                        }
                        break;
                    default:
                        babylonjs_1.Tools.Warn("GLTF Material Common extension: light type \"" + light.type + "\” not supported");
                        break;
                }
            }
        }
        return false;
    };
    GLTFMaterialsCommonExtension.prototype.loadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {
        var material = gltfRuntime.materials[id];
        if (!material || !material.extensions) {
            return false;
        }
        var extension = material.extensions[this.name];
        if (!extension) {
            return false;
        }
        var standardMaterial = new babylonjs_1.StandardMaterial(id, gltfRuntime.scene);
        standardMaterial.sideOrientation = babylonjs_1.Material.CounterClockWiseSideOrientation;
        if (extension.technique === "CONSTANT") {
            standardMaterial.disableLighting = true;
        }
        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;
        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;
        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;
        // Ambient
        if (typeof extension.values.ambient === "string") {
            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, "ambientTexture", onError);
        }
        else {
            standardMaterial.ambientColor = babylonjs_1.Color3.FromArray(extension.values.ambient || [0, 0, 0]);
        }
        // Diffuse
        if (typeof extension.values.diffuse === "string") {
            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, "diffuseTexture", onError);
        }
        else {
            standardMaterial.diffuseColor = babylonjs_1.Color3.FromArray(extension.values.diffuse || [0, 0, 0]);
        }
        // Emission
        if (typeof extension.values.emission === "string") {
            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, "emissiveTexture", onError);
        }
        else {
            standardMaterial.emissiveColor = babylonjs_1.Color3.FromArray(extension.values.emission || [0, 0, 0]);
        }
        // Specular
        if (typeof extension.values.specular === "string") {
            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, "specularTexture", onError);
        }
        else {
            standardMaterial.specularColor = babylonjs_1.Color3.FromArray(extension.values.specular || [0, 0, 0]);
        }
        return true;
    };
    GLTFMaterialsCommonExtension.prototype._loadTexture = function (gltfRuntime, id, material, propertyPath, onError) {
        // Create buffer from texture url
        _1.GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, function (buffer) {
            // Create texture from buffer
            _1.GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, function (texture) { return material[propertyPath] = texture; }, onError);
        }, onError);
    };
    return GLTFMaterialsCommonExtension;
}(_1.GLTFLoaderExtension));
exports.GLTFMaterialsCommonExtension = GLTFMaterialsCommonExtension;
GLTF1Loader_1.GLTF1Loader.RegisterExtension(new GLTFMaterialsCommonExtension());


/***/ }),

/***/ "./src/glTF/1.0/index.ts":
/*!*******************************!*\
  !*** ./src/glTF/1.0/index.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./glTFBinaryExtension */ "./src/glTF/1.0/glTFBinaryExtension.ts"));
__export(__webpack_require__(/*! ./GLTF1Loader */ "./src/glTF/1.0/GLTF1Loader.ts"));
__export(__webpack_require__(/*! ./glTFLoaderExtension */ "./src/glTF/1.0/glTFLoaderExtension.ts"));
__export(__webpack_require__(/*! ./glTFLoaderInterfaces */ "./src/glTF/1.0/glTFLoaderInterfaces.ts"));
__export(__webpack_require__(/*! ./glTFLoaderUtils */ "./src/glTF/1.0/glTFLoaderUtils.ts"));
__export(__webpack_require__(/*! ./glTFMaterialsCommonExtension */ "./src/glTF/1.0/glTFMaterialsCommonExtension.ts"));


/***/ }),

/***/ "./src/glTF/glTFFileLoader.ts":
/*!************************************!*\
  !*** ./src/glTF/glTFFileLoader.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var babylonjs_1 = __webpack_require__(/*! babylonjs */ "babylonjs");
/**
 * Mode that determines the coordinate system to use.
 */
var GLTFLoaderCoordinateSystemMode;
(function (GLTFLoaderCoordinateSystemMode) {
    /**
     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.
     */
    GLTFLoaderCoordinateSystemMode[GLTFLoaderCoordinateSystemMode["AUTO"] = 0] = "AUTO";
    /**
     * Sets the useRightHandedSystem flag on the scene.
     */
    GLTFLoaderCoordinateSystemMode[GLTFLoaderCoordinateSystemMode["FORCE_RIGHT_HANDED"] = 1] = "FORCE_RIGHT_HANDED";
})(GLTFLoaderCoordinateSystemMode = exports.GLTFLoaderCoordinateSystemMode || (exports.GLTFLoaderCoordinateSystemMode = {}));
/**
 * Mode that determines what animations will start.
 */
var GLTFLoaderAnimationStartMode;
(function (GLTFLoaderAnimationStartMode) {
    /**
     * No animation will start.
     */
    GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode["NONE"] = 0] = "NONE";
    /**
     * The first animation will start.
     */
    GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode["FIRST"] = 1] = "FIRST";
    /**
     * All animations will start.
     */
    GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode["ALL"] = 2] = "ALL";
})(GLTFLoaderAnimationStartMode = exports.GLTFLoaderAnimationStartMode || (exports.GLTFLoaderAnimationStartMode = {}));
/**
 * Loader state.
 */
var GLTFLoaderState;
(function (GLTFLoaderState) {
    /**
     * The asset is loading.
     */
    GLTFLoaderState[GLTFLoaderState["LOADING"] = 0] = "LOADING";
    /**
     * The asset is ready for rendering.
     */
    GLTFLoaderState[GLTFLoaderState["READY"] = 1] = "READY";
    /**
     * The asset is completely loaded.
     */
    GLTFLoaderState[GLTFLoaderState["COMPLETE"] = 2] = "COMPLETE";
})(GLTFLoaderState = exports.GLTFLoaderState || (exports.GLTFLoaderState = {}));
/**
 * File loader for loading glTF files into a scene.
 */
var GLTFFileLoader = /** @class */ (function () {
    function GLTFFileLoader() {
        // --------------
        // Common options
        // --------------
        /**
         * Raised when the asset has been parsed
         */
        this.onParsedObservable = new babylonjs_1.Observable();
        // ----------
        // V2 options
        // ----------
        /**
         * The coordinate system mode. Defaults to AUTO.
         */
        this.coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;
        /**
        * The animation start mode. Defaults to FIRST.
        */
        this.animationStartMode = GLTFLoaderAnimationStartMode.FIRST;
        /**
         * Defines if the loader should compile materials before raising the success callback. Defaults to false.
         */
        this.compileMaterials = false;
        /**
         * Defines if the loader should also compile materials with clip planes. Defaults to false.
         */
        this.useClipPlane = false;
        /**
         * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.
         */
        this.compileShadowGenerators = false;
        /**
         * Defines if the Alpha blended materials are only applied as coverage.
         * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.
         * If true, no extra effects are applied to transparent pixels.
         */
        this.transparencyAsCoverage = false;
        /**
         * Function called before loading a url referenced by the asset.
         */
        this.preprocessUrlAsync = function (url) { return Promise.resolve(url); };
        /**
         * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.
         */
        this.onMeshLoadedObservable = new babylonjs_1.Observable();
        /**
         * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.
         */
        this.onTextureLoadedObservable = new babylonjs_1.Observable();
        /**
         * Observable raised when the loader creates a material after parsing the glTF properties of the material.
         */
        this.onMaterialLoadedObservable = new babylonjs_1.Observable();
        /**
         * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.
         */
        this.onCameraLoadedObservable = new babylonjs_1.Observable();
        /**
         * Observable raised when the asset is completely loaded, immediately before the loader is disposed.
         * For assets with LODs, raised when all of the LODs are complete.
         * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.
         */
        this.onCompleteObservable = new babylonjs_1.Observable();
        /**
         * Observable raised when an error occurs.
         */
        this.onErrorObservable = new babylonjs_1.Observable();
        /**
         * Observable raised after the loader is disposed.
         */
        this.onDisposeObservable = new babylonjs_1.Observable();
        /**
         * Observable raised after a loader extension is created.
         * Set additional options for a loader extension in this event.
         */
        this.onExtensionLoadedObservable = new babylonjs_1.Observable();
        /**
         * Defines if the loader should validate the asset.
         */
        this.validate = false;
        /**
         * Observable raised after validation when validate is set to true. The event data is the result of the validation.
         */
        this.onValidatedObservable = new babylonjs_1.Observable();
        this._loader = null;
        /**
         * Name of the loader ("gltf")
         */
        this.name = "gltf";
        /**
         * Supported file extensions of the loader (.gltf, .glb)
         */
        this.extensions = {
            ".gltf": { isBinary: false },
            ".glb": { isBinary: true }
        };
        this._logIndentLevel = 0;
        this._loggingEnabled = false;
        /** @hidden */
        this._log = this._logDisabled;
        this._capturePerformanceCounters = false;
        /** @hidden */
        this._startPerformanceCounter = this._startPerformanceCounterDisabled;
        /** @hidden */
        this._endPerformanceCounter = this._endPerformanceCounterDisabled;
    }
    Object.defineProperty(GLTFFileLoader.prototype, "onParsed", {
        /**
         * Raised when the asset has been parsed
         */
        set: function (callback) {
            if (this._onParsedObserver) {
                this.onParsedObservable.remove(this._onParsedObserver);
            }
            this._onParsedObserver = this.onParsedObservable.add(callback);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onMeshLoaded", {
        /**
         * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.
         */
        set: function (callback) {
            if (this._onMeshLoadedObserver) {
                this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);
            }
            this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onTextureLoaded", {
        /**
         * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.
         */
        set: function (callback) {
            if (this._onTextureLoadedObserver) {
                this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);
            }
            this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onMaterialLoaded", {
        /**
         * Callback raised when the loader creates a material after parsing the glTF properties of the material.
         */
        set: function (callback) {
            if (this._onMaterialLoadedObserver) {
                this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);
            }
            this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onCameraLoaded", {
        /**
         * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.
         */
        set: function (callback) {
            if (this._onCameraLoadedObserver) {
                this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);
            }
            this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onComplete", {
        /**
         * Callback raised when the asset is completely loaded, immediately before the loader is disposed.
         * For assets with LODs, raised when all of the LODs are complete.
         * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.
         */
        set: function (callback) {
            if (this._onCompleteObserver) {
                this.onCompleteObservable.remove(this._onCompleteObserver);
            }
            this._onCompleteObserver = this.onCompleteObservable.add(callback);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onError", {
        /**
         * Callback raised when an error occurs.
         */
        set: function (callback) {
            if (this._onErrorObserver) {
                this.onErrorObservable.remove(this._onErrorObserver);
            }
            this._onErrorObserver = this.onErrorObservable.add(callback);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onDispose", {
        /**
         * Callback raised after the loader is disposed.
         */
        set: function (callback) {
            if (this._onDisposeObserver) {
                this.onDisposeObservable.remove(this._onDisposeObserver);
            }
            this._onDisposeObserver = this.onDisposeObservable.add(callback);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onExtensionLoaded", {
        /**
         * Callback raised after a loader extension is created.
         */
        set: function (callback) {
            if (this._onExtensionLoadedObserver) {
                this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);
            }
            this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "loggingEnabled", {
        /**
         * Defines if the loader logging is enabled.
         */
        get: function () {
            return this._loggingEnabled;
        },
        set: function (value) {
            if (this._loggingEnabled === value) {
                return;
            }
            this._loggingEnabled = value;
            if (this._loggingEnabled) {
                this._log = this._logEnabled;
            }
            else {
                this._log = this._logDisabled;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "capturePerformanceCounters", {
        /**
         * Defines if the loader should capture performance counters.
         */
        get: function () {
            return this._capturePerformanceCounters;
        },
        set: function (value) {
            if (this._capturePerformanceCounters === value) {
                return;
            }
            this._capturePerformanceCounters = value;
            if (this._capturePerformanceCounters) {
                this._startPerformanceCounter = this._startPerformanceCounterEnabled;
                this._endPerformanceCounter = this._endPerformanceCounterEnabled;
            }
            else {
                this._startPerformanceCounter = this._startPerformanceCounterDisabled;
                this._endPerformanceCounter = this._endPerformanceCounterDisabled;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GLTFFileLoader.prototype, "onValidated", {
        /**
         * Callback raised after a loader extension is created.
         */
        set: function (callback) {
            if (this._onValidatedObserver) {
                this.onValidatedObservable.remove(this._onValidatedObserver);
            }
            this._onValidatedObserver = this.onValidatedObservable.add(callback);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes the loader, releases resources during load, and cancels any outstanding requests.
     */
    GLTFFileLoader.prototype.dispose = function () {
        if (this._loader) {
            this._loader.dispose();
            this._loader = null;
        }
        this._clear();
        this.onDisposeObservable.notifyObservers(undefined);
        this.onDisposeObservable.clear();
    };
    /** @hidden */
    GLTFFileLoader.prototype._clear = function () {
        this.preprocessUrlAsync = function (url) { return Promise.resolve(url); };
        this.onMeshLoadedObservable.clear();
        this.onTextureLoadedObservable.clear();
        this.onMaterialLoadedObservable.clear();
        this.onCameraLoadedObservable.clear();
        this.onCompleteObservable.clear();
        this.onExtensionLoadedObservable.clear();
    };
    /**
     * Imports one or more meshes from the loaded glTF data and adds them to the scene
     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
     * @param scene the scene the meshes should be added to
     * @param data the glTF data to load
     * @param rootUrl root url to load from
     * @param onProgress event that fires when loading progress has occured
     * @param fileName Defines the name of the file to load
     * @returns a promise containg the loaded meshes, particles, skeletons and animations
     */
    GLTFFileLoader.prototype.importMeshAsync = function (meshesNames, scene, data, rootUrl, onProgress, fileName) {
        var _this = this;
        return this._parseAsync(scene, data, rootUrl, fileName).then(function (loaderData) {
            _this._log("Loading " + (fileName || ""));
            _this._loader = _this._getLoader(loaderData);
            return _this._loader.importMeshAsync(meshesNames, scene, loaderData, rootUrl, onProgress, fileName);
        });
    };
    /**
     * Imports all objects from the loaded glTF data and adds them to the scene
     * @param scene the scene the objects should be added to
     * @param data the glTF data to load
     * @param rootUrl root url to load from
     * @param onProgress event that fires when loading progress has occured
     * @param fileName Defines the name of the file to load
     * @returns a promise which completes when objects have been loaded to the scene
     */
    GLTFFileLoader.prototype.loadAsync = function (scene, data, rootUrl, onProgress, fileName) {
        var _this = this;
        return this._parseAsync(scene, data, rootUrl, fileName).then(function (loaderData) {
            _this._log("Loading " + (fileName || ""));
            _this._loader = _this._getLoader(loaderData);
            return _this._loader.loadAsync(scene, loaderData, rootUrl, onProgress, fileName);
        });
    };
    /**
     * Load into an asset container.
     * @param scene The scene to load into
     * @param data The data to import
     * @param rootUrl The root url for scene and resources
     * @param onProgress The callback when the load progresses
     * @param fileName Defines the name of the file to load
     * @returns The loaded asset container
     */
    GLTFFileLoader.prototype.loadAssetContainerAsync = function (scene, data, rootUrl, onProgress, fileName) {
        var _this = this;
        return this._parseAsync(scene, data, rootUrl, fileName).then(function (loaderData) {
            _this._log("Loading " + (fileName || ""));
            _this._loader = _this._getLoader(loaderData);
            return _this._loader.importMeshAsync(null, scene, loaderData, rootUrl, onProgress, fileName).then(function (result) {
                var container = new babylonjs_1.AssetContainer(scene);
                Array.prototype.push.apply(container.meshes, result.meshes);
                Array.prototype.push.apply(container.particleSystems, result.particleSystems);
                Array.prototype.push.apply(container.skeletons, result.skeletons);
                Array.prototype.push.apply(container.animationGroups, result.animationGroups);
                container.removeAllFromScene();
                return container;
            });
        });
    };
    /**
     * If the data string can be loaded directly.
     * @param data string contianing the file data
     * @returns if the data can be loaded directly
     */
    GLTFFileLoader.prototype.canDirectLoad = function (data) {
        return ((data.indexOf("scene") !== -1) && (data.indexOf("node") !== -1));
    };
    /**
     * Instantiates a glTF file loader plugin.
     * @returns the created plugin
     */
    GLTFFileLoader.prototype.createPlugin = function () {
        return new GLTFFileLoader();
    };
    Object.defineProperty(GLTFFileLoader.prototype, "loaderState", {
        /**
         * The loader state or null if the loader is not active.
         */
        get: function () {
            return this._loader ? this._loader.state : null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a promise that resolves when the asset is completely loaded.
     * @returns a promise that resolves when the asset is completely loaded.
     */
    GLTFFileLoader.prototype.whenCompleteAsync = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.onCompleteObservable.addOnce(function () {
                resolve();
            });
            _this.onErrorObservable.addOnce(function (reason) {
                reject(reason);
            });
        });
    };
    GLTFFileLoader.prototype._parseAsync = function (scene, data, rootUrl, fileName) {
        var _this = this;
        return Promise.resolve().then(function () {
            var unpacked = (data instanceof ArrayBuffer) ? _this._unpackBinary(data) : { json: data, bin: null };
            return _this._validateAsync(scene, unpacked.json, rootUrl, fileName).then(function () {
                _this._startPerformanceCounter("Parse JSON");
                _this._log("JSON length: " + unpacked.json.length);
                var loaderData = {
                    json: JSON.parse(unpacked.json),
                    bin: unpacked.bin
                };
                _this._endPerformanceCounter("Parse JSON");
                _this.onParsedObservable.notifyObservers(loaderData);
                _this.onParsedObservable.clear();
                return loaderData;
            });
        });
    };
    GLTFFileLoader.prototype._validateAsync = function (scene, json, rootUrl, fileName) {
        var _this = this;
        if (!this.validate || typeof GLTFValidator === "undefined") {
            return Promise.resolve();
        }
        this._startPerformanceCounter("Validate JSON");
        var options = {
            externalResourceFunction: function (uri) {
                return _this.preprocessUrlAsync(rootUrl + uri)
                    .then(function (url) { return scene._loadFileAsync(url, true, true); })
                    .then(function (data) { return new Uint8Array(data); });
            }
        };
        if (fileName && fileName.substr(0, 5) !== "data:") {
            options.uri = (rootUrl === "file:" ? fileName : "" + rootUrl + fileName);
        }
        return GLTFValidator.validateString(json, options).then(function (result) {
            _this._endPerformanceCounter("Validate JSON");
            _this.onValidatedObservable.notifyObservers(result);
            _this.onValidatedObservable.clear();
        }, function (reason) {
            _this._endPerformanceCounter("Validate JSON");
            babylonjs_1.Tools.Warn("Failed to validate: " + reason);
            _this.onValidatedObservable.clear();
        });
    };
    GLTFFileLoader.prototype._getLoader = function (loaderData) {
        var asset = loaderData.json.asset || {};
        this._log("Asset version: " + asset.version);
        asset.minVersion && this._log("Asset minimum version: " + asset.minVersion);
        asset.generator && this._log("Asset generator: " + asset.generator);
        var version = GLTFFileLoader._parseVersion(asset.version);
        if (!version) {
            throw new Error("Invalid version: " + asset.version);
        }
        if (asset.minVersion !== undefined) {
            var minVersion = GLTFFileLoader._parseVersion(asset.minVersion);
            if (!minVersion) {
                throw new Error("Invalid minimum version: " + asset.minVersion);
            }
            if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {
                throw new Error("Incompatible minimum version: " + asset.minVersion);
            }
        }
        var createLoaders = {
            1: GLTFFileLoader._CreateGLTF1Loader,
            2: GLTFFileLoader._CreateGLTF2Loader
        };
        var createLoader = createLoaders[version.major];
        if (!createLoader) {
            throw new Error("Unsupported version: " + asset.version);
        }
        return createLoader(this);
    };
    GLTFFileLoader.prototype._unpackBinary = function (data) {
        this._startPerformanceCounter("Unpack binary");
        this._log("Binary length: " + data.byteLength);
        var Binary = {
            Magic: 0x46546C67
        };
        var binaryReader = new BinaryReader(data);
        var magic = binaryReader.readUint32();
        if (magic !== Binary.Magic) {
            throw new Error("Unexpected magic: " + magic);
        }
        var version = binaryReader.readUint32();
        if (this.loggingEnabled) {
            this._log("Binary version: " + version);
        }
        var unpacked;
        switch (version) {
            case 1: {
                unpacked = this._unpackBinaryV1(binaryReader);
                break;
            }
            case 2: {
                unpacked = this._unpackBinaryV2(binaryReader);
                break;
            }
            default: {
                throw new Error("Unsupported version: " + version);
            }
        }
        this._endPerformanceCounter("Unpack binary");
        return unpacked;
    };
    GLTFFileLoader.prototype._unpackBinaryV1 = function (binaryReader) {
        var ContentFormat = {
            JSON: 0
        };
        var length = binaryReader.readUint32();
        if (length != binaryReader.getLength()) {
            throw new Error("Length in header does not match actual data length: " + length + " != " + binaryReader.getLength());
        }
        var contentLength = binaryReader.readUint32();
        var contentFormat = binaryReader.readUint32();
        var content;
        switch (contentFormat) {
            case ContentFormat.JSON: {
                content = GLTFFileLoader._decodeBufferToText(binaryReader.readUint8Array(contentLength));
                break;
            }
            default: {
                throw new Error("Unexpected content format: " + contentFormat);
            }
        }
        var bytesRemaining = binaryReader.getLength() - binaryReader.getPosition();
        var body = binaryReader.readUint8Array(bytesRemaining);
        return {
            json: content,
            bin: body
        };
    };
    GLTFFileLoader.prototype._unpackBinaryV2 = function (binaryReader) {
        var ChunkFormat = {
            JSON: 0x4E4F534A,
            BIN: 0x004E4942
        };
        var length = binaryReader.readUint32();
        if (length !== binaryReader.getLength()) {
            throw new Error("Length in header does not match actual data length: " + length + " != " + binaryReader.getLength());
        }
        // JSON chunk
        var chunkLength = binaryReader.readUint32();
        var chunkFormat = binaryReader.readUint32();
        if (chunkFormat !== ChunkFormat.JSON) {
            throw new Error("First chunk format is not JSON");
        }
        var json = GLTFFileLoader._decodeBufferToText(binaryReader.readUint8Array(chunkLength));
        // Look for BIN chunk
        var bin = null;
        while (binaryReader.getPosition() < binaryReader.getLength()) {
            var chunkLength_1 = binaryReader.readUint32();
            var chunkFormat_1 = binaryReader.readUint32();
            switch (chunkFormat_1) {
                case ChunkFormat.JSON: {
                    throw new Error("Unexpected JSON chunk");
                }
                case ChunkFormat.BIN: {
                    bin = binaryReader.readUint8Array(chunkLength_1);
                    break;
                }
                default: {
                    // ignore unrecognized chunkFormat
                    binaryReader.skipBytes(chunkLength_1);
                    break;
                }
            }
        }
        return {
            json: json,
            bin: bin
        };
    };
    GLTFFileLoader._parseVersion = function (version) {
        if (version === "1.0" || version === "1.0.1") {
            return {
                major: 1,
                minor: 0
            };
        }
        var match = (version + "").match(/^(\d+)\.(\d+)/);
        if (!match) {
            return null;
        }
        return {
            major: parseInt(match[1]),
            minor: parseInt(match[2])
        };
    };
    GLTFFileLoader._compareVersion = function (a, b) {
        if (a.major > b.major) {
            return 1;
        }
        if (a.major < b.major) {
            return -1;
        }
        if (a.minor > b.minor) {
            return 1;
        }
        if (a.minor < b.minor) {
            return -1;
        }
        return 0;
    };
    GLTFFileLoader._decodeBufferToText = function (buffer) {
        var result = "";
        var length = buffer.byteLength;
        for (var i = 0; i < length; i++) {
            result += String.fromCharCode(buffer[i]);
        }
        return result;
    };
    /** @hidden */
    GLTFFileLoader.prototype._logOpen = function (message) {
        this._log(message);
        this._logIndentLevel++;
    };
    /** @hidden */
    GLTFFileLoader.prototype._logClose = function () {
        --this._logIndentLevel;
    };
    GLTFFileLoader.prototype._logEnabled = function (message) {
        var spaces = GLTFFileLoader._logSpaces.substr(0, this._logIndentLevel * 2);
        babylonjs_1.Tools.Log("" + spaces + message);
    };
    GLTFFileLoader.prototype._logDisabled = function (message) {
    };
    GLTFFileLoader.prototype._startPerformanceCounterEnabled = function (counterName) {
        babylonjs_1.Tools.StartPerformanceCounter(counterName);
    };
    GLTFFileLoader.prototype._startPerformanceCounterDisabled = function (counterName) {
    };
    GLTFFileLoader.prototype._endPerformanceCounterEnabled = function (counterName) {
        babylonjs_1.Tools.EndPerformanceCounter(counterName);
    };
    GLTFFileLoader.prototype._endPerformanceCounterDisabled = function (counterName) {
    };
    // ----------
    // V1 options
    // ----------
    /**
     * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.
     * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.
     * Defaults to true.
     * @hidden
     */
    GLTFFileLoader.IncrementalLoading = true;
    /**
     * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.
     * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.
     * @hidden
     */
    GLTFFileLoader.HomogeneousCoordinates = false;
    GLTFFileLoader._logSpaces = "                                ";
    return GLTFFileLoader;
}());
exports.GLTFFileLoader = GLTFFileLoader;
var BinaryReader = /** @class */ (function () {
    function BinaryReader(arrayBuffer) {
        this._arrayBuffer = arrayBuffer;
        this._dataView = new DataView(arrayBuffer);
        this._byteOffset = 0;
    }
    BinaryReader.prototype.getPosition = function () {
        return this._byteOffset;
    };
    BinaryReader.prototype.getLength = function () {
        return this._arrayBuffer.byteLength;
    };
    BinaryReader.prototype.readUint32 = function () {
        var value = this._dataView.getUint32(this._byteOffset, true);
        this._byteOffset += 4;
        return value;
    };
    BinaryReader.prototype.readUint8Array = function (length) {
        var value = new Uint8Array(this._arrayBuffer, this._byteOffset, length);
        this._byteOffset += length;
        return value;
    };
    BinaryReader.prototype.skipBytes = function (length) {
        this._byteOffset += length;
    };
    return BinaryReader;
}());
if (babylonjs_1.SceneLoader) {
    babylonjs_1.SceneLoader.RegisterPlugin(new GLTFFileLoader());
}


/***/ }),

/***/ "babylonjs":
/*!****************************************************************************************************!*\
  !*** external {"root":"BABYLON","commonjs":"babylonjs","commonjs2":"babylonjs","amd":"babylonjs"} ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_babylonjs__;

/***/ })

/******/ });
});
//# sourceMappingURL=babylon.glTF1FileLoader.min.js.map
=======
!(function(a){var e,n,r,t,o;(n=e=a.GLTFLoaderCoordinateSystemMode||(a.GLTFLoaderCoordinateSystemMode={}))[n.AUTO=0]="AUTO",n[n.FORCE_RIGHT_HANDED=1]="FORCE_RIGHT_HANDED",(t=r=a.GLTFLoaderAnimationStartMode||(a.GLTFLoaderAnimationStartMode={}))[t.NONE=0]="NONE",t[t.FIRST=1]="FIRST",t[t.ALL=2]="ALL",(o=a.GLTFLoaderState||(a.GLTFLoaderState={}))[o.LOADING=0]="LOADING",o[o.READY=1]="READY",o[o.COMPLETE=2]="COMPLETE";var i=(function(){function u(){this.onParsedObservable=new a.Observable,this.coordinateSystemMode=e.AUTO,this.animationStartMode=r.FIRST,this.compileMaterials=!1,this.useClipPlane=!1,this.compileShadowGenerators=!1,this.transparencyAsCoverage=!1,this.preprocessUrlAsync=function(e){return Promise.resolve(e)},this.onMeshLoadedObservable=new a.Observable,this.onTextureLoadedObservable=new a.Observable,this.onMaterialLoadedObservable=new a.Observable,this.onCameraLoadedObservable=new a.Observable,this.onCompleteObservable=new a.Observable,this.onErrorObservable=new a.Observable,this.onDisposeObservable=new a.Observable,this.onExtensionLoadedObservable=new a.Observable,this.validate=!1,this.onValidatedObservable=new a.Observable,this._loader=null,this.name="gltf",this.extensions={".gltf":{isBinary:!1},".glb":{isBinary:!0}},this._logIndentLevel=0,this._loggingEnabled=!1,this._log=this._logDisabled,this._capturePerformanceCounters=!1,this._startPerformanceCounter=this._startPerformanceCounterDisabled,this._endPerformanceCounter=this._endPerformanceCounterDisabled}return Object.defineProperty(u.prototype,"onParsed",{set:function(e){this._onParsedObserver&&this.onParsedObservable.remove(this._onParsedObserver),this._onParsedObserver=this.onParsedObservable.add(e)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"onMeshLoaded",{set:function(e){this._onMeshLoadedObserver&&this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver),this._onMeshLoadedObserver=this.onMeshLoadedObservable.add(e)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"onTextureLoaded",{set:function(e){this._onTextureLoadedObserver&&this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver),this._onTextureLoadedObserver=this.onTextureLoadedObservable.add(e)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"onMaterialLoaded",{set:function(e){this._onMaterialLoadedObserver&&this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver),this._onMaterialLoadedObserver=this.onMaterialLoadedObservable.add(e)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"onCameraLoaded",{set:function(e){this._onCameraLoadedObserver&&this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver),this._onCameraLoadedObserver=this.onCameraLoadedObservable.add(e)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"onComplete",{set:function(e){this._onCompleteObserver&&this.onCompleteObservable.remove(this._onCompleteObserver),this._onCompleteObserver=this.onCompleteObservable.add(e)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"onError",{set:function(e){this._onErrorObserver&&this.onErrorObservable.remove(this._onErrorObserver),this._onErrorObserver=this.onErrorObservable.add(e)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"onDispose",{set:function(e){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(e)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"onExtensionLoaded",{set:function(e){this._onExtensionLoadedObserver&&this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver),this._onExtensionLoadedObserver=this.onExtensionLoadedObservable.add(e)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"loggingEnabled",{get:function(){return this._loggingEnabled},set:function(e){this._loggingEnabled!==e&&(this._loggingEnabled=e,this._loggingEnabled?this._log=this._logEnabled:this._log=this._logDisabled)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"capturePerformanceCounters",{get:function(){return this._capturePerformanceCounters},set:function(e){this._capturePerformanceCounters!==e&&(this._capturePerformanceCounters=e,this._capturePerformanceCounters?(this._startPerformanceCounter=this._startPerformanceCounterEnabled,this._endPerformanceCounter=this._endPerformanceCounterEnabled):(this._startPerformanceCounter=this._startPerformanceCounterDisabled,this._endPerformanceCounter=this._endPerformanceCounterDisabled))},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"onValidated",{set:function(e){this._onValidatedObserver&&this.onValidatedObservable.remove(this._onValidatedObserver),this._onValidatedObserver=this.onValidatedObservable.add(e)},enumerable:!0,configurable:!0}),u.prototype.dispose=function(){this._loader&&(this._loader.dispose(),this._loader=null),this._clear(),this.onDisposeObservable.notifyObservers(void 0),this.onDisposeObservable.clear()},u.prototype._clear=function(){this.preprocessUrlAsync=function(e){return Promise.resolve(e)},this.onMeshLoadedObservable.clear(),this.onTextureLoadedObservable.clear(),this.onMaterialLoadedObservable.clear(),this.onCameraLoadedObservable.clear(),this.onCompleteObservable.clear(),this.onExtensionLoadedObservable.clear()},u.prototype.importMeshAsync=function(n,r,e,t,o,i){var a=this;return this._parseAsync(r,e,t,i).then((function(e){return a._log("Loading "+(i||"")),a._loader=a._getLoader(e),a._loader.importMeshAsync(n,r,e,t,o,i)}))},u.prototype.loadAsync=function(n,e,r,t,o){var i=this;return this._parseAsync(n,e,r,o).then((function(e){return i._log("Loading "+(o||"")),i._loader=i._getLoader(e),i._loader.loadAsync(n,e,r,t,o)}))},u.prototype.loadAssetContainerAsync=function(r,e,n,t,o){var i=this;return this._parseAsync(r,e,n,o).then((function(e){return i._log("Loading "+(o||"")),i._loader=i._getLoader(e),i._loader.importMeshAsync(null,r,e,n,t,o).then((function(e){var n=new a.AssetContainer(r);return Array.prototype.push.apply(n.meshes,e.meshes),Array.prototype.push.apply(n.particleSystems,e.particleSystems),Array.prototype.push.apply(n.skeletons,e.skeletons),Array.prototype.push.apply(n.animationGroups,e.animationGroups),n.removeAllFromScene(),n}))}))},u.prototype.canDirectLoad=function(e){return-1!==e.indexOf("scene")&&-1!==e.indexOf("node")},u.prototype.createPlugin=function(){return new u},Object.defineProperty(u.prototype,"loaderState",{get:function(){return this._loader?this._loader.state:null},enumerable:!0,configurable:!0}),u.prototype.whenCompleteAsync=function(){var r=this;return new Promise(function(e,n){r.onCompleteObservable.addOnce((function(){e()})),r.onErrorObservable.addOnce((function(e){n(e)}))})},u.prototype._parseAsync=function(e,r,t,o){var i=this;return Promise.resolve().then((function(){var n=r instanceof ArrayBuffer?i._unpackBinary(r):{json:r,bin:null};return i._validateAsync(e,n.json,t,o).then((function(){i._startPerformanceCounter("Parse JSON"),i._log("JSON length: "+n.json.length);var e={json:JSON.parse(n.json),bin:n.bin};return i._endPerformanceCounter("Parse JSON"),i.onParsedObservable.notifyObservers(e),i.onParsedObservable.clear(),e}))}))},u.prototype._validateAsync=function(n,e,r,t){var o=this;if(!this.validate||"undefined"==typeof GLTFValidator)return Promise.resolve();this._startPerformanceCounter("Validate JSON");var i={externalResourceFunction:function(e){return o.preprocessUrlAsync(r+e).then((function(e){return n._loadFileAsync(e,!0,!0)})).then((function(e){return new Uint8Array(e)}))}};return t&&"data:"!==t.substr(0,5)&&(i.uri="file:"===r?t:""+r+t),GLTFValidator.validateString(e,i).then((function(e){o._endPerformanceCounter("Validate JSON"),o.onValidatedObservable.notifyObservers(e),o.onValidatedObservable.clear()}),(function(e){o._endPerformanceCounter("Validate JSON"),a.Tools.Warn("Failed to validate: "+e),o.onValidatedObservable.clear()}))},u.prototype._getLoader=function(e){var n=e.json.asset||{};this._log("Asset version: "+n.version),n.minVersion&&this._log("Asset minimum version: "+n.minVersion),n.generator&&this._log("Asset generator: "+n.generator);var r=u._parseVersion(n.version);if(!r)throw new Error("Invalid version: "+n.version);if(void 0!==n.minVersion){var t=u._parseVersion(n.minVersion);if(!t)throw new Error("Invalid minimum version: "+n.minVersion);if(0<u._compareVersion(t,{major:2,minor:0}))throw new Error("Incompatible minimum version: "+n.minVersion)}var o={1:u._CreateGLTFLoaderV1,2:u._CreateGLTFLoaderV2}[r.major];if(!o)throw new Error("Unsupported version: "+n.version);return o(this)},u.prototype._unpackBinary=function(e){this._startPerformanceCounter("Unpack binary"),this._log("Binary length: "+e.byteLength);var n=new s(e),r=n.readUint32();if(1179937895!==r)throw new Error("Unexpected magic: "+r);var t,o=n.readUint32();switch(this.loggingEnabled&&this._log("Binary version: "+o),o){case 1:t=this._unpackBinaryV1(n);break;case 2:t=this._unpackBinaryV2(n);break;default:throw new Error("Unsupported version: "+o)}return this._endPerformanceCounter("Unpack binary"),t},u.prototype._unpackBinaryV1=function(e){var n=e.readUint32();if(n!=e.getLength())throw new Error("Length in header does not match actual data length: "+n+" != "+e.getLength());var r,t=e.readUint32(),o=e.readUint32();switch(o){case 0:r=u._decodeBufferToText(e.readUint8Array(t));break;default:throw new Error("Unexpected content format: "+o)}var i=e.getLength()-e.getPosition();return{json:r,bin:e.readUint8Array(i)}},u.prototype._unpackBinaryV2=function(e){var n=1313821514,r=5130562,t=e.readUint32();if(t!==e.getLength())throw new Error("Length in header does not match actual data length: "+t+" != "+e.getLength());var o=e.readUint32();if(e.readUint32()!==n)throw new Error("First chunk format is not JSON");for(var i=u._decodeBufferToText(e.readUint8Array(o)),a=null;e.getPosition()<e.getLength();){var s=e.readUint32();switch(e.readUint32()){case n:throw new Error("Unexpected JSON chunk");case r:a=e.readUint8Array(s);break;default:e.skipBytes(s)}}return{json:i,bin:a}},u._parseVersion=function(e){if("1.0"===e||"1.0.1"===e)return{major:1,minor:0};var n=(e+"").match(/^(\d+)\.(\d+)/);return n?{major:parseInt(n[1]),minor:parseInt(n[2])}:null},u._compareVersion=function(e,n){return e.major>n.major?1:e.major<n.major?-1:e.minor>n.minor?1:e.minor<n.minor?-1:0},u._decodeBufferToText=function(e){for(var n="",r=e.byteLength,t=0;t<r;t++)n+=String.fromCharCode(e[t]);return n},u.prototype._logOpen=function(e){this._log(e),this._logIndentLevel++},u.prototype._logClose=function(){--this._logIndentLevel},u.prototype._logEnabled=function(e){var n=u._logSpaces.substr(0,2*this._logIndentLevel);a.Tools.Log(""+n+e)},u.prototype._logDisabled=function(e){},u.prototype._startPerformanceCounterEnabled=function(e){a.Tools.StartPerformanceCounter(e)},u.prototype._startPerformanceCounterDisabled=function(e){},u.prototype._endPerformanceCounterEnabled=function(e){a.Tools.EndPerformanceCounter(e)},u.prototype._endPerformanceCounterDisabled=function(e){},u.IncrementalLoading=!0,u.HomogeneousCoordinates=!1,u._logSpaces="                                ",u})();a.GLTFFileLoader=i;var s=(function(){function e(e){this._arrayBuffer=e,this._dataView=new DataView(e),this._byteOffset=0}return e.prototype.getPosition=function(){return this._byteOffset},e.prototype.getLength=function(){return this._arrayBuffer.byteLength},e.prototype.readUint32=function(){var e=this._dataView.getUint32(this._byteOffset,!0);return this._byteOffset+=4,e},e.prototype.readUint8Array=function(e){var n=new Uint8Array(this._arrayBuffer,this._byteOffset,e);return this._byteOffset+=e,n},e.prototype.skipBytes=function(e){this._byteOffset+=e},e})();a.SceneLoader&&a.SceneLoader.RegisterPlugin(new i)})(BABYLON||(BABYLON={})),(function(e){var n,r,t,o,i,a,s,u,l;n=e.GLTF1||(e.GLTF1={}),(r=n.EComponentType||(n.EComponentType={}))[r.BYTE=5120]="BYTE",r[r.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",r[r.SHORT=5122]="SHORT",r[r.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",r[r.FLOAT=5126]="FLOAT",(t=n.EShaderType||(n.EShaderType={}))[t.FRAGMENT=35632]="FRAGMENT",t[t.VERTEX=35633]="VERTEX",(o=n.EParameterType||(n.EParameterType={}))[o.BYTE=5120]="BYTE",o[o.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",o[o.SHORT=5122]="SHORT",o[o.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",o[o.INT=5124]="INT",o[o.UNSIGNED_INT=5125]="UNSIGNED_INT",o[o.FLOAT=5126]="FLOAT",o[o.FLOAT_VEC2=35664]="FLOAT_VEC2",o[o.FLOAT_VEC3=35665]="FLOAT_VEC3",o[o.FLOAT_VEC4=35666]="FLOAT_VEC4",o[o.INT_VEC2=35667]="INT_VEC2",o[o.INT_VEC3=35668]="INT_VEC3",o[o.INT_VEC4=35669]="INT_VEC4",o[o.BOOL=35670]="BOOL",o[o.BOOL_VEC2=35671]="BOOL_VEC2",o[o.BOOL_VEC3=35672]="BOOL_VEC3",o[o.BOOL_VEC4=35673]="BOOL_VEC4",o[o.FLOAT_MAT2=35674]="FLOAT_MAT2",o[o.FLOAT_MAT3=35675]="FLOAT_MAT3",o[o.FLOAT_MAT4=35676]="FLOAT_MAT4",o[o.SAMPLER_2D=35678]="SAMPLER_2D",(i=n.ETextureWrapMode||(n.ETextureWrapMode={}))[i.CLAMP_TO_EDGE=33071]="CLAMP_TO_EDGE",i[i.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT",i[i.REPEAT=10497]="REPEAT",(a=n.ETextureFilterType||(n.ETextureFilterType={}))[a.NEAREST=9728]="NEAREST",a[a.LINEAR=9728]="LINEAR",a[a.NEAREST_MIPMAP_NEAREST=9984]="NEAREST_MIPMAP_NEAREST",a[a.LINEAR_MIPMAP_NEAREST=9985]="LINEAR_MIPMAP_NEAREST",a[a.NEAREST_MIPMAP_LINEAR=9986]="NEAREST_MIPMAP_LINEAR",a[a.LINEAR_MIPMAP_LINEAR=9987]="LINEAR_MIPMAP_LINEAR",(s=n.ETextureFormat||(n.ETextureFormat={}))[s.ALPHA=6406]="ALPHA",s[s.RGB=6407]="RGB",s[s.RGBA=6408]="RGBA",s[s.LUMINANCE=6409]="LUMINANCE",s[s.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",(u=n.ECullingType||(n.ECullingType={}))[u.FRONT=1028]="FRONT",u[u.BACK=1029]="BACK",u[u.FRONT_AND_BACK=1032]="FRONT_AND_BACK",(l=n.EBlendingFunction||(n.EBlendingFunction={}))[l.ZERO=0]="ZERO",l[l.ONE=1]="ONE",l[l.SRC_COLOR=768]="SRC_COLOR",l[l.ONE_MINUS_SRC_COLOR=769]="ONE_MINUS_SRC_COLOR",l[l.DST_COLOR=774]="DST_COLOR",l[l.ONE_MINUS_DST_COLOR=775]="ONE_MINUS_DST_COLOR",l[l.SRC_ALPHA=770]="SRC_ALPHA",l[l.ONE_MINUS_SRC_ALPHA=771]="ONE_MINUS_SRC_ALPHA",l[l.DST_ALPHA=772]="DST_ALPHA",l[l.ONE_MINUS_DST_ALPHA=773]="ONE_MINUS_DST_ALPHA",l[l.CONSTANT_COLOR=32769]="CONSTANT_COLOR",l[l.ONE_MINUS_CONSTANT_COLOR=32770]="ONE_MINUS_CONSTANT_COLOR",l[l.CONSTANT_ALPHA=32771]="CONSTANT_ALPHA",l[l.ONE_MINUS_CONSTANT_ALPHA=32772]="ONE_MINUS_CONSTANT_ALPHA",l[l.SRC_ALPHA_SATURATE=776]="SRC_ALPHA_SATURATE"})(BABYLON||(BABYLON={})),(function(W){!(function(w){var V,e;(e=V||(V={}))[e.IDENTIFIER=1]="IDENTIFIER",e[e.UNKNOWN=2]="UNKNOWN",e[e.END_OF_INPUT=3]="END_OF_INPUT";var G=(function(){function e(e){this._pos=0,this.currentToken=V.UNKNOWN,this.currentIdentifier="",this.currentString="",this.isLetterOrDigitPattern=/^[a-zA-Z0-9]+$/,this._toParse=e,this._maxPos=e.length}return e.prototype.getNextToken=function(){if(this.isEnd())return V.END_OF_INPUT;if(this.currentString=this.read(),this.currentToken=V.UNKNOWN,"_"===this.currentString||this.isLetterOrDigitPattern.test(this.currentString))for(this.currentToken=V.IDENTIFIER,this.currentIdentifier=this.currentString;!this.isEnd()&&(this.isLetterOrDigitPattern.test(this.currentString=this.peek())||"_"===this.currentString);)this.currentIdentifier+=this.currentString,this.forward();return this.currentToken},e.prototype.peek=function(){return this._toParse[this._pos]},e.prototype.read=function(){return this._toParse[this._pos++]},e.prototype.forward=function(){this._pos++},e.prototype.isEnd=function(){return this._pos>=this._maxPos},e})(),D=["MODEL","VIEW","PROJECTION","MODELVIEW","MODELVIEWPROJECTION","JOINTMATRIX"],U=["world","view","projection","worldView","worldViewProjection","mBones"],M=["translation","rotation","scale"],x=["position","rotationQuaternion","scaling"],o=function(e,n,r){for(var t in e){var o=e[t];r[n][t]=o}},F=function(e){if(e)for(var n=0;n<e.length/2;n++)e[2*n+1]=1-e[2*n+1]},k=function(e){if("NORMAL"===e.semantic)return"normal";if("POSITION"===e.semantic)return"position";if("JOINT"===e.semantic)return"matricesIndices";if("WEIGHT"===e.semantic)return"matricesWeights";if("COLOR"===e.semantic)return"color";if(e.semantic&&-1!==e.semantic.indexOf("TEXCOORD_")){var n=Number(e.semantic.split("_")[1]);return"uv"+(0===n?"":n+1)}return null},_=function(e){var n=null;if(e.translation||e.rotation||e.scale){var r=W.Vector3.FromArray(e.scale||[1,1,1]),t=W.Quaternion.FromArray(e.rotation||[0,0,0,1]),o=W.Vector3.FromArray(e.translation||[0,0,0]);n=W.Matrix.Compose(r,t,o)}else n=W.Matrix.FromArray(e.matrix);return n},v=function(e,n,r,t){for(var o=0;o<t.bones.length;o++)if(t.bones[o].name===r)return t.bones[o];var i=e.nodes;for(var a in i){var s=i[a];if(s.jointName){var u=s.children;for(o=0;o<u.length;o++){var l=e.nodes[u[o]];if(l.jointName&&l.jointName===r){var c=_(s),f=new W.Bone(s.name||"",t,v(e,n,s.jointName,t),c);return f.id=a,f}}}}return null},O=function(e,n){for(var r=0;r<e.length;r++)for(var t=e[r],o=0;o<t.node.children.length;o++){if(t.node.children[o]===n)return t.bone}return null},L=function(e,n){var r=e.nodes,t=r[n];if(t)return{node:t,id:n};for(var o in r)if((t=r[o]).jointName===n)return{node:t,id:o};return null},b=function(e,n){for(var r=0;r<e.jointNames.length;r++)if(e.jointNames[r]===n)return!0;return!1},g=function(e,n,r,t,o){if(t||(t=new W.Skeleton(n.name||"","",e.scene)),!n.babylonSkeleton)return t;var i=[],a=[];!(function(e,n,r,t){for(var o in e.nodes){var i=e.nodes[o],a=o;if(i.jointName&&!b(r,i.jointName)){var s=_(i),u=new W.Bone(i.name||"",n,null,s);u.id=a,t.push({bone:u,node:i,id:a})}}for(var l=0;l<t.length;l++)for(var c=t[l],f=c.node.children,d=0;d<f.length;d++){for(var m=null,h=0;h<t.length;h++)if(t[h].id===f[d]){m=t[h];break}m&&(m.bone._parent=c.bone,c.bone.children.push(m.bone))}})(e,t,n,i),t.bones=[];for(var s=0;s<n.jointNames.length;s++){if(y=L(e,n.jointNames[s])){var u=y.node;if(u){o=y.id;var l=e.scene.getBoneByID(o);if(l)t.bones.push(l);else{for(var c=!1,f=null,d=0;d<s;d++){var m=L(e,n.jointNames[d]);if(m){var h=m.node;if(h){var p=h.children;if(p){c=!1;for(var E=0;E<p.length;E++)if(p[E]===o){f=v(e,n,n.jointNames[d],t),c=!0;break}if(c)break}}else W.Tools.Warn("Joint named "+n.jointNames[d]+" does not exist when looking for parent")}}var T=_(u);!f&&0<i.length&&(f=O(i,o))&&-1===a.indexOf(f)&&a.push(f),new W.Bone(u.jointName||"",t,f,T).id=o}}else W.Tools.Warn("Joint named "+n.jointNames[s]+" does not exist")}}var A=t.bones;t.bones=[];for(s=0;s<n.jointNames.length;s++){var y;if(y=L(e,n.jointNames[s]))for(d=0;d<A.length;d++)if(A[d].id===y.id){t.bones.push(A[d]);break}}t.prepare();for(s=0;s<a.length;s++)t.bones.push(a[s]);return t},N=function(e,n,r,t,o){if(o||((o=new W.Mesh(n.name||"",e.scene)).id=t),!n.babylonNode)return o;for(var i,a=[],s=null,u=new Array,l=new Array,c=new Array,f=new Array,d=0;d<r.length;d++){var m=r[d];if(M=e.meshes[m])for(var h=0;h<M.primitives.length;h++){var p=new W.VertexData,E=M.primitives[h];E.mode;var T=E.attributes,A=null,y=null;for(var _ in T)if(A=e.accessors[T[_]],y=w.GLTFUtils.GetBufferFromAccessor(e,A),"NORMAL"===_)p.normals=new Float32Array(y.length),p.normals.set(y);else if("POSITION"===_){if(W.GLTFFileLoader.HomogeneousCoordinates){p.positions=new Float32Array(y.length-y.length/4);for(var v=0;v<y.length;v+=4)p.positions[v]=y[v],p.positions[v+1]=y[v+1],p.positions[v+2]=y[v+2]}else p.positions=new Float32Array(y.length),p.positions.set(y);l.push(p.positions.length)}else if(-1!==_.indexOf("TEXCOORD_")){var O=Number(_.split("_")[1]),L=W.VertexBuffer.UVKind+(0===O?"":O+1),b=new Float32Array(y.length);b.set(y),F(b),p.set(b,L)}else"JOINT"===_?(p.matricesIndices=new Float32Array(y.length),p.matricesIndices.set(y)):"WEIGHT"===_?(p.matricesWeights=new Float32Array(y.length),p.matricesWeights.set(y)):"COLOR"===_&&(p.colors=new Float32Array(y.length),p.colors.set(y));if(A=e.accessors[E.indices])y=w.GLTFUtils.GetBufferFromAccessor(e,A),p.indices=new Int32Array(y.length),p.indices.set(y),f.push(p.indices.length);else{var g=[];for(v=0;v<p.positions.length/3;v++)g.push(v);p.indices=new Int32Array(g),f.push(p.indices.length)}s?s.merge(p):s=p;var N=e.scene.getMaterialByID(E.material);a.push(null===N?w.GLTFUtils.GetDefaultMaterial(e.scene):N),u.push(0===u.length?0:u[u.length-1]+l[l.length-2]),c.push(0===c.length?0:c[c.length-1]+f[f.length-2])}}1<a.length?(i=new W.MultiMaterial("multimat"+t,e.scene)).subMaterials=a:i=new W.StandardMaterial("multimat"+t,e.scene),1===a.length&&(i=a[0]),o.material||(o.material=i),new W.Geometry(t,e.scene,s,!1,o),o.computeWorldMatrix(!0),o.subMeshes=[];var S=0;for(d=0;d<r.length;d++){var M;m=r[d];if(M=e.meshes[m])for(h=0;h<M.primitives.length;h++)M.primitives[h].mode,W.SubMesh.AddToMesh(S,u[S],l[S],c[S],f[S],o,o,!0),S++}return o},S=function(e,n,r,t){e.position&&(e.position=n),(e.rotationQuaternion||e.rotation)&&(e.rotationQuaternion=r),e.scaling&&(e.scaling=t)},s=function(e,n,r,t){var o=null;if(e.importOnlyMeshes&&(n.skin||n.meshes)&&e.importMeshesNames&&0<e.importMeshesNames.length&&-1===e.importMeshesNames.indexOf(n.name||""))return null;if(n.skin){if(n.meshes){var i=e.skins[n.skin];(a=N(e,n,n.meshes,r,n.babylonNode)).skeleton=e.scene.getLastSkeletonByID(n.skin),null===a.skeleton&&(a.skeleton=g(e,i,0,i.babylonSkeleton,n.skin),i.babylonSkeleton||(i.babylonSkeleton=a.skeleton)),o=a}}else if(n.meshes){var a;o=a=N(e,n,n.mesh?[n.mesh]:n.meshes,r,n.babylonNode)}else if(!n.light||n.babylonNode||e.importOnlyMeshes){if(n.camera&&!n.babylonNode&&!e.importOnlyMeshes){var s=e.cameras[n.camera];if(s)if("orthographic"===s.type){var u=new W.FreeCamera(n.camera,W.Vector3.Zero(),e.scene,!1);u.name=n.name||"",u.mode=W.Camera.ORTHOGRAPHIC_CAMERA,u.attachControl(e.scene.getEngine().getRenderingCanvas()),o=u}else if("perspective"===s.type){var l=s[s.type],c=new W.FreeCamera(n.camera,W.Vector3.Zero(),e.scene,!1);c.name=n.name||"",c.attachControl(e.scene.getEngine().getRenderingCanvas()),l.aspectRatio||(l.aspectRatio=e.scene.getEngine().getRenderWidth()/e.scene.getEngine().getRenderHeight()),l.znear&&l.zfar&&(c.maxZ=l.zfar,c.minZ=l.znear),o=c}}}else{var f=e.lights[n.light];if(f)if("ambient"===f.type){var d=f[f.type],m=new W.HemisphericLight(n.light,W.Vector3.Zero(),e.scene);m.name=n.name||"",d.color&&(m.diffuse=W.Color3.FromArray(d.color)),o=m}else if("directional"===f.type){var h=f[f.type],p=new W.DirectionalLight(n.light,W.Vector3.Zero(),e.scene);p.name=n.name||"",h.color&&(p.diffuse=W.Color3.FromArray(h.color)),o=p}else if("point"===f.type){var E=f[f.type],T=new W.PointLight(n.light,W.Vector3.Zero(),e.scene);T.name=n.name||"",E.color&&(T.diffuse=W.Color3.FromArray(E.color)),o=T}else if("spot"===f.type){var A=f[f.type],y=new W.SpotLight(n.light,W.Vector3.Zero(),W.Vector3.Zero(),0,0,e.scene);y.name=n.name||"",A.color&&(y.diffuse=W.Color3.FromArray(A.color)),A.fallOfAngle&&(y.angle=A.fallOfAngle),A.fallOffExponent&&(y.exponent=A.fallOffExponent),o=y}}if(!n.jointName){if(n.babylonNode)return n.babylonNode;if(null===o){var _=new W.Mesh(n.name||"",e.scene);o=n.babylonNode=_}}if(null!==o){if(n.matrix&&o instanceof W.Mesh)!(function(e,n,r){if(n.matrix){var t=new W.Vector3(0,0,0),o=new W.Quaternion,i=new W.Vector3(0,0,0);W.Matrix.FromArray(n.matrix).decompose(i,o,t),S(e,t,o,i)}else n.translation&&n.rotation&&n.scale&&S(e,W.Vector3.FromArray(n.translation),W.Quaternion.FromArray(n.rotation),W.Vector3.FromArray(n.scale));e.computeWorldMatrix(!0)})(o,n);else{var v=n.translation||[0,0,0],O=n.rotation||[0,0,0,1],L=n.scale||[1,1,1];S(o,W.Vector3.FromArray(v),W.Quaternion.FromArray(O),W.Vector3.FromArray(L))}o.updateCache(!0),n.babylonNode=o}return o},u=function(e,n,r,t){void 0===t&&(t=!1);var o=e.nodes[n],i=null;if(t=!(e.importOnlyMeshes&&!t&&e.importMeshesNames)||(-1!==e.importMeshesNames.indexOf(o.name||"")||0===e.importMeshesNames.length),!o.jointName&&t&&null!==(i=s(e,o,n))&&(i.id=n,i.parent=r),o.children)for(var a=0;a<o.children.length;a++)u(e,o.children[a],i,t)},f=function(e){var n=e.currentScene;if(n)for(var r=0;r<n.nodes.length;r++)u(e,n.nodes[r],null);else for(var t in e.scenes){n=e.scenes[t];for(r=0;r<n.nodes.length;r++)u(e,n.nodes[r],null)}!(function(e){for(var n in e.animations){var r=e.animations[n];if(r.channels&&r.samplers)for(var t=null,o=0;o<r.channels.length;o++){var i=r.channels[o],a=r.samplers[i.sampler];if(a){var s=null,u=null;u=r.parameters?(s=r.parameters[a.input],r.parameters[a.output]):(s=a.input,a.output);var l=w.GLTFUtils.GetBufferFromAccessor(e,e.accessors[s]),c=w.GLTFUtils.GetBufferFromAccessor(e,e.accessors[u]),f=i.target.id,d=e.scene.getNodeByID(f);if(null===d&&(d=e.scene.getNodeByName(f)),null!==d){var m=d instanceof W.Bone,h=i.target.path,p=M.indexOf(h);-1!==p&&(h=x[p]);var E=W.Animation.ANIMATIONTYPE_MATRIX;m||("rotationQuaternion"===h?(E=W.Animation.ANIMATIONTYPE_QUATERNION,d.rotationQuaternion=new W.Quaternion):E=W.Animation.ANIMATIONTYPE_VECTOR3);var T=null,A=[],y=0,_=!1;m&&t&&t.getKeys().length===l.length&&(T=t,_=!0),_||(T=new W.Animation(n,m?"_matrix":h,1,E,W.Animation.ANIMATIONLOOPMODE_CYCLE));for(var v=0;v<l.length;v++){var O=null;if("rotationQuaternion"===h?(O=W.Quaternion.FromArray([c[y],c[y+1],c[y+2],c[y+3]]),y+=4):(O=W.Vector3.FromArray([c[y],c[y+1],c[y+2]]),y+=3),m){var L=d,b=W.Vector3.Zero(),g=new W.Quaternion,N=W.Vector3.Zero(),S=L.getBaseMatrix();_&&t&&(S=t.getKeys()[v].value),S.decompose(N,g,b),"position"===h?b=O:"rotationQuaternion"===h?g=O:N=O,O=W.Matrix.Compose(N,g,b)}_?t&&(t.getKeys()[v].value=O):A.push({frame:l[v],value:O})}!_&&T&&(T.setKeys(A),d.animations.push(T)),t=T,e.scene.stopAnimation(d),e.scene.beginAnimation(d,0,l[l.length-1],!0,1)}else W.Tools.Warn("Creating animation named "+n+". But cannot find node named "+f+" to attach to")}}}})(e);for(r=0;r<e.scene.skeletons.length;r++){var o=e.scene.skeletons[r];e.scene.beginAnimation(o,0,Number.MAX_VALUE,!0,1)}},j=function(n,r,t,o,i,a){return function(e){!(function(e,r,n,t,o){var i=t.values||n.parameters,a=n.uniforms;for(var s in o){var u=o[s],l=u.type,c=i[a[s]];if(void 0===c&&(c=u.value),c){var f=function(n){return function(e){u.value&&n&&(r.setTexture(n,e),delete o[n])}};l===w.EParameterType.SAMPLER_2D?w.GLTFLoaderExtension.LoadTextureAsync(e,t.values?c:u.value,f(s),(function(){return f(null)})):u.value&&w.GLTFUtils.SetUniform(r,s,t.values?c:u.value,l)&&delete o[s]}}})(n,r,t,o,i),r.onBind=function(e){!(function(e,n,r,t,o,i,a){var s=i.values||o.parameters;for(var u in r){var l=r[u],c=l.type;if(c===w.EParameterType.FLOAT_MAT2||c===w.EParameterType.FLOAT_MAT3||c===w.EParameterType.FLOAT_MAT4)if(!l.semantic||l.source||l.node){if(l.semantic&&(l.source||l.node)){var f=n.scene.getNodeByName(l.source||l.node||"");if(null===f&&(f=n.scene.getNodeByID(l.source||l.node||"")),null===f)continue;w.GLTFUtils.SetMatrix(n.scene,f,l,u,t.getEffect())}}else w.GLTFUtils.SetMatrix(n.scene,e,l,u,t.getEffect());else{var d=s[o.uniforms[u]];if(!d)continue;if(c===w.EParameterType.SAMPLER_2D){var m=n.textures[i.values?d:l.value].babylonTexture;if(null==m)continue;t.getEffect().setTexture(u,m)}else w.GLTFUtils.SetUniform(t.getEffect(),u,d,c)}}a(t)})(e,n,i,r,t,o,a)}}},H=function(e,n,r){for(var t in n.uniforms){var o=n.uniforms[t],i=n.parameters[o];if(e.currentIdentifier===t&&i.semantic&&!i.source&&!i.node){var a=D.indexOf(i.semantic);if(-1!==a)return delete r[t],U[a]}}return e.currentIdentifier},d=function(e){for(var n in e.materials)w.GLTFLoaderExtension.LoadMaterialAsync(e,n,(function(e){}),(function(){}))},n=(function(){function e(){}return e.CreateRuntime=function(e,n,r){var t={extensions:{},accessors:{},buffers:{},bufferViews:{},meshes:{},lights:{},cameras:{},nodes:{},images:{},textures:{},shaders:{},programs:{},samplers:{},techniques:{},materials:{},animations:{},skins:{},extensionsUsed:[],scenes:{},buffersCount:0,shaderscount:0,scene:n,rootUrl:r,loadedBufferCount:0,loadedBufferViews:{},loadedShaderCount:0,importOnlyMeshes:!1,dummyNodes:[]};return e.extensions&&o(e.extensions,"extensions",t),e.extensionsUsed&&o(e.extensionsUsed,"extensionsUsed",t),e.buffers&&(function(e,n){for(var r in e){var t=e[r];n.buffers[r]=t,n.buffersCount++}})(e.buffers,t),e.bufferViews&&o(e.bufferViews,"bufferViews",t),e.accessors&&o(e.accessors,"accessors",t),e.meshes&&o(e.meshes,"meshes",t),e.lights&&o(e.lights,"lights",t),e.cameras&&o(e.cameras,"cameras",t),e.nodes&&o(e.nodes,"nodes",t),e.images&&o(e.images,"images",t),e.textures&&o(e.textures,"textures",t),e.shaders&&(function(e,n){for(var r in e){var t=e[r];n.shaders[r]=t,n.shaderscount++}})(e.shaders,t),e.programs&&o(e.programs,"programs",t),e.samplers&&o(e.samplers,"samplers",t),e.techniques&&o(e.techniques,"techniques",t),e.materials&&o(e.materials,"materials",t),e.animations&&o(e.animations,"animations",t),e.skins&&o(e.skins,"skins",t),e.scenes&&(t.scenes=e.scenes),e.scene&&e.scenes&&(t.currentScene=e.scenes[e.scene]),t},e.LoadBufferAsync=function(e,n,r,t,o){var i=e.buffers[n];W.Tools.IsBase64(i.uri)?setTimeout((function(){return r(new Uint8Array(W.Tools.DecodeBase64(i.uri)))})):W.Tools.LoadFile(e.rootUrl+i.uri,(function(e){return r(new Uint8Array(e))}),o,void 0,!0,(function(e){e&&t(e.status+" "+e.statusText)}))},e.LoadTextureBufferAsync=function(e,n,r,t){var o=e.textures[n];if(o&&o.source)if(o.babylonTexture)r(null);else{var i=e.images[o.source];W.Tools.IsBase64(i.uri)?setTimeout((function(){return r(new Uint8Array(W.Tools.DecodeBase64(i.uri)))})):W.Tools.LoadFile(e.rootUrl+i.uri,(function(e){return r(new Uint8Array(e))}),void 0,void 0,!0,(function(e){e&&t(e.status+" "+e.statusText)}))}else t("")},e.CreateTextureAsync=function(e,n,r,t,o){var i=e.textures[n];if(i.babylonTexture)t(i.babylonTexture);else{var a=e.samplers[i.sampler],s=a.minFilter===w.ETextureFilterType.NEAREST_MIPMAP_NEAREST||a.minFilter===w.ETextureFilterType.NEAREST_MIPMAP_LINEAR||a.minFilter===w.ETextureFilterType.LINEAR_MIPMAP_NEAREST||a.minFilter===w.ETextureFilterType.LINEAR_MIPMAP_LINEAR,u=W.Texture.BILINEAR_SAMPLINGMODE,l=null==r?new Blob:new Blob([r]),c=URL.createObjectURL(l),f=function(){return URL.revokeObjectURL(c)},d=new W.Texture(c,e.scene,!s,!0,u,f,f);void 0!==a.wrapS&&(d.wrapU=w.GLTFUtils.GetWrapMode(a.wrapS)),void 0!==a.wrapT&&(d.wrapV=w.GLTFUtils.GetWrapMode(a.wrapT)),d.name=n,t(i.babylonTexture=d)}},e.LoadShaderStringAsync=function(e,n,r,t){var o=e.shaders[n];if(W.Tools.IsBase64(o.uri)){var i=atob(o.uri.split(",")[1]);r&&r(i)}else W.Tools.LoadFile(e.rootUrl+o.uri,r,void 0,void 0,!1,(function(e){e&&t&&t(e.status+" "+e.statusText)}))},e.LoadMaterialAsync=function(e,n,r,t){var o=e.materials[n];if(o.technique){var i=e.techniques[o.technique];if(!i){var a=new W.StandardMaterial(n,e.scene);return a.diffuseColor=new W.Color3(.5,.5,.5),a.sideOrientation=W.Material.CounterClockWiseSideOrientation,void r(a)}var s=e.programs[i.program],u=i.states,l=W.Effect.ShadersStore[s.vertexShader+"VertexShader"],c=W.Effect.ShadersStore[s.fragmentShader+"PixelShader"],f="",d="",m=new G(l),h=new G(c),p={},E=[],T=[],A=[];for(var y in i.uniforms){var _=i.uniforms[y],v=i.parameters[_];if(!(p[y]=v).semantic||v.node||v.source)v.type===w.EParameterType.SAMPLER_2D?A.push(y):E.push(y);else{var O=D.indexOf(v.semantic);-1!==O?(E.push(U[O]),delete p[y]):E.push(y)}}for(var L in i.attributes){var b=i.attributes[L];if((S=i.parameters[b]).semantic){var g=k(S);g&&T.push(g)}}for(;!m.isEnd()&&m.getNextToken();){if(m.currentToken===V.IDENTIFIER){var N=!1;for(var L in i.attributes){b=i.attributes[L];var S=i.parameters[b];if(m.currentIdentifier===L&&S.semantic){f+=k(S),N=!0;break}}N||(f+=H(m,i,p))}else f+=m.currentString}for(;!h.isEnd()&&h.getNextToken();){h.currentToken===V.IDENTIFIER?d+=H(h,i,p):d+=h.currentString}var M={vertex:s.vertexShader+n,fragment:s.fragmentShader+n},x={attributes:T,uniforms:E,samplers:A,needAlphaBlending:u&&u.enable&&-1!==u.enable.indexOf(3042)};W.Effect.ShadersStore[s.vertexShader+n+"VertexShader"]=f,W.Effect.ShadersStore[s.fragmentShader+n+"PixelShader"]=d;var F,C,P,R=new W.ShaderMaterial(n,e.scene,M,x);if(R.onError=(F=s,C=R,P=t,function(e,n){C.dispose(!0),P("Cannot compile program named "+F.name+". Error: "+n+". Default material will be applied")}),R.onCompiled=j(e,R,i,o,p,r),R.sideOrientation=W.Material.CounterClockWiseSideOrientation,u&&u.functions){var I=u.functions;I.cullFace&&I.cullFace[0]!==w.ECullingType.BACK&&(R.backFaceCulling=!1);var B=I.blendFuncSeparate;B&&(B[0]===w.EBlendingFunction.SRC_ALPHA&&B[1]===w.EBlendingFunction.ONE_MINUS_SRC_ALPHA&&B[2]===w.EBlendingFunction.ONE&&B[3]===w.EBlendingFunction.ONE?R.alphaMode=W.Engine.ALPHA_COMBINE:B[0]===w.EBlendingFunction.ONE&&B[1]===w.EBlendingFunction.ONE&&B[2]===w.EBlendingFunction.ZERO&&B[3]===w.EBlendingFunction.ONE?R.alphaMode=W.Engine.ALPHA_ONEONE:B[0]===w.EBlendingFunction.SRC_ALPHA&&B[1]===w.EBlendingFunction.ONE&&B[2]===w.EBlendingFunction.ZERO&&B[3]===w.EBlendingFunction.ONE?R.alphaMode=W.Engine.ALPHA_ADD:B[0]===w.EBlendingFunction.ZERO&&B[1]===w.EBlendingFunction.ONE_MINUS_SRC_COLOR&&B[2]===w.EBlendingFunction.ONE&&B[3]===w.EBlendingFunction.ONE?R.alphaMode=W.Engine.ALPHA_SUBTRACT:B[0]===w.EBlendingFunction.DST_COLOR&&B[1]===w.EBlendingFunction.ZERO&&B[2]===w.EBlendingFunction.ONE&&B[3]===w.EBlendingFunction.ONE?R.alphaMode=W.Engine.ALPHA_MULTIPLY:B[0]===w.EBlendingFunction.SRC_ALPHA&&B[1]===w.EBlendingFunction.ONE_MINUS_SRC_COLOR&&B[2]===w.EBlendingFunction.ONE&&B[3]===w.EBlendingFunction.ONE&&(R.alphaMode=W.Engine.ALPHA_MAXIMIZED))}}else t&&t("No technique found.")},e})();w.GLTFLoaderBase=n;var r=(function(){function n(){this.state=null}return n.RegisterExtension=function(e){n.Extensions[e.name]?W.Tools.Error('Tool with the same name "'+e.name+'" already exists'):n.Extensions[e.name]=e},n.prototype.dispose=function(){},n.prototype._importMeshAsync=function(s,e,n,r,u,l,t){var c=this;return e.useRightHandedSystem=!0,w.GLTFLoaderExtension.LoadRuntimeAsync(e,n,r,(function(e){e.importOnlyMeshes=!0,""===s?e.importMeshesNames=[]:"string"==typeof s?e.importMeshesNames=[s]:!s||s instanceof Array?(e.importMeshesNames=[],W.Tools.Warn("Argument meshesNames must be of type string or string[]")):e.importMeshesNames=[s],c._createNodes(e);var n=new Array,r=new Array;for(var t in e.nodes){var o=e.nodes[t];o.babylonNode instanceof W.AbstractMesh&&n.push(o.babylonNode)}for(var i in e.skins){var a=e.skins[i];a.babylonSkeleton instanceof W.Skeleton&&r.push(a.babylonSkeleton)}c._loadBuffersAsync(e,(function(){c._loadShadersAsync(e,(function(){d(e),f(e),!W.GLTFFileLoader.IncrementalLoading&&u&&u(n,r)}))}),l),W.GLTFFileLoader.IncrementalLoading&&u&&u(n,r)}),t),!0},n.prototype.importMeshAsync=function(e,t,o,i,a){var s=this;return new Promise(function(r,n){s._importMeshAsync(e,t,o,i,(function(e,n){r({meshes:e,particleSystems:[],skeletons:n,animationGroups:[]})}),a,(function(e){n(new Error(e))}))})},n.prototype._loadAsync=function(e,n,r,t,o,i){var a=this;e.useRightHandedSystem=!0,w.GLTFLoaderExtension.LoadRuntimeAsync(e,n,r,(function(e){w.GLTFLoaderExtension.LoadRuntimeExtensionsAsync(e,(function(){a._createNodes(e),a._loadBuffersAsync(e,(function(){a._loadShadersAsync(e,(function(){d(e),f(e),W.GLTFFileLoader.IncrementalLoading||t()}))})),W.GLTFFileLoader.IncrementalLoading&&t()}),i)}),i)},n.prototype.loadAsync=function(r,t,o,i){var a=this;return new Promise(function(e,n){a._loadAsync(r,t,o,(function(){e()}),i,(function(e){n(new Error(e))}))})},n.prototype._loadShadersAsync=function(t,o){var e=!1,n=function(n,r){w.GLTFLoaderExtension.LoadShaderStringAsync(t,n,(function(e){e instanceof ArrayBuffer||(t.loadedShaderCount++,e&&(W.Effect.ShadersStore[n+(r.type===w.EShaderType.VERTEX?"VertexShader":"PixelShader")]=e),t.loadedShaderCount===t.shaderscount&&o())}),(function(){W.Tools.Error("Error when loading shader program named "+n+" located at "+r.uri)}))};for(var r in t.shaders){e=!0;var i=t.shaders[r];i?n.bind(this,r,i)():W.Tools.Error("No shader named: "+r)}e||o()},n.prototype._loadBuffersAsync=function(t,o,e){var n=!1,r=function(n,r){w.GLTFLoaderExtension.LoadBufferAsync(t,n,(function(e){t.loadedBufferCount++,e&&(e.byteLength!=t.buffers[n].byteLength&&W.Tools.Error("Buffer named "+n+" is length "+e.byteLength+". Expected: "+r.byteLength),t.loadedBufferViews[n]=e),t.loadedBufferCount===t.buffersCount&&o()}),(function(){W.Tools.Error("Error when loading buffer named "+n+" located at "+r.uri)}))};for(var i in t.buffers){n=!0;var a=t.buffers[i];a?r.bind(this,i,a)():W.Tools.Error("No buffer named: "+i)}n||o()},n.prototype._createNodes=function(e){var n=e.currentScene;if(n)for(var r=0;r<n.nodes.length;r++)u(e,n.nodes[r],null);else for(var t in e.scenes){n=e.scenes[t];for(r=0;r<n.nodes.length;r++)u(e,n.nodes[r],null)}},n.Extensions={},n})();w.GLTFLoader=r,W.GLTFFileLoader._CreateGLTFLoaderV1=function(){return new r}})(W.GLTF1||(W.GLTF1={}))})(BABYLON||(BABYLON={})),(function(a){var s,e;s=a.GLTF1||(a.GLTF1={}),e=(function(){function o(){}return o.SetMatrix=function(e,n,r,t,o){var i=null;if("MODEL"===r.semantic?i=n.getWorldMatrix():"PROJECTION"===r.semantic?i=e.getProjectionMatrix():"VIEW"===r.semantic?i=e.getViewMatrix():"MODELVIEWINVERSETRANSPOSE"===r.semantic?i=a.Matrix.Transpose(n.getWorldMatrix().multiply(e.getViewMatrix()).invert()):"MODELVIEW"===r.semantic?i=n.getWorldMatrix().multiply(e.getViewMatrix()):"MODELVIEWPROJECTION"===r.semantic?i=n.getWorldMatrix().multiply(e.getTransformMatrix()):"MODELINVERSE"===r.semantic?i=n.getWorldMatrix().invert():"VIEWINVERSE"===r.semantic?i=e.getViewMatrix().invert():"PROJECTIONINVERSE"===r.semantic?i=e.getProjectionMatrix().invert():"MODELVIEWINVERSE"===r.semantic?i=n.getWorldMatrix().multiply(e.getViewMatrix()).invert():"MODELVIEWPROJECTIONINVERSE"===r.semantic?i=n.getWorldMatrix().multiply(e.getTransformMatrix()).invert():"MODELINVERSETRANSPOSE"===r.semantic&&(i=a.Matrix.Transpose(n.getWorldMatrix().invert())),i)switch(r.type){case s.EParameterType.FLOAT_MAT2:o.setMatrix2x2(t,a.Matrix.GetAsMatrix2x2(i));break;case s.EParameterType.FLOAT_MAT3:o.setMatrix3x3(t,a.Matrix.GetAsMatrix3x3(i));break;case s.EParameterType.FLOAT_MAT4:o.setMatrix(t,i)}},o.SetUniform=function(e,n,r,t){switch(t){case s.EParameterType.FLOAT:return e.setFloat(n,r),!0;case s.EParameterType.FLOAT_VEC2:return e.setVector2(n,a.Vector2.FromArray(r)),!0;case s.EParameterType.FLOAT_VEC3:return e.setVector3(n,a.Vector3.FromArray(r)),!0;case s.EParameterType.FLOAT_VEC4:return e.setVector4(n,a.Vector4.FromArray(r)),!0;default:return!1}},o.GetWrapMode=function(e){switch(e){case s.ETextureWrapMode.CLAMP_TO_EDGE:return a.Texture.CLAMP_ADDRESSMODE;case s.ETextureWrapMode.MIRRORED_REPEAT:return a.Texture.MIRROR_ADDRESSMODE;case s.ETextureWrapMode.REPEAT:default:return a.Texture.WRAP_ADDRESSMODE}},o.GetByteStrideFromType=function(e){switch(e.type){case"VEC2":return 2;case"VEC3":return 3;case"VEC4":case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;default:return 1}},o.GetTextureFilterMode=function(e){switch(e){case s.ETextureFilterType.LINEAR:case s.ETextureFilterType.LINEAR_MIPMAP_NEAREST:case s.ETextureFilterType.LINEAR_MIPMAP_LINEAR:return a.Texture.TRILINEAR_SAMPLINGMODE;case s.ETextureFilterType.NEAREST:case s.ETextureFilterType.NEAREST_MIPMAP_NEAREST:return a.Texture.NEAREST_SAMPLINGMODE;default:return a.Texture.BILINEAR_SAMPLINGMODE}},o.GetBufferFromBufferView=function(e,n,r,t,o){r=n.byteOffset+r;var i=e.loadedBufferViews[n.buffer];if(r+t>i.byteLength)throw new Error("Buffer access is out of range");var a=i.buffer;switch(r+=i.byteOffset,o){case s.EComponentType.BYTE:return new Int8Array(a,r,t);case s.EComponentType.UNSIGNED_BYTE:return new Uint8Array(a,r,t);case s.EComponentType.SHORT:return new Int16Array(a,r,t);case s.EComponentType.UNSIGNED_SHORT:return new Uint16Array(a,r,t);default:return new Float32Array(a,r,t)}},o.GetBufferFromAccessor=function(e,n){var r=e.bufferViews[n.bufferView],t=n.count*o.GetByteStrideFromType(n);return o.GetBufferFromBufferView(e,r,n.byteOffset,t,n.componentType)},o.DecodeBufferToText=function(e){for(var n="",r=e.byteLength,t=0;t<r;++t)n+=String.fromCharCode(e[t]);return n},o.GetDefaultMaterial=function(e){if(!o._DefaultMaterial){a.Effect.ShadersStore.GLTFDefaultMaterialVertexShader=["precision highp float;","","uniform mat4 worldView;","uniform mat4 projection;","","attribute vec3 position;","","void main(void)","{","    gl_Position = projection * worldView * vec4(position, 1.0);","}"].join("\n"),a.Effect.ShadersStore.GLTFDefaultMaterialPixelShader=["precision highp float;","","uniform vec4 u_emission;","","void main(void)","{","    gl_FragColor = u_emission;","}"].join("\n");var n={attributes:["position"],uniforms:["worldView","projection","u_emission"],samplers:new Array,needAlphaBlending:!1};(o._DefaultMaterial=new a.ShaderMaterial("GLTFDefaultMaterial",e,{vertex:"GLTFDefaultMaterial",fragment:"GLTFDefaultMaterial"},n)).setColor4("u_emission",new a.Color4(.5,.5,.5,1))}return o._DefaultMaterial},o._DefaultMaterial=null,o})(),s.GLTFUtils=e})(BABYLON||(BABYLON={})),(function(e){var s,n;s=e.GLTF1||(e.GLTF1={}),n=(function(){function a(e){this._name=e}return Object.defineProperty(a.prototype,"name",{get:function(){return this._name},enumerable:!0,configurable:!0}),a.prototype.loadRuntimeAsync=function(e,n,r,t,o){return!1},a.prototype.loadRuntimeExtensionsAsync=function(e,n,r){return!1},a.prototype.loadBufferAsync=function(e,n,r,t,o){return!1},a.prototype.loadTextureBufferAsync=function(e,n,r,t){return!1},a.prototype.createTextureAsync=function(e,n,r,t,o){return!1},a.prototype.loadShaderStringAsync=function(e,n,r,t){return!1},a.prototype.loadMaterialAsync=function(e,n,r,t){return!1},a.LoadRuntimeAsync=function(n,r,t,o,i){a.ApplyExtensions((function(e){return e.loadRuntimeAsync(n,r,t,o,i)}),(function(){setTimeout((function(){o&&o(s.GLTFLoaderBase.CreateRuntime(r.json,n,t))}))}))},a.LoadRuntimeExtensionsAsync=function(n,r,t){a.ApplyExtensions((function(e){return e.loadRuntimeExtensionsAsync(n,r,t)}),(function(){setTimeout((function(){r()}))}))},a.LoadBufferAsync=function(n,r,t,o,i){a.ApplyExtensions((function(e){return e.loadBufferAsync(n,r,t,o,i)}),(function(){s.GLTFLoaderBase.LoadBufferAsync(n,r,t,o,i)}))},a.LoadTextureAsync=function(n,r,t,o){a.LoadTextureBufferAsync(n,r,(function(e){e&&a.CreateTextureAsync(n,r,e,t,o)}),o)},a.LoadShaderStringAsync=function(n,r,t,o){a.ApplyExtensions((function(e){return e.loadShaderStringAsync(n,r,t,o)}),(function(){s.GLTFLoaderBase.LoadShaderStringAsync(n,r,t,o)}))},a.LoadMaterialAsync=function(n,r,t,o){a.ApplyExtensions((function(e){return e.loadMaterialAsync(n,r,t,o)}),(function(){s.GLTFLoaderBase.LoadMaterialAsync(n,r,t,o)}))},a.LoadTextureBufferAsync=function(n,r,t,o){a.ApplyExtensions((function(e){return e.loadTextureBufferAsync(n,r,t,o)}),(function(){s.GLTFLoaderBase.LoadTextureBufferAsync(n,r,t,o)}))},a.CreateTextureAsync=function(n,r,t,o,i){a.ApplyExtensions((function(e){return e.createTextureAsync(n,r,t,o,i)}),(function(){s.GLTFLoaderBase.CreateTextureAsync(n,r,t,o,i)}))},a.ApplyExtensions=function(e,n){for(var r in s.GLTFLoader.Extensions){if(e(s.GLTFLoader.Extensions[r]))return}n()},a})(),s.GLTFLoaderExtension=n})(BABYLON||(BABYLON={}));var __extends=this&&this.__extends||(function(){var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var r in n)n.hasOwnProperty(r)&&(e[r]=n[r])})(e,n)};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}})();!(function(e){var u,n;u=e.GLTF1||(e.GLTF1={}),n=(function(e){function n(){return e.call(this,"KHR_binary_glTF")||this}return __extends(n,e),n.prototype.loadRuntimeAsync=function(e,n,r,t,o){var i=n.json.extensionsUsed;return!(!i||-1===i.indexOf(this.name)||!n.bin)&&(this._bin=n.bin,t(u.GLTFLoaderBase.CreateRuntime(n.json,e,r)),!0)},n.prototype.loadBufferAsync=function(e,n,r,t){return-1!==e.extensionsUsed.indexOf(this.name)&&("binary_glTF"===n&&(r(this._bin),!0))},n.prototype.loadTextureBufferAsync=function(e,n,r,t){var o=e.textures[n],i=e.images[o.source];if(!(i.extensions&&this.name in i.extensions))return!1;var a=i.extensions[this.name],s=e.bufferViews[a.bufferView];return r(u.GLTFUtils.GetBufferFromBufferView(e,s,0,s.byteLength,u.EComponentType.UNSIGNED_BYTE)),!0},n.prototype.loadShaderStringAsync=function(e,n,r,t){var o=e.shaders[n];if(!(o.extensions&&this.name in o.extensions))return!1;var i=o.extensions[this.name],a=e.bufferViews[i.bufferView],s=u.GLTFUtils.GetBufferFromBufferView(e,a,0,a.byteLength,u.EComponentType.UNSIGNED_BYTE);return setTimeout((function(){var e=u.GLTFUtils.DecodeBufferToText(s);r(e)})),!0},n})(u.GLTFLoaderExtension),u.GLTFBinaryExtension=n,u.GLTFLoader.RegisterExtension(new n)})(BABYLON||(BABYLON={}));var BABYLON;__extends=this&&this.__extends||(function(){var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var r in n)n.hasOwnProperty(r)&&(e[r]=n[r])})(e,n)};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}})();!(function(h){var a,e;a=h.GLTF1||(h.GLTF1={}),e=(function(e){function n(){return e.call(this,"KHR_materials_common")||this}return __extends(n,e),n.prototype.loadRuntimeExtensionsAsync=function(e,n,r){if(!e.extensions)return!1;var t=e.extensions[this.name];if(!t)return!1;var o=t.lights;if(o)for(var i in o){var a=o[i];switch(a.type){case"ambient":var s=new h.HemisphericLight(a.name,new h.Vector3(0,1,0),e.scene),u=a.ambient;u&&(s.diffuse=h.Color3.FromArray(u.color||[1,1,1]));break;case"point":var l=new h.PointLight(a.name,new h.Vector3(10,10,10),e.scene),c=a.point;c&&(l.diffuse=h.Color3.FromArray(c.color||[1,1,1]));break;case"directional":var f=new h.DirectionalLight(a.name,new h.Vector3(0,-1,0),e.scene),d=a.directional;d&&(f.diffuse=h.Color3.FromArray(d.color||[1,1,1]));break;case"spot":var m=a.spot;if(m)new h.SpotLight(a.name,new h.Vector3(0,10,0),new h.Vector3(0,-1,0),m.fallOffAngle||Math.PI,m.fallOffExponent||0,e.scene).diffuse=h.Color3.FromArray(m.color||[1,1,1]);break;default:h.Tools.Warn('GLTF Material Common extension: light type "'+a.type+"” not supported")}}return!1},n.prototype.loadMaterialAsync=function(e,n,r,t){var o=e.materials[n];if(!o||!o.extensions)return!1;var i=o.extensions[this.name];if(!i)return!1;var a=new h.StandardMaterial(n,e.scene);return a.sideOrientation=h.Material.CounterClockWiseSideOrientation,"CONSTANT"===i.technique&&(a.disableLighting=!0),a.backFaceCulling=void 0!==i.doubleSided&&!i.doubleSided,a.alpha=void 0===i.values.transparency?1:i.values.transparency,a.specularPower=void 0===i.values.shininess?0:i.values.shininess,"string"==typeof i.values.ambient?this._loadTexture(e,i.values.ambient,a,"ambientTexture",t):a.ambientColor=h.Color3.FromArray(i.values.ambient||[0,0,0]),"string"==typeof i.values.diffuse?this._loadTexture(e,i.values.diffuse,a,"diffuseTexture",t):a.diffuseColor=h.Color3.FromArray(i.values.diffuse||[0,0,0]),"string"==typeof i.values.emission?this._loadTexture(e,i.values.emission,a,"emissiveTexture",t):a.emissiveColor=h.Color3.FromArray(i.values.emission||[0,0,0]),"string"==typeof i.values.specular?this._loadTexture(e,i.values.specular,a,"specularTexture",t):a.specularColor=h.Color3.FromArray(i.values.specular||[0,0,0]),!0},n.prototype._loadTexture=function(n,r,t,o,i){a.GLTFLoaderBase.LoadTextureBufferAsync(n,r,(function(e){a.GLTFLoaderBase.CreateTextureAsync(n,r,e,(function(e){return t[o]=e}),i)}),i)},n})(a.GLTFLoaderExtension),a.GLTFMaterialsCommonExtension=e,a.GLTFLoader.RegisterExtension(new e)})(BABYLON||(BABYLON={}));
>>>>>>> upstream/master
